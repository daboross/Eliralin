From fe48450358669c3969aa054bbe417a85a6036cb5 Mon Sep 17 00:00:00 2001
From: Dabo Ross <daboross@daboross.net>
Date: Wed, 18 Jun 2014 01:09:15 -0500
Subject: [PATCH] Add @hook.event(EventType.X) for non-irc-specific event
 catching


diff --git a/cloudbot/core/bot.py b/cloudbot/core/bot.py
index 173fc62..1ad162d 100644
--- a/cloudbot/core/bot.py
+++ b/cloudbot/core/bot.py
@@ -4,8 +4,8 @@ import logging
 import re
 import os
 import gc
-
 from sqlalchemy import create_engine
+
 from sqlalchemy.orm import scoped_session, sessionmaker
 from sqlalchemy.schema import MetaData
 
@@ -197,8 +197,8 @@ class CloudBot:
         tasks = []
         command_prefix = event.conn.config.get('command_prefix', '.')
 
-        # EVENTS
-        for raw_hook in self.plugin_manager.catch_all_events:
+        # Raw IRC hook
+        for raw_hook in self.plugin_manager.catch_all_triggers:
             # run catch-all coroutine hooks before all others - TODO: Make this a plugin argument
             if not raw_hook.threaded:
                 run_before_tasks.append(
@@ -209,6 +209,11 @@ class CloudBot:
             for raw_hook in self.plugin_manager.raw_triggers[event.irc_command]:
                 tasks.append(self.plugin_manager.launch(raw_hook, BaseEvent(hook=raw_hook, base_event=event)))
 
+        # Event hooks
+        if event.type in self.plugin_manager.event_type_hooks:
+            for event_hook in self.plugin_manager.event_type_hooks[event.type]:
+                tasks.append(self.plugin_manager.launch(event_hook, BaseEvent(hook=event_hook, base_event=event)))
+
         if event.type is EventType.message:
             # Commands
             if event.chan.lower() == event.nick.lower():  # private message, no command prefix
diff --git a/cloudbot/core/pluginmanager.py b/cloudbot/core/pluginmanager.py
index 36a88e2..444385a 100644
--- a/cloudbot/core/pluginmanager.py
+++ b/cloudbot/core/pluginmanager.py
@@ -18,7 +18,7 @@ def find_hooks(parent, module):
     """
     :type parent: Plugin
     :type module: object
-    :rtype: (list[CommandHook], list[RegexHook], list[RawHook], list[SieveHook], list[OnloadHook])
+    :rtype: (list[CommandHook], list[RegexHook], list[RawHook], list[SieveHook], List[EventHook], list[OnloadHook])
     """
     # set the loaded flag
     module._cloudbot_loaded = True
@@ -26,8 +26,9 @@ def find_hooks(parent, module):
     regex = []
     raw = []
     sieve = []
+    event = []
     onload = []
-    type_lists = {"command": command, "regex": regex, "irc_raw": raw, "sieve": sieve, "onload": onload}
+    type_lists = {"command": command, "regex": regex, "irc_raw": raw, "sieve": sieve, "event": event, "onload": onload}
     for name, func in module.__dict__.items():
         if hasattr(func, "_cloudbot_hook"):
             # if it has cloudbot hook
@@ -39,7 +40,7 @@ def find_hooks(parent, module):
             # delete the hook to free memory
             del func._cloudbot_hook
 
-    return command, regex, raw, sieve, onload
+    return command, regex, raw, sieve, event, onload
 
 
 def find_tables(code):
@@ -74,14 +75,15 @@ class PluginManager:
     :type plugins: dict[str, Plugin]
     :type commands: dict[str, CommandHook]
     :type raw_triggers: dict[str, list[RawHook]]
-    :type catch_all_events: list[RawHook]
+    :type catch_all_triggers: list[RawHook]
+    :type event_type_hooks: dict[cloudbot.core.events.EventType, list[EventHook]]
     :type regex_hooks: list[(re.__Regex, RegexHook)]
     :type sieves: list[SieveHook]
     """
 
     def __init__(self, bot):
         """
-        Creates a new PluginManager. You generally only need to do this from inside core.bot.CloudBot
+        Creates a new PluginManager. You generally only need to do this from inside cloudbot.core.bot.CloudBot
         :type bot: cloudbot.core.bot.CloudBot
         """
         self.bot = bot
@@ -89,7 +91,8 @@ class PluginManager:
         self.plugins = {}
         self.commands = {}
         self.raw_triggers = {}
-        self.catch_all_events = []
+        self.catch_all_triggers = []
+        self.event_type_hooks = {}
         self.regex_hooks = []
         self.sieves = []
         self._hook_waiting_queues = {}
@@ -178,10 +181,10 @@ class PluginManager:
                     self.commands[alias] = command_hook
             self._log_hook(command_hook)
 
-        # register events
+        # register raw hooks
         for raw_hook in plugin.raw_hooks:
             if raw_hook.is_catch_all():
-                self.catch_all_events.append(raw_hook)
+                self.catch_all_triggers.append(raw_hook)
             else:
                 for trigger in raw_hook.triggers:
                     if trigger in self.raw_triggers:
@@ -190,6 +193,15 @@ class PluginManager:
                         self.raw_triggers[trigger] = [raw_hook]
             self._log_hook(raw_hook)
 
+        # register events
+        for event_hook in plugin.events:
+            for event_type in event_hook.types:
+                if event_type in self.event_type_hooks:
+                    self.event_type_hooks[event_type].append(event_hook)
+                else:
+                    self.event_type_hooks[event_type] = [event_hook]
+            self._log_hook(event_hook)
+
         # register regexps
         for regex_hook in plugin.regexes:
             for regex_match in regex_hook.regexes:
@@ -234,14 +246,24 @@ class PluginManager:
                     # we need to make sure that there wasn't a conflict, so we don't delete another plugin's command
                     del self.commands[alias]
 
-        # unregister events
+        # unregister raw hooks
         for raw_hook in plugin.raw_hooks:
             if raw_hook.is_catch_all():
-                self.catch_all_events.remove(raw_hook)
+                self.catch_all_triggers.remove(raw_hook)
             else:
-                for event_name in raw_hook.triggers:
-                    assert event_name in self.raw_triggers  # this can't be not true
-                    self.raw_triggers[event_name].remove(raw_hook)
+                for trigger in raw_hook.triggers:
+                    assert trigger in self.raw_triggers  # this can't be not true
+                    self.raw_triggers[trigger].remove(raw_hook)
+                    if not self.raw_triggers[trigger]:  # if that was the last hook for this trigger
+                        del self.raw_triggers[trigger]
+
+        # unregister events
+        for event_hook in plugin.events:
+            for event_type in event_hook.types:
+                assert event_type in self.event_type_hooks  # this can't be not true
+                self.event_type_hooks[event_type].remove(event_hook)
+                if not self.event_type_hooks[event_type]:  # if that was the last hook for this event type
+                    del self.event_type_hooks[event_type]
 
         # unregister regexps
         for regex_hook in plugin.regexes:
@@ -448,6 +470,7 @@ class Plugin:
     :type regexes: list[RegexHook]
     :type raw_hooks: list[RawHook]
     :type sieves: list[SieveHook]
+    :type events: list[EventHook]
     :type tables: list[sqlalchemy.Table]
     """
 
@@ -460,7 +483,7 @@ class Plugin:
         self.file_path = filepath
         self.file_name = filename
         self.title = title
-        self.commands, self.regexes, self.raw_hooks, self.sieves, self.run_on_load = find_hooks(self, code)
+        self.commands, self.regexes, self.raw_hooks, self.sieves, self.events, self.run_on_load = find_hooks(self, code)
         # we need to find tables for each plugin so that they can be unloaded from the global metadata when the
         # plugin is reloaded
         self.tables = find_tables(code)
@@ -604,20 +627,20 @@ class RawHook(Hook):
     :type triggers: set[str]
     """
 
-    def __init__(self, plugin, event_hook):
+    def __init__(self, plugin, irc_raw_hook):
         """
         :type plugin: Plugin
-        :type event_hook: cloudbot.util.hook._RawHook
+        :type irc_raw_hook: cloudbot.util.hook._RawHook
         """
-        super().__init__("irc_raw", plugin, event_hook)
+        super().__init__("irc_raw", plugin, irc_raw_hook)
 
-        self.triggers = event_hook.triggers
+        self.triggers = irc_raw_hook.triggers
 
     def is_catch_all(self):
         return "*" in self.triggers
 
     def __repr__(self):
-        return "Raw[events: {}, {}]".format(list(self.triggers), Hook.__repr__(self))
+        return "Raw[triggers: {}, {}]".format(list(self.triggers), Hook.__repr__(self))
 
     def __str__(self):
         return "events {} ({}) from {}".format(self.function_name, ",".join(self.triggers), self.plugin.file_name)
@@ -639,6 +662,28 @@ class SieveHook(Hook):
         return "sieve {} from {}".format(self.function_name, self.plugin.file_name)
 
 
+class EventHook(Hook):
+    """
+    :type types: set[cloudbot.core.events.EventType]
+    """
+
+    def __init__(self, plugin, event_hook):
+        """
+        :type plugin: Plugin
+        :type event_hook: cloudbot.util.hook._EventHook
+        """
+        super().__init__("event", plugin, event_hook)
+
+        self.types = event_hook.types
+
+    def __repr__(self):
+        return "Event[types: {}, {}]".format(list(self.types), Hook.__repr__(self))
+
+    def __str__(self):
+        return "event {} ({}) from {}".format(self.function_name, ",".join(str(t) for t in self.types),
+                                              self.plugin.file_name)
+
+
 class OnloadHook(Hook):
     def __init__(self, plugin, on_load_hook):
         """
@@ -659,5 +704,6 @@ _hook_name_to_plugin = {
     "regex": RegexHook,
     "irc_raw": RawHook,
     "sieve": SieveHook,
+    "event": EventHook,
     "onload": OnloadHook
 }
diff --git a/cloudbot/util/hook.py b/cloudbot/util/hook.py
index e446d87..06d6ac3 100644
--- a/cloudbot/util/hook.py
+++ b/cloudbot/util/hook.py
@@ -1,6 +1,7 @@
 import inspect
 import re
 import collections
+from cloudbot.core.events import EventType
 
 valid_command_re = re.compile(r"^\w+$")
 
@@ -126,10 +127,36 @@ class _RawHook(_Hook):
         if isinstance(trigger_param, str):
             self.triggers.add(trigger_param)
         else:
-            assert isinstance(trigger_param, list)
+            # it's a list
             self.triggers.update(trigger_param)
 
 
+class _EventHook(_Hook):
+    """
+    :type types: set[cloudbot.core.events.EventType]
+    """
+
+    def __init__(self, function):
+        """
+        :type function: function
+        """
+        _Hook.__init__(self, function, "event")
+        self.types = set()
+
+    def add_hook(self, trigger_param, kwargs):
+        """
+        :type trigger_param: cloudbot.core.events.EventType | list[cloudbot.core.events.EventType]
+        :type kwargs: dict[str, unknown]
+        """
+        self._add_hook(kwargs)
+
+        if isinstance(trigger_param, EventType):
+            self.types.add(trigger_param)
+        else:
+            # it's a list
+            self.types.update(trigger_param)
+
+
 def _add_hook(func, hook):
     if not hasattr(func, "_cloudbot_hook"):
         func._cloudbot_hook = {}
@@ -185,6 +212,26 @@ def irc_raw(triggers_param, **kwargs):
         return lambda func: _raw_hook(func)
 
 
+def event(types_param, **kwargs):
+    """External event decorator. Must be used as a function to return a decorator
+    :type types_param: cloudbot.core.events.EventType | list[cloudbot.core.events.EventType]
+    """
+
+    def _event_hook(func):
+        hook = _get_hook(func, "event")
+        if hook is None:
+            hook = _EventHook(func)
+            _add_hook(func, hook)
+
+        hook.add_hook(types_param, kwargs)
+        return func
+
+    if callable(types_param):  # this decorator is being used directly, which isn't good
+        raise TypeError("@irc_raw() must be used as a function that returns a decorator")
+    else:  # this decorator is being used as a function, so return a decorator
+        return lambda func: _event_hook(func)
+
+
 def regex(regex_param, **kwargs):
     """External regex decorator. Must be used as a function to return a decorator.
     :type regex_param: str | re.__Regex | list[str | re.__Regex]
diff --git a/plugins/history.py b/plugins/history.py
index 6a09488..0631f06 100644
--- a/plugins/history.py
+++ b/plugins/history.py
@@ -4,6 +4,7 @@ import asyncio
 import re
 
 from cloudbot import hook, timesince
+from cloudbot.core.events import EventType
 
 db_ready = []
 
@@ -48,7 +49,7 @@ def track_history(event, message_time, conn):
     history.append(data)
 
 
-@hook.irc_raw('PRIVMSG', ignorebots=False, singlethread=True)
+@hook.event(EventType.message, ignorebots=False, singlethread=True)
 def chat_tracker(event, db, conn):
     """
     :type db: sqlalchemy.orm.Session
diff --git a/plugins/tell.py b/plugins/tell.py
index 8b90ce7..60a5591 100644
--- a/plugins/tell.py
+++ b/plugins/tell.py
@@ -5,6 +5,7 @@ from sqlalchemy import Table, Column, String, Boolean, DateTime
 from sqlalchemy.sql import select
 
 from cloudbot import hook, timesince, botvars
+from cloudbot.core.events import EventType
 
 table = Table(
     'tells',
@@ -70,11 +71,11 @@ def add_tell(db, server, sender, target, message):
     db.commit()
 
 
-@hook.irc_raw('PRIVMSG', singlethread=True)
+@hook.event(EventType.message, singlethread=True)
 def tellinput(event, conn, db, nick, notice):
     """
     :type event: cloudbot.core.events.BaseEvent
-    :type conn: cloudbot.core.connection.IrcConnection
+    :type conn: cloudbot.core.connection.Connection
     :type db: sqlalchemy.orm.Session
     """
     if 'showtells' in event.content.lower():
-- 
2.0.0

