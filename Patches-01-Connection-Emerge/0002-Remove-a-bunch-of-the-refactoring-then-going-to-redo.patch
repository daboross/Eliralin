From 1ae7cce5856ecdbf87f6b38dee77f2e45de6e162 Mon Sep 17 00:00:00 2001
From: Dabo Ross <daboross@daboross.net>
Date: Wed, 18 Jun 2014 17:18:01 -0500
Subject: [PATCH] Remove a bunch of the refactoring, then going to redo it.

Difference from before things were moved:
- Move cloudbot/core/* to cloudbot/
- Move cloudbot/util/hook to cloudbot/
- Remove cloudbot/util/* aliases in cloudbot/
- Update all plugins, documentation, etc. accordingly

Difference from last commit:
- Move client/connection stuff back into connection.py
- Move event.py back to events.py
- Move plugin.py back to pluginmanager.py
- Move util/hook.py to hook.py
- Rename IRCClient to IrcConnection and Client to Connection
- Fix a bunch of refactoring documentation in plugins/

diff --git a/cloudbot/__init__.py b/cloudbot/__init__.py
index f033189..5d91238 100644
--- a/cloudbot/__init__.py
+++ b/cloudbot/__init__.py
@@ -10,12 +10,10 @@ import logging.config
 import logging
 import os
 
-from .util import botvars, bucket, formatting, hook, http, textgen, timeformat, timesince, urlnorm, web
-
 __version__ = "0.1.1.dev0"
 
-__all__ = ["core", "util", "bot", "config", "permissions", "pluginmanager", "events", "botvars", "bucket",
-           "formatting", "hook", "http", "textgen", "timeformat", "timesince", "urlnorm", "web", "dev_mode", "log_dir"]
+__all__ = ["util", "bot", "connection", "config", "permissions", "pluginmanager", "events", "hook", "dev_mode",
+           "log_dir"]
 
 
 def _setup():
diff --git a/cloudbot/bot.py b/cloudbot/bot.py
index e388c2f..5502f33 100644
--- a/cloudbot/bot.py
+++ b/cloudbot/bot.py
@@ -4,20 +4,19 @@ import logging
 import re
 import os
 import gc
-
 from sqlalchemy import create_engine
+
 from sqlalchemy.orm import scoped_session, sessionmaker
 from sqlalchemy.schema import MetaData
 
 import cloudbot
+from cloudbot.connection import Connection, IrcConnection
 from cloudbot.config import Config
 from cloudbot.reloader import PluginReloader
-from cloudbot.plugin import PluginManager
-from cloudbot.event import Event, CommandEvent, RegexEvent, EventType
-from cloudbot.dialect.irc.client import IRCClient
+from cloudbot.pluginmanager import PluginManager
+from cloudbot.events import BaseEvent, CommandEvent, RegexEvent, EventType
 from cloudbot.util import botvars, formatting
 
-
 logger = logging.getLogger("cloudbot")
 
 
@@ -33,7 +32,7 @@ class CloudBot:
     """
     :type start_time: float
     :type running: bool
-    :type connections: list[Connection | IRCClient]
+    :type connections: list[Connection | IrcConnection]
     :type data_dir: bytes
     :type config: core.config.Config
     :type plugin_manager: PluginManager
@@ -126,7 +125,7 @@ class CloudBot:
             server = conf['connection']['server']
             port = conf['connection'].get('port', 6667)
 
-            self.connections.append(IRCClient(self, name, nick, config=conf, channels=conf['channels'],
+            self.connections.append(IrcConnection(self, name, nick, config=conf, channels=conf['channels'],
                                                   readable_name=readable_name, server=server, port=port,
                                                   use_ssl=conf['connection'].get('ssl', False)))
             logger.debug("[{}] Created connection.".format(readable_name))
@@ -192,7 +191,7 @@ class CloudBot:
     @asyncio.coroutine
     def process(self, event):
         """
-        :type event: Event
+        :type event: BaseEvent
         """
         run_before_tasks = []
         tasks = []
@@ -203,17 +202,17 @@ class CloudBot:
             # run catch-all coroutine hooks before all others - TODO: Make this a plugin argument
             if not raw_hook.threaded:
                 run_before_tasks.append(
-                    self.plugin_manager.launch(raw_hook, Event(hook=raw_hook, base_event=event)))
+                    self.plugin_manager.launch(raw_hook, BaseEvent(hook=raw_hook, base_event=event)))
             else:
-                tasks.append(self.plugin_manager.launch(raw_hook, Event(hook=raw_hook, base_event=event)))
+                tasks.append(self.plugin_manager.launch(raw_hook, BaseEvent(hook=raw_hook, base_event=event)))
         if event.irc_command in self.plugin_manager.raw_triggers:
             for raw_hook in self.plugin_manager.raw_triggers[event.irc_command]:
-                tasks.append(self.plugin_manager.launch(raw_hook, Event(hook=raw_hook, base_event=event)))
+                tasks.append(self.plugin_manager.launch(raw_hook, BaseEvent(hook=raw_hook, base_event=event)))
 
         # Event hooks
         if event.type in self.plugin_manager.event_type_hooks:
             for event_hook in self.plugin_manager.event_type_hooks[event.type]:
-                tasks.append(self.plugin_manager.launch(event_hook, Event(hook=event_hook, base_event=event)))
+                tasks.append(self.plugin_manager.launch(event_hook, BaseEvent(hook=event_hook, base_event=event)))
 
         if event.type is EventType.message:
             # Commands
diff --git a/cloudbot/config.py b/cloudbot/config.py
index 22f2062..22574c7 100644
--- a/cloudbot/config.py
+++ b/cloudbot/config.py
@@ -15,14 +15,14 @@ class Config(dict):
     """
     :type filename: str
     :type path: str
-    :type bot: cloudbot.core.bot.CloudBot
+    :type bot: cloudbot.bot.CloudBot
     :type observer: Observer
     :type event_handler: ConfigEventHandler
     """
 
     def __init__(self, bot, *args, **kwargs):
         """
-        :type bot: cloudbot.core.bot.CloudBot
+        :type bot: cloudbot.bot.CloudBot
         :type args: list
         :type kwargs: dict
         """
@@ -78,19 +78,18 @@ class Config(dict):
 
 class ConfigEventHandler(Trick):
     """
-    :type bot: cloudbot.core.bot.CloudBot
+    :type bot: cloudbot.bot.CloudBot
     :type config: core.config.Config
     :type logger: logging.Logger
     """
 
     def __init__(self, bot, config, *args, **kwargs):
         """
-        :type bot: cloudbot.core.bot.CloudBot
+        :type bot: cloudbot.bot.CloudBot
         :type config: Config
         """
         self.bot = bot
         self.config = config
-        logger = config.logger
         Trick.__init__(self, *args, **kwargs)
 
     def on_any_event(self, event):
diff --git a/cloudbot/connection.py b/cloudbot/connection.py
new file mode 100644
index 0000000..baefb04
--- /dev/null
+++ b/cloudbot/connection.py
@@ -0,0 +1,495 @@
+from _ssl import PROTOCOL_SSLv23
+import asyncio
+import re
+import ssl
+import logging
+from ssl import SSLContext
+
+from cloudbot.permissions import PermissionManager
+from cloudbot.events import BaseEvent, EventType
+
+logger = logging.getLogger("cloudbot")
+
+irc_prefix_re = re.compile(r":([^ ]*) ([^ ]*) (.*)")
+irc_noprefix_re = re.compile(r"([^ ]*) (.*)")
+irc_netmask_re = re.compile(r"([^!@]*)!([^@]*)@(.*)")
+irc_param_re = re.compile(r"(?:^|(?<= ))(:.*|[^ ]+)")
+
+irc_command_to_event_type = {
+    "PRIVMSG": EventType.message,
+    "JOIN": EventType.join,
+    "PART": EventType.part,
+    "KICK": EventType.kick,
+    "NOTICE": EventType.notice
+}
+
+
+class Connection:
+    """
+    A Connection representing each connection the bot makes to a single server
+    :type bot: cloudbot.bot.CloudBot
+    :type loop: asyncio.events.AbstractEventLoop
+    :type name: str
+    :type readable_name: str
+    :type channels: list[str]
+    :type config: dict[str, unknown]
+    :type nick: str
+    :type vars: dict
+    :type history: dict[str, list[tuple]]
+    :type permissions: PermissionManager
+    """
+
+    def __init__(self, bot, name, nick, *, readable_name, channels=None, config=None):
+        """
+        :type bot: cloudbot.bot.CloudBot
+        :type name: str
+        :type readable_name: str
+        :type nick: str
+        :type channels: list[str]
+        :type config: dict[str, unknown]
+        """
+        self.bot = bot
+        self.loop = bot.loop
+        self.name = name
+        self.nick = nick
+        self.readable_name = readable_name
+
+        if channels is None:
+            self.channels = []
+        else:
+            self.channels = channels
+
+        if config is None:
+            self.config = {}
+        else:
+            self.config = config
+        self.vars = {}
+        self.history = {}
+
+        # create permissions manager
+        self.permissions = PermissionManager(self)
+
+    def describe_server(self):
+        raise NotImplementedError
+
+    @asyncio.coroutine
+    def connect(self):
+        """
+        Connects to the server, or reconnects if already connected.
+        """
+        raise NotImplementedError
+
+    def quit(self, reason=None):
+        """
+        Gracefully disconnects from the server with reason <reason>, close() should be called shortly after.
+        """
+        raise NotImplementedError
+
+    def close(self):
+        """
+        Disconnects from the server, only for use when this Connection object will *not* ever be connected again
+        """
+        raise NotImplementedError
+
+    def message(self, target, text):
+        """
+        Sends a message to the given target
+        :type target: str
+        :type text: str
+        """
+        raise NotImplementedError
+
+    def action(self, target, text):
+        """
+        Sends an action (or /me) to the given target channel
+        :type target: str
+        :type text: str
+        """
+        raise NotImplementedError
+
+    def notice(self, target, text):
+        """
+        Sends a notice to the given target
+        :type target: str
+        :type text: str
+        """
+        raise NotImplementedError
+
+    def set_nick(self, nick):
+        """
+        Sets the bot's nickname
+        :type nick: str
+        """
+        raise NotImplementedError
+
+    def join(self, channel):
+        """
+        Joins a given channel
+        :type channel: str
+        """
+        raise NotImplementedError
+
+    def part(self, channel):
+        """
+        Parts a given channel
+        :type channel: str
+        """
+        raise NotImplementedError
+
+    @property
+    def connected(self):
+        raise NotImplementedError
+
+
+class IrcConnection(Connection):
+    """
+    An implementation of Connection for IRC.
+    :type use_ssl: bool
+    :type server: str
+    :type port: int
+    :type _connected: bool
+    :type _ignore_cert_errors: bool
+    """
+
+    def __init__(self, bot, name, nick, *, readable_name, channels=None, config=None,
+                 server, port=6667, use_ssl=False, ignore_cert_errors=True, timeout=300):
+        """
+        :type bot: cloudbot.bot.CloudBot
+        :type name: str
+        :type readable_name: str
+        :type nick: str
+        :type channels: list[str]
+        :type config: dict[str, unknown]
+        :type server: str
+        :type port: int
+        :type use_ssl: bool
+        :type ignore_cert_errors: bool
+        :type timeout: int
+        """
+        super().__init__(bot, name, nick, readable_name=readable_name, channels=channels, config=config)
+
+        self.use_ssl = use_ssl
+        self._ignore_cert_errors = ignore_cert_errors
+        self._timeout = timeout
+        self.server = server
+        self.port = port
+
+        # create SSL context
+        if self.use_ssl:
+            self.ssl_context = SSLContext(PROTOCOL_SSLv23)
+            if self._ignore_cert_errors:
+                self.ssl_context.verify_mode = ssl.CERT_NONE
+            else:
+                self.ssl_context.verify_mode = ssl.CERT_REQUIRED
+        else:
+            self.ssl_context = None
+
+        # if we're connected
+        self._connected = False
+        # if we've quit
+        self._quit = False
+
+        # transport and protocol
+        self._transport = None
+        self._protocol = None
+
+    def describe_server(self):
+        if self.use_ssl:
+            return "+{}:{}".format(self.server, self.port)
+        else:
+            return "{}:{}".format(self.server, self.port)
+
+    @asyncio.coroutine
+    def connect(self):
+        """
+        Connects to the IRC server, or reconnects if already connected.
+        """
+        # connect to the irc server
+        if self._quit:
+            # we've quit, so close instead (because this has probably been called because of EOF received)
+            self.close()
+            return
+
+        if self._connected:
+            logger.info("[{}] Reconnecting".format(self.readable_name))
+            self._transport.close()
+        else:
+            self._connected = True
+            logger.info("[{}] Connecting".format(self.readable_name))
+
+        self._transport, self._protocol = yield from self.loop.create_connection(
+            lambda: _IrcProtocol(self), host=self.server, port=self.port, ssl=self.ssl_context)
+
+        # send the password, nick, and user
+        self.set_pass(self.config["connection"].get("password"))
+        self.set_nick(self.nick)
+        self.cmd("USER", self.config.get('user', 'cloudbot'), "3", "*",
+                 self.config.get('realname', 'CloudBotRefresh - http://cloudbot.pw'))
+
+    def quit(self, reason=None):
+        if self._quit:
+            return
+        self._quit = True
+        if reason:
+            self.cmd("QUIT", reason)
+        else:
+            self.cmd("QUIT")
+
+    def close(self):
+        if not self._quit:
+            self.quit()
+        if not self._connected:
+            return
+
+        self._transport.close()
+        self._connected = False
+
+    def message(self, target, text):
+        self.cmd("PRIVMSG", target, text)
+
+    def action(self, target, text):
+        self.ctcp(target, "ACTION", text)
+
+    def notice(self, target, text):
+        self.cmd("NOTICE", target, text)
+
+    def set_nick(self, nick):
+        self.cmd("NICK", nick)
+
+    def join(self, channel):
+        self.send("JOIN {}".format(channel))
+        if channel not in self.channels:
+            self.channels.append(channel)
+
+    def part(self, channel):
+        self.cmd("PART", channel)
+        if channel in self.channels:
+            self.channels.remove(channel)
+
+    def set_pass(self, password):
+        if not password:
+            return
+        self.cmd("PASS", password)
+
+    def ctcp(self, target, ctcp_type, text):
+        """
+        Makes the bot send a PRIVMSG CTCP of type <ctcp_type> to the target
+        :type ctcp_type: str
+        :type text: str
+        :type target: str
+        """
+        out = "\x01{} {}\x01".format(ctcp_type, text)
+        self.cmd("PRIVMSG", target, out)
+
+    def cmd(self, command, *params):
+        """
+        Sends a raw IRC command of type <command> with params <params>
+        :param command: The IRC command to send
+        :param params: The params to the IRC command
+        :type command: str
+        :type params: (str)
+        """
+        params = list(params)  # turn the tuple of parameters into a list
+        if params:
+            params[-1] = ':' + params[-1]
+            self.send("{} {}".format(command, ' '.join(params)))
+        else:
+            self.send(command)
+
+    def send(self, line):
+        """
+        Sends a raw IRC line
+        :type line: str
+        """
+        if not self._connected:
+            raise ValueError("Connection must be connected to irc server to use send")
+        self.loop.call_soon_threadsafe(self._send, line)
+
+    def _send(self, line):
+        """
+        Sends a raw IRC line unchecked. Doesn't do connected check, and is *not* threadsafe
+        :type line: str
+        """
+        logger.info("[{}] >> {}".format(self.readable_name, line))
+        asyncio.async(self._protocol.send(line), loop=self.loop)
+
+    @property
+    def connected(self):
+        return self._connected
+
+
+class _IrcProtocol(asyncio.Protocol):
+    """
+    :type loop: asyncio.events.AbstractEventLoop
+    :type conn: IrcConnection
+    :type bot: cloudbot.bot.CloudBot
+    :type _input_buffer: bytes
+    :type _connected: bool
+    :type _transport: asyncio.transports.Transport
+    :type _connected_future: asyncio.Future
+    """
+
+    def __init__(self, conn):
+        """
+        :type conn: IrcConnection
+        """
+        self.loop = conn.loop
+        self.bot = conn.bot
+        self.conn = conn
+
+        # input buffer
+        self._input_buffer = b""
+
+        # connected
+        self._connected = False
+
+        # transport
+        self._transport = None
+
+        # Future that waits until we are connected
+        self._connected_future = asyncio.Future(loop=self.loop)
+
+    def connection_made(self, transport):
+        self._transport = transport
+        self._connected = True
+        self._connected_future.set_result(None)
+        # we don't need the _connected_future, everything uses it will check _connected first.
+        del self._connected_future
+
+    def connection_lost(self, exc):
+        self._connected = False
+        # create a new connected_future for when we are connected.
+        self._connected_future = asyncio.Future(loop=self.loop)
+        if exc is None:
+            # we've been closed intentionally, so don't reconnect
+            return
+        logger.exception("[{}] Connection lost.".format(self.conn.readable_name))
+        asyncio.async(self.conn.connect(), loop=self.loop)
+
+    def eof_received(self):
+        self._connected = False
+        # create a new connected_future for when we are connected.
+        self._connected_future = asyncio.Future(loop=self.loop)
+        logger.info("[{}] EOF received.".format(self.conn.readable_name))
+        asyncio.async(self.conn.connect(), loop=self.loop)
+        return True
+
+    @asyncio.coroutine
+    def send(self, line):
+        # make sure we are connected before sending
+        if not self._connected:
+            yield from self._connected_future
+        line = line.splitlines()[0][:500] + "\r\n"
+        data = line.encode("utf-8", "replace")
+        self._transport.write(data)
+
+    def data_received(self, data):
+        self._input_buffer += data
+
+        while b"\r\n" in self._input_buffer:
+            line_data, self._input_buffer = self._input_buffer.split(b"\r\n", 1)
+            line = line_data.decode()
+
+            # parse the line into a message
+            if line.startswith(":"):
+                prefix_line_match = irc_prefix_re.match(line)
+                if prefix_line_match is None:
+                    logger.critical("[{}] Received invalid IRC line '{}' from {}".format(
+                        self.conn.readable_name, line, self.conn.describe_server()))
+                    continue
+
+                netmask_prefix, command, params = prefix_line_match.groups()
+                prefix = ":" + netmask_prefix  # TODO: Do we need to know this?
+                netmask_match = irc_netmask_re.match(netmask_prefix)
+                if netmask_match is None:
+                    # This isn't in the format of a netmask
+                    nick = netmask_prefix
+                    user = None
+                    host = None
+                    mask = netmask_prefix
+                else:
+                    nick = netmask_match.group(1)
+                    user = netmask_match.group(2)
+                    host = netmask_match.group(3)
+                    mask = netmask_prefix
+            else:
+                prefix = None
+                noprefix_line_match = irc_noprefix_re.match(line)
+                if noprefix_line_match is None:
+                    logger.critical("[{}] Received invalid IRC line '{}' from {}".format(
+                        self.conn.readable_name, line, self.conn.describe_server()))
+                    continue
+                command = noprefix_line_match.group(1)
+                params = noprefix_line_match.group(2)
+                nick = None
+                user = None
+                host = None
+                mask = None
+
+            command_params = irc_param_re.findall(params)
+
+            # Reply to pings immediately
+
+            if command == "PING":
+                asyncio.async(self.send("PONG " + command_params[-1]), loop=self.loop)
+
+            # Parse the command and params
+
+            # Content
+            if command_params and command_params[-1].startswith(":"):
+                # If the last param is in the format of `:content` remove the `:` from it, and set content from it
+                content = command_params[-1][1:]
+            else:
+                content = None
+
+            # Event type
+            if command in irc_command_to_event_type:
+                event_type = irc_command_to_event_type[command]
+            else:
+                event_type = EventType.other
+
+            # Target (for KICK, INVITE)
+            if event_type is EventType.kick:
+                target = command_params[1]
+            elif command == "INVITE":
+                target = command_params[0]
+            else:
+                # TODO: Find more commands which give a target
+                target = None
+
+            # Parse for CTCP
+            if event_type is EventType.message and content.count("\x01") >= 2 and content.startswith("\x01"):
+                # Remove the first \x01, then rsplit to remove the last one, and ignore text after the last \x01
+                ctcp_text = content[1:].rsplit("\x01", 1)[0]
+                ctcp_text_split = ctcp_text.split(None, 1)
+                if ctcp_text_split[0] == "ACTION":
+                    # this is a CTCP ACTION, set event_type and content accordingly
+                    event_type = EventType.action
+                    content = ctcp_text_split[1]
+                else:
+                    # this shouldn't be considered a regular message
+                    event_type = EventType.other
+            else:
+                ctcp_text = None
+
+            # Channel
+            # TODO: Migrate plugins using chan for storage to use chan.lower() instead so we can pass the original case
+            if command_params and (len(command_params) > 2 or not command_params[0].startswith(":")):
+
+                if command_params[0].lower() == self.conn.nick.lower():
+                    # this is a private message - set the channel to the sender's nick
+                    channel = nick.lower()
+                else:
+                    channel = command_params[0].lower()
+            else:
+                channel = None
+
+            # Set up parsed message
+            # TODO: Do we really want to send the raw `prefix` and `command_params` here?
+            event = BaseEvent(bot=self.bot, conn=self.conn, event_type=event_type, content=content, target=target,
+                              channel=channel, nick=nick, user=user, host=host, mask=mask, irc_raw=line,
+                              irc_prefix=prefix, irc_command=command, irc_paramlist=command_params,
+                              irc_ctcp_text=ctcp_text)
+
+            # handle the message, async
+            asyncio.async(self.bot.process(event), loop=self.loop)
diff --git a/cloudbot/dialect/__init__.py b/cloudbot/dialect/__init__.py
deleted file mode 100644
index ad25671..0000000
--- a/cloudbot/dialect/__init__.py
+++ /dev/null
@@ -1 +0,0 @@
-__author__ = 'Luke'
diff --git a/cloudbot/dialect/irc/__init__.py b/cloudbot/dialect/irc/__init__.py
deleted file mode 100644
index ad25671..0000000
--- a/cloudbot/dialect/irc/__init__.py
+++ /dev/null
@@ -1 +0,0 @@
-__author__ = 'Luke'
diff --git a/cloudbot/dialect/irc/client.py b/cloudbot/dialect/irc/client.py
deleted file mode 100644
index 1218dd3..0000000
--- a/cloudbot/dialect/irc/client.py
+++ /dev/null
@@ -1,188 +0,0 @@
-from _ssl import PROTOCOL_SSLv23
-import asyncio
-import ssl
-import logging
-from ssl import SSLContext
-
-from cloudbot.client import Client
-from cloudbot.dialect.irc.protocol import IRCProtocol
-
-
-logger = logging.getLogger("cloudbot")
-
-
-class IRCClient(Client):
-    """
-    An implementation of Client for IRC.
-    :type use_ssl: bool
-    :type server: str
-    :type port: int
-    :type _connected: bool
-    :type _ignore_cert_errors: bool
-    """
-
-    def __init__(self, bot, name, nick, *, readable_name, channels=None, config=None,
-                 server, port=6667, use_ssl=False, ignore_cert_errors=True, timeout=300):
-        """
-        :type bot: cloudbot.core.bot.CloudBot
-        :type name: str
-        :type readable_name: str
-        :type nick: str
-        :type channels: list[str]
-        :type config: dict[str, unknown]
-        :type server: str
-        :type port: int
-        :type use_ssl: bool
-        :type ignore_cert_errors: bool
-        :type timeout: int
-        """
-        super().__init__(bot, name, nick, readable_name=readable_name, channels=channels, config=config)
-
-        self.use_ssl = use_ssl
-        self._ignore_cert_errors = ignore_cert_errors
-        self._timeout = timeout
-        self.server = server
-        self.port = port
-
-        # create SSL context
-        if self.use_ssl:
-            self.ssl_context = SSLContext(PROTOCOL_SSLv23)
-            if self._ignore_cert_errors:
-                self.ssl_context.verify_mode = ssl.CERT_NONE
-            else:
-                self.ssl_context.verify_mode = ssl.CERT_REQUIRED
-        else:
-            self.ssl_context = None
-
-        # if we're connected
-        self._connected = False
-        # if we've quit
-        self._quit = False
-
-        # transport and protocol
-        self._transport = None
-        self._protocol = None
-
-    def describe_server(self):
-        if self.use_ssl:
-            return "+{}:{}".format(self.server, self.port)
-        else:
-            return "{}:{}".format(self.server, self.port)
-
-    @asyncio.coroutine
-    def connect(self):
-        """
-        Connects to the IRC server, or reconnects if already connected.
-        """
-        # connect to the irc server
-        if self._quit:
-            # we've quit, so close instead (because this has probably been called because of EOF received)
-            self.close()
-            return
-
-        if self._connected:
-            logger.info("[{}] Reconnecting".format(self.readable_name))
-            self._transport.close()
-        else:
-            self._connected = True
-            logger.info("[{}] Connecting".format(self.readable_name))
-
-        self._transport, self._protocol = yield from self.loop.create_connection(
-            lambda: IRCProtocol(self), host=self.server, port=self.port, ssl=self.ssl_context)
-
-        # send the password, nick, and user
-        self.set_pass(self.config["connection"].get("password"))
-        self.set_nick(self.nick)
-        self.cmd("USER", self.config.get('user', 'cloudbot'), "3", "*",
-                 self.config.get('realname', 'CloudBotRefresh - http://cloudbot.pw'))
-
-    def quit(self, reason=None):
-        if self._quit:
-            return
-        self._quit = True
-        if reason:
-            self.cmd("QUIT", reason)
-        else:
-            self.cmd("QUIT")
-
-    def close(self):
-        if not self._quit:
-            self.quit()
-        if not self._connected:
-            return
-
-        self._transport.close()
-        self._connected = False
-
-    def message(self, target, text):
-        self.cmd("PRIVMSG", target, text)
-
-    def action(self, target, text):
-        self.ctcp(target, "ACTION", text)
-
-    def notice(self, target, text):
-        self.cmd("NOTICE", target, text)
-
-    def set_nick(self, nick):
-        self.cmd("NICK", nick)
-
-    def join(self, channel):
-        self.send("JOIN {}".format(channel))
-        if channel not in self.channels:
-            self.channels.append(channel)
-
-    def part(self, channel):
-        self.cmd("PART", channel)
-        if channel in self.channels:
-            self.channels.remove(channel)
-
-    def set_pass(self, password):
-        if not password:
-            return
-        self.cmd("PASS", password)
-
-    def ctcp(self, target, ctcp_type, text):
-        """
-        Makes the bot send a PRIVMSG CTCP of type <ctcp_type> to the target
-        :type ctcp_type: str
-        :type text: str
-        :type target: str
-        """
-        out = "\x01{} {}\x01".format(ctcp_type, text)
-        self.cmd("PRIVMSG", target, out)
-
-    def cmd(self, command, *params):
-        """
-        Sends a raw IRC command of type <command> with params <params>
-        :param command: The IRC command to send
-        :param params: The params to the IRC command
-        :type command: str
-        :type params: (str)
-        """
-        params = list(params)  # turn the tuple of parameters into a list
-        if params:
-            params[-1] = ':' + params[-1]
-            self.send("{} {}".format(command, ' '.join(params)))
-        else:
-            self.send(command)
-
-    def send(self, line):
-        """
-        Sends a raw IRC line
-        :type line: str
-        """
-        if not self._connected:
-            raise ValueError("Client must be connected to irc server to use send")
-        self.loop.call_soon_threadsafe(self._send, line)
-
-    def _send(self, line):
-        """
-        Sends a raw IRC line unchecked. Doesn't do connected check, and is *not* threadsafe
-        :type line: str
-        """
-        logger.info("[{}] >> {}".format(self.readable_name, line))
-        asyncio.async(self._protocol.send(line), loop=self.loop)
-
-    @property
-    def connected(self):
-        return self._connected
diff --git a/cloudbot/dialect/irc/protocol.py b/cloudbot/dialect/irc/protocol.py
deleted file mode 100644
index a8f6da1..0000000
--- a/cloudbot/dialect/irc/protocol.py
+++ /dev/null
@@ -1,198 +0,0 @@
-import asyncio
-import logging
-import re
-
-from cloudbot.event import EventType, Event
-
-
-logger = logging.getLogger("cloudbot")
-
-irc_prefix_re = re.compile(r":([^ ]*) ([^ ]*) (.*)")
-irc_noprefix_re = re.compile(r"([^ ]*) (.*)")
-irc_netmask_re = re.compile(r"([^!@]*)!([^@]*)@(.*)")
-irc_param_re = re.compile(r"(?:^|(?<= ))(:.*|[^ ]+)")
-
-irc_command_to_event_type = {
-    "PRIVMSG": EventType.message,
-    "JOIN": EventType.join,
-    "PART": EventType.part,
-    "KICK": EventType.kick,
-    "NOTICE": EventType.notice
-}
-
-
-class IRCProtocol(asyncio.Protocol):
-    """
-    :type loop: asyncio.events.AbstractEventLoop
-    :type conn: IRCClient
-    :type bot: cloudbot.core.bot.CloudBot
-    :type _input_buffer: bytes
-    :type _connected: bool
-    :type _transport: asyncio.transports.Transport
-    :type _connected_future: asyncio.Future
-    """
-
-    def __init__(self, conn):
-        """
-        :type conn: IRCClient
-        """
-        self.loop = conn.loop
-        self.bot = conn.bot
-        self.conn = conn
-
-        # input buffer
-        self._input_buffer = b""
-
-        # connected
-        self._connected = False
-
-        # transport
-        self._transport = None
-
-        # Future that waits until we are connected
-        self._connected_future = asyncio.Future(loop=self.loop)
-
-    def connection_made(self, transport):
-        self._transport = transport
-        self._connected = True
-        self._connected_future.set_result(None)
-        # we don't need the _connected_future, everything uses it will check _connected first.
-        del self._connected_future
-
-    def connection_lost(self, exc):
-        self._connected = False
-        # create a new connected_future for when we are connected.
-        self._connected_future = asyncio.Future(loop=self.loop)
-        if exc is None:
-            # we've been closed intentionally, so don't reconnect
-            return
-        logger.exception("[{}] Client lost.".format(self.conn.readable_name))
-        asyncio.async(self.conn.connect(), loop=self.loop)
-
-    def eof_received(self):
-        self._connected = False
-        # create a new connected_future for when we are connected.
-        self._connected_future = asyncio.Future(loop=self.loop)
-        logger.info("[{}] EOF received.".format(self.conn.readable_name))
-        asyncio.async(self.conn.connect(), loop=self.loop)
-        return True
-
-    @asyncio.coroutine
-    def send(self, line):
-        # make sure we are connected before sending
-        if not self._connected:
-            yield from self._connected_future
-        line = line.splitlines()[0][:500] + "\r\n"
-        data = line.encode("utf-8", "replace")
-        self._transport.write(data)
-
-    def data_received(self, data):
-        self._input_buffer += data
-
-        while b"\r\n" in self._input_buffer:
-            line_data, self._input_buffer = self._input_buffer.split(b"\r\n", 1)
-            line = line_data.decode()
-
-            # parse the line into a message
-            if line.startswith(":"):
-                prefix_line_match = irc_prefix_re.match(line)
-                if prefix_line_match is None:
-                    logger.critical("[{}] Received invalid IRC line '{}' from {}".format(
-                        self.conn.readable_name, line, self.conn.describe_server()))
-                    continue
-
-                netmask_prefix, command, params = prefix_line_match.groups()
-                prefix = ":" + netmask_prefix  # TODO: Do we need to know this?
-                netmask_match = irc_netmask_re.match(netmask_prefix)
-                if netmask_match is None:
-                    # This isn't in the format of a netmask
-                    nick = netmask_prefix
-                    user = None
-                    host = None
-                    mask = netmask_prefix
-                else:
-                    nick = netmask_match.group(1)
-                    user = netmask_match.group(2)
-                    host = netmask_match.group(3)
-                    mask = netmask_prefix
-            else:
-                prefix = None
-                noprefix_line_match = irc_noprefix_re.match(line)
-                if noprefix_line_match is None:
-                    logger.critical("[{}] Received invalid IRC line '{}' from {}".format(
-                        self.conn.readable_name, line, self.conn.describe_server()))
-                    continue
-                command = noprefix_line_match.group(1)
-                params = noprefix_line_match.group(2)
-                nick = None
-                user = None
-                host = None
-                mask = None
-
-            command_params = irc_param_re.findall(params)
-
-            # Reply to pings immediately
-
-            if command == "PING":
-                asyncio.async(self.send("PONG " + command_params[-1]), loop=self.loop)
-
-            # Parse the command and params
-
-            # Content
-            if command_params and command_params[-1].startswith(":"):
-                # If the last param is in the format of `:content` remove the `:` from it, and set content from it
-                content = command_params[-1][1:]
-            else:
-                content = None
-
-            # Event type
-            if command in irc_command_to_event_type:
-                event_type = irc_command_to_event_type[command]
-            else:
-                event_type = EventType.other
-
-            # Target (for KICK, INVITE)
-            if event_type is EventType.kick:
-                target = command_params[1]
-            elif command == "INVITE":
-                target = command_params[0]
-            else:
-                # TODO: Find more commands which give a target
-                target = None
-
-            # Parse for CTCP
-            if event_type is EventType.message and content.count("\x01") >= 2 and content.startswith("\x01"):
-                # Remove the first \x01, then rsplit to remove the last one, and ignore text after the last \x01
-                ctcp_text = content[1:].rsplit("\x01", 1)[0]
-                ctcp_text_split = ctcp_text.split(None, 1)
-                if ctcp_text_split[0] == "ACTION":
-                    # this is a CTCP ACTION, set event_type and content accordingly
-                    event_type = EventType.action
-                    content = ctcp_text_split[1]
-                else:
-                    # this shouldn't be considered a regular message
-                    event_type = EventType.other
-            else:
-                ctcp_text = None
-
-            # Channel
-            # TODO: Migrate plugins using chan for storage to use chan.lower() instead so we can pass the original case
-            if command_params and (len(command_params) > 2 or not command_params[0].startswith(":")):
-
-                if command_params[0].lower() == self.conn.nick.lower():
-                    # this is a private message - set the channel to the sender's nick
-                    channel = nick.lower()
-                else:
-                    channel = command_params[0].lower()
-            else:
-                channel = None
-
-            # Set up parsed message
-            # TODO: Do we really want to send the raw `prefix` and `command_params` here?
-            event = Event(bot=self.bot, conn=self.conn, event_type=event_type, content=content, target=target,
-                          channel=channel, nick=nick, user=user, host=host, mask=mask, irc_raw=line,
-                          irc_prefix=prefix, irc_command=command, irc_paramlist=command_params,
-                          irc_ctcp_text=ctcp_text)
-
-            # handle the message, async
-            asyncio.async(self.bot.process(event), loop=self.loop)
diff --git a/cloudbot/event.py b/cloudbot/event.py
deleted file mode 100644
index 0cb3a27..0000000
--- a/cloudbot/event.py
+++ /dev/null
@@ -1,373 +0,0 @@
-import asyncio
-import enum
-import logging
-import concurrent.futures
-
-logger = logging.getLogger("cloudbot")
-
-
-@enum.unique
-class EventType(enum.Enum):
-    message = 0
-    action = 1
-    # TODO: Do we actually want to have a 'notice' event type? Should the NOTICE command be a 'message' type?
-    notice = 2
-    join = 3
-    part = 4
-    kick = 5
-    other = 6
-
-
-class Event:
-    """
-    :type bot: cloudbot.core.bot.CloudBot
-    :type conn: cloudbot.core.connection.Client
-    :type hook: cloudbot.core.pluginmanager.Hook
-    :type type: EventType
-    :type content: str
-    :type target: str
-    :type chan: str
-    :type nick: str
-    :type user: str
-    :type host: str
-    :type mask: str
-    :type db: sqlalchemy.orm.Session
-    :type db_executor: concurrent.futures.ThreadPoolExecutor
-    :type irc_raw: str
-    :type irc_prefix: str
-    :type irc_command: str
-    :type irc_paramlist: str
-    :type irc_ctcp_text: str
-    """
-
-    def __init__(self, *, bot=None, hook=None, conn=None, base_event=None, event_type=EventType.other, content=None,
-                 target=None, channel=None, nick=None, user=None, host=None, mask=None, irc_raw=None, irc_prefix=None,
-                 irc_command=None, irc_paramlist=None, irc_ctcp_text=None):
-        """
-        All of these parameters except for `bot` and `hook` are optional.
-        The irc_* parameters should only be specified for IRC events.
-
-        Note that the `bot` argument may be left out if you specify a `base_event`.
-
-        :param bot: The CloudBot instance this event was triggered from
-        :param conn: The Client instance this event was triggered from
-        :param hook: The hook this event will be passed to
-        :param base_event: The base event that this event is based on. If this parameter is not None, then nick, user,
-                            host, mask, and irc_* arguments are ignored
-        :param event_type: The type of the event
-        :param content: The content of the message, or the reason for an join or part
-        :param target: The target of the action, for example the user being kicked, or invited
-        :param channel: The channel that this action took place in
-        :param nick: The nickname of the sender that triggered this event
-        :param user: The user of the sender that triggered this event
-        :param host: The host of the sender that triggered this event
-        :param mask: The mask of the sender that triggered this event (nick!user@host)
-        :param irc_raw: The raw IRC line
-        :param irc_prefix: The raw IRC prefix
-        :param irc_command: The IRC command
-        :param irc_paramlist: The list of params for the IRC command. If the last param is a content param, the ':'
-                                should be removed from the front.
-        :param irc_ctcp_text: CTCP text if this message is a CTCP command
-        :type bot: cloudbot.core.bot.CloudBot
-        :type conn: cloudbot.core.connection.Client
-        :type hook: cloudbot.core.pluginmanager.Hook
-        :type base_event: cloudbot.core.events.Event
-        :type content: str
-        :type target: str
-        :type event_type: EventType
-        :type nick: str
-        :type user: str
-        :type host: str
-        :type mask: str
-        :type irc_raw: str
-        :type irc_prefix: str
-        :type irc_command: str
-        :type irc_paramlist: list[str]
-        :type irc_ctcp_text: str
-        """
-        self.db = None
-        self.db_executor = None
-        self.bot = bot
-        self.conn = conn
-        self.hook = hook
-        if base_event is not None:
-            # We're copying an event, so inherit values
-            if self.bot is None and base_event.bot is not None:
-                self.bot = base_event.bot
-            if self.conn is None and base_event.conn is not None:
-                self.conn = base_event.conn
-            if self.hook is None and base_event.hook is not None:
-                self.hook = base_event.hook
-
-            # If base_event is provided, don't check these parameters, just inherit
-            self.type = base_event.type
-            self.content = base_event.content
-            self.target = base_event.target
-            self.chan = base_event.chan
-            self.nick = base_event.nick
-            self.user = base_event.user
-            self.host = base_event.host
-            self.mask = base_event.mask
-            # irc-specific parameters
-            self.irc_raw = base_event.irc_raw
-            self.irc_prefix = base_event.irc_prefix
-            self.irc_command = base_event.irc_command
-            self.irc_paramlist = base_event.irc_paramlist
-            self.irc_ctcp_text = base_event.irc_ctcp_text
-        else:
-            # Since base_event wasn't provided, we can take these parameters
-            self.type = event_type
-            self.content = content
-            self.target = target
-            self.chan = channel
-            self.nick = nick
-            self.user = user
-            self.host = host
-            self.mask = mask
-            # irc-specific parameters
-            self.irc_raw = irc_raw
-            self.irc_prefix = irc_prefix
-            self.irc_command = irc_command
-            self.irc_paramlist = irc_paramlist
-            self.irc_ctcp_text = irc_ctcp_text
-
-    @asyncio.coroutine
-    def prepare(self):
-        """
-        Initializes this event to be run through it's hook
-
-        Mainly, initializes a database object on this event, if the hook requires it.
-
-        This method is for when the hook is *not* threaded (event.hook.threaded is False).
-        If you need to add a db to a threaded hook, use prepare_threaded.
-        """
-
-        if self.hook is None:
-            raise ValueError("event.hook is required to prepare an event")
-
-        if "db" in self.hook.required_args:
-            logger.debug("Opening database session for {}:threaded=False".format(self.hook.description))
-
-            # we're running a coroutine hook with a db, so initialise an executor pool
-            self.db_executor = concurrent.futures.ThreadPoolExecutor(1)
-            # be sure to initialize the db in the database executor, so it will be accessible in that thread.
-            self.db = yield from self.async(self.bot.db_session)
-
-    def prepare_threaded(self):
-        """
-        Initializes this event to be run through it's hook
-
-        Mainly, initializes the database object on this event, if the hook requires it.
-
-        This method is for when the hook is threaded (event.hook.threaded is True).
-        If you need to add a db to a coroutine hook, use prepare.
-        """
-
-        if self.hook is None:
-            raise ValueError("event.hook is required to prepare an event")
-
-        if "db" in self.hook.required_args:
-            logger.debug("Opening database session for {}:threaded=True".format(self.hook.description))
-
-            self.db = self.bot.db_session()
-
-    @asyncio.coroutine
-    def close(self):
-        """
-        Closes this event after running it through it's hook.
-
-        Mainly, closes the database connection attached to this event (if any).
-
-        This method is for when the hook is *not* threaded (event.hook.threaded is False).
-        If you need to add a db to a threaded hook, use close_threaded.
-        """
-        if self.hook is None:
-            raise ValueError("event.hook is required to close an event")
-
-        if self.db is not None:
-            logger.debug("Closing database session for {}:threaded=False".format(self.hook.description))
-            # be sure the close the database in the database executor, as it is only accessable in that one thread
-            yield from self.async(self.db.close)
-            self.db = None
-
-    def close_threaded(self):
-        """
-        Closes this event after running it through it's hook.
-
-        Mainly, closes the database connection attached to this event (if any).
-
-        This method is for when the hook is threaded (event.hook.threaded is True).
-        If you need to add a db to a coroutine hook, use close.
-        """
-        if self.hook is None:
-            raise ValueError("event.hook is required to close an event")
-        if self.db is not None:
-            logger.debug("Closing database session for {}:threaded=True".format(self.hook.description))
-            self.db.close()
-            self.db = None
-
-    @property
-    def event(self):
-        """
-        :rtype; cloudbot.core.events.Event
-        """
-        return self
-
-    @property
-    def loop(self):
-        """
-        :rtype: asyncio.events.AbstractEventLoop
-        """
-        return self.bot.loop
-
-    @property
-    def logger(self):
-        return logger
-
-    def message(self, message, target=None):
-        """sends a message to a specific or current channel/user
-        :type message: str
-        :type target: str
-        """
-        if target is None:
-            if self.chan is None:
-                raise ValueError("Target must be specified when chan is not assigned")
-            target = self.chan
-        self.conn.message(target, message)
-
-    def reply(self, message, target=None):
-        """sends a message to the current channel/user with a prefix
-        :type message: str
-        :type target: str
-        """
-        if target is None:
-            if self.chan is None:
-                raise ValueError("Target must be specified when chan is not assigned")
-            target = self.chan
-
-        if target == self.nick:
-            self.conn.message(target, message)
-        else:
-            self.conn.message(target, "({}) {}".format(self.nick, message))
-
-    def action(self, message, target=None):
-        """sends an action to the current channel/user or a specific channel/user
-        :type message: str
-        :type target: str
-        """
-        if target is None:
-            if self.chan is None:
-                raise ValueError("Target must be specified when chan is not assigned")
-            target = self.chan
-
-        self.conn.action(target, message)
-
-    def ctcp(self, message, ctcp_type, target=None):
-        """sends an ctcp to the current channel/user or a specific channel/user
-        :type message: str
-        :type ctcp_type: str
-        :type target: str
-        """
-        if target is None:
-            if self.chan is None:
-                raise ValueError("Target must be specified when chan is not assigned")
-            target = self.chan
-        if not hasattr(self.conn, "ctcp"):
-            raise ValueError("CTCP can only be used on IRC connections")
-        # noinspection PyUnresolvedReferences
-        self.conn.ctcp(target, ctcp_type, message)
-
-    def notice(self, message, target=None):
-        """sends a notice to the current channel/user or a specific channel/user
-        :type message: str
-        :type target: str
-        """
-        if target is None:
-            if self.nick is None:
-                raise ValueError("Target must be specified when nick is not assigned")
-            target = self.nick
-
-        self.conn.notice(target, message)
-
-    def has_permission(self, permission, notice=True):
-        """ returns whether or not the current user has a given permission
-        :type permission: str
-        :rtype: bool
-        """
-        if not self.mask:
-            raise ValueError("has_permission requires mask is not assigned")
-        return self.conn.permissions.has_perm_mask(self.mask, permission, notice=notice)
-
-    @asyncio.coroutine
-    def async(self, function, *args, **kwargs):
-        if self.db_executor is not None:
-            executor = self.db_executor
-        else:
-            executor = None
-        if kwargs:
-            result = yield from self.loop.run_in_executor(executor, function, *args)
-        else:
-            result = yield from self.loop.run_in_executor(executor, lambda: function(*args, **kwargs))
-        return result
-
-
-class CommandEvent(Event):
-    """
-    :type hook: cloudbot.core.pluginmanager.CommandHook
-    :type text: str
-    :type triggered_command: str
-    """
-
-    def __init__(self, *, bot=None, hook, text, triggered_command, conn=None, base_event=None, event_type=None,
-                 content=None, target=None, channel=None, nick=None, user=None, host=None, mask=None, irc_raw=None,
-                 irc_prefix=None, irc_command=None, irc_paramlist=None):
-        """
-        :param text: The arguments for the command
-        :param triggered_command: The command that was triggered
-        :type text: str
-        :type triggered_command: str
-        """
-        super().__init__(bot=bot, hook=hook, conn=conn, base_event=base_event, event_type=event_type, content=content,
-                         target=target, channel=channel, nick=nick, user=user, host=host, mask=mask, irc_raw=irc_raw,
-                         irc_prefix=irc_prefix, irc_command=irc_command, irc_paramlist=irc_paramlist)
-        self.hook = hook
-        self.text = text
-        self.triggered_command = triggered_command
-
-    def notice_doc(self, target=None):
-        """sends a notice containing this command's docstring to the current channel/user or a specific channel/user
-        :type target: str
-        """
-        if self.triggered_command is None:
-            raise ValueError("Triggered command not set on this event")
-        if self.hook.doc is None:
-            message = "{}{} requires additional arguments.".format(self.conn.config["command_prefix"],
-                                                                   self.triggered_command)
-        else:
-            if self.hook.doc.split()[0].isalpha():
-                # this is using the old format of `name <args> - doc`
-                message = "{}{}".format(self.conn.config["command_prefix"], self.hook.doc)
-            else:
-                # this is using the new format of `<args> - doc`
-                message = "{}{} {}".format(self.conn.config["command_prefix"], self.triggered_command, self.hook.doc)
-
-        self.notice(message, target=target)
-
-
-class RegexEvent(Event):
-    """
-    :type hook: cloudbot.core.pluginmanager.RegexHook
-    :type match: re.__Match
-    """
-
-    def __init__(self, *, bot=None, hook, match, conn=None, base_event=None, event_type=None, content=None, target=None,
-                 channel=None, nick=None, user=None, host=None, mask=None, irc_raw=None, irc_prefix=None,
-                 irc_command=None, irc_paramlist=None):
-        """
-        :param: match: The match objected returned by the regex search method
-        :type match: re.__Match
-        """
-        super().__init__(bot=bot, conn=conn, hook=hook, base_event=base_event, event_type=event_type, content=content,
-                         target=target, channel=channel, nick=nick, user=user, host=host, mask=mask, irc_raw=irc_raw,
-                         irc_prefix=irc_prefix, irc_command=irc_command, irc_paramlist=irc_paramlist)
-        self.match = match
diff --git a/cloudbot/events.py b/cloudbot/events.py
new file mode 100644
index 0000000..ec96914
--- /dev/null
+++ b/cloudbot/events.py
@@ -0,0 +1,373 @@
+import asyncio
+import enum
+import logging
+import concurrent.futures
+
+logger = logging.getLogger("cloudbot")
+
+
+@enum.unique
+class EventType(enum.Enum):
+    message = 0
+    action = 1
+    # TODO: Do we actually want to have a 'notice' event type? Should the NOTICE command be a 'message' type?
+    notice = 2
+    join = 3
+    part = 4
+    kick = 5
+    other = 6
+
+
+class BaseEvent:
+    """
+    :type bot: cloudbot.bot.CloudBot
+    :type conn: cloudbot.connection.Connection
+    :type hook: cloudbot.pluginmanager.Hook
+    :type type: EventType
+    :type content: str
+    :type target: str
+    :type chan: str
+    :type nick: str
+    :type user: str
+    :type host: str
+    :type mask: str
+    :type db: sqlalchemy.orm.Session
+    :type db_executor: concurrent.futures.ThreadPoolExecutor
+    :type irc_raw: str
+    :type irc_prefix: str
+    :type irc_command: str
+    :type irc_paramlist: str
+    :type irc_ctcp_text: str
+    """
+
+    def __init__(self, *, bot=None, hook=None, conn=None, base_event=None, event_type=EventType.other, content=None,
+                 target=None, channel=None, nick=None, user=None, host=None, mask=None, irc_raw=None, irc_prefix=None,
+                 irc_command=None, irc_paramlist=None, irc_ctcp_text=None):
+        """
+        All of these parameters except for `bot` and `hook` are optional.
+        The irc_* parameters should only be specified for IRC events.
+
+        Note that the `bot` argument may be left out if you specify a `base_event`.
+
+        :param bot: The CloudBot instance this event was triggered from
+        :param conn: The Connection instance this event was triggered from
+        :param hook: The hook this event will be passed to
+        :param base_event: The base event that this event is based on. If this parameter is not None, then nick, user,
+                            host, mask, and irc_* arguments are ignored
+        :param event_type: The type of the event
+        :param content: The content of the message, or the reason for an join or part
+        :param target: The target of the action, for example the user being kicked, or invited
+        :param channel: The channel that this action took place in
+        :param nick: The nickname of the sender that triggered this event
+        :param user: The user of the sender that triggered this event
+        :param host: The host of the sender that triggered this event
+        :param mask: The mask of the sender that triggered this event (nick!user@host)
+        :param irc_raw: The raw IRC line
+        :param irc_prefix: The raw IRC prefix
+        :param irc_command: The IRC command
+        :param irc_paramlist: The list of params for the IRC command. If the last param is a content param, the ':'
+                                should be removed from the front.
+        :param irc_ctcp_text: CTCP text if this message is a CTCP command
+        :type bot: cloudbot.bot.CloudBot
+        :type conn: cloudbot.connection.Connection
+        :type hook: cloudbot.pluginmanager.Hook
+        :type base_event: cloudbot.events.BaseEvent
+        :type content: str
+        :type target: str
+        :type event_type: EventType
+        :type nick: str
+        :type user: str
+        :type host: str
+        :type mask: str
+        :type irc_raw: str
+        :type irc_prefix: str
+        :type irc_command: str
+        :type irc_paramlist: list[str]
+        :type irc_ctcp_text: str
+        """
+        self.db = None
+        self.db_executor = None
+        self.bot = bot
+        self.conn = conn
+        self.hook = hook
+        if base_event is not None:
+            # We're copying an event, so inherit values
+            if self.bot is None and base_event.bot is not None:
+                self.bot = base_event.bot
+            if self.conn is None and base_event.conn is not None:
+                self.conn = base_event.conn
+            if self.hook is None and base_event.hook is not None:
+                self.hook = base_event.hook
+
+            # If base_event is provided, don't check these parameters, just inherit
+            self.type = base_event.type
+            self.content = base_event.content
+            self.target = base_event.target
+            self.chan = base_event.chan
+            self.nick = base_event.nick
+            self.user = base_event.user
+            self.host = base_event.host
+            self.mask = base_event.mask
+            # irc-specific parameters
+            self.irc_raw = base_event.irc_raw
+            self.irc_prefix = base_event.irc_prefix
+            self.irc_command = base_event.irc_command
+            self.irc_paramlist = base_event.irc_paramlist
+            self.irc_ctcp_text = base_event.irc_ctcp_text
+        else:
+            # Since base_event wasn't provided, we can take these parameters
+            self.type = event_type
+            self.content = content
+            self.target = target
+            self.chan = channel
+            self.nick = nick
+            self.user = user
+            self.host = host
+            self.mask = mask
+            # irc-specific parameters
+            self.irc_raw = irc_raw
+            self.irc_prefix = irc_prefix
+            self.irc_command = irc_command
+            self.irc_paramlist = irc_paramlist
+            self.irc_ctcp_text = irc_ctcp_text
+
+    @asyncio.coroutine
+    def prepare(self):
+        """
+        Initializes this event to be run through it's hook
+
+        Mainly, initializes a database object on this event, if the hook requires it.
+
+        This method is for when the hook is *not* threaded (event.hook.threaded is False).
+        If you need to add a db to a threaded hook, use prepare_threaded.
+        """
+
+        if self.hook is None:
+            raise ValueError("event.hook is required to prepare an event")
+
+        if "db" in self.hook.required_args:
+            logger.debug("Opening database session for {}:threaded=False".format(self.hook.description))
+
+            # we're running a coroutine hook with a db, so initialise an executor pool
+            self.db_executor = concurrent.futures.ThreadPoolExecutor(1)
+            # be sure to initialize the db in the database executor, so it will be accessible in that thread.
+            self.db = yield from self.async(self.bot.db_session)
+
+    def prepare_threaded(self):
+        """
+        Initializes this event to be run through it's hook
+
+        Mainly, initializes the database object on this event, if the hook requires it.
+
+        This method is for when the hook is threaded (event.hook.threaded is True).
+        If you need to add a db to a coroutine hook, use prepare.
+        """
+
+        if self.hook is None:
+            raise ValueError("event.hook is required to prepare an event")
+
+        if "db" in self.hook.required_args:
+            logger.debug("Opening database session for {}:threaded=True".format(self.hook.description))
+
+            self.db = self.bot.db_session()
+
+    @asyncio.coroutine
+    def close(self):
+        """
+        Closes this event after running it through it's hook.
+
+        Mainly, closes the database connection attached to this event (if any).
+
+        This method is for when the hook is *not* threaded (event.hook.threaded is False).
+        If you need to add a db to a threaded hook, use close_threaded.
+        """
+        if self.hook is None:
+            raise ValueError("event.hook is required to close an event")
+
+        if self.db is not None:
+            logger.debug("Closing database session for {}:threaded=False".format(self.hook.description))
+            # be sure the close the database in the database executor, as it is only accessable in that one thread
+            yield from self.async(self.db.close)
+            self.db = None
+
+    def close_threaded(self):
+        """
+        Closes this event after running it through it's hook.
+
+        Mainly, closes the database connection attached to this event (if any).
+
+        This method is for when the hook is threaded (event.hook.threaded is True).
+        If you need to add a db to a coroutine hook, use close.
+        """
+        if self.hook is None:
+            raise ValueError("event.hook is required to close an event")
+        if self.db is not None:
+            logger.debug("Closing database session for {}:threaded=True".format(self.hook.description))
+            self.db.close()
+            self.db = None
+
+    @property
+    def event(self):
+        """
+        :rtype; cloudbot.events.BaseEvent
+        """
+        return self
+
+    @property
+    def loop(self):
+        """
+        :rtype: asyncio.events.AbstractEventLoop
+        """
+        return self.bot.loop
+
+    @property
+    def logger(self):
+        return logger
+
+    def message(self, message, target=None):
+        """sends a message to a specific or current channel/user
+        :type message: str
+        :type target: str
+        """
+        if target is None:
+            if self.chan is None:
+                raise ValueError("Target must be specified when chan is not assigned")
+            target = self.chan
+        self.conn.message(target, message)
+
+    def reply(self, message, target=None):
+        """sends a message to the current channel/user with a prefix
+        :type message: str
+        :type target: str
+        """
+        if target is None:
+            if self.chan is None:
+                raise ValueError("Target must be specified when chan is not assigned")
+            target = self.chan
+
+        if target == self.nick:
+            self.conn.message(target, message)
+        else:
+            self.conn.message(target, "({}) {}".format(self.nick, message))
+
+    def action(self, message, target=None):
+        """sends an action to the current channel/user or a specific channel/user
+        :type message: str
+        :type target: str
+        """
+        if target is None:
+            if self.chan is None:
+                raise ValueError("Target must be specified when chan is not assigned")
+            target = self.chan
+
+        self.conn.action(target, message)
+
+    def ctcp(self, message, ctcp_type, target=None):
+        """sends an ctcp to the current channel/user or a specific channel/user
+        :type message: str
+        :type ctcp_type: str
+        :type target: str
+        """
+        if target is None:
+            if self.chan is None:
+                raise ValueError("Target must be specified when chan is not assigned")
+            target = self.chan
+        if not hasattr(self.conn, "ctcp"):
+            raise ValueError("CTCP can only be used on IRC connections")
+        # noinspection PyUnresolvedReferences
+        self.conn.ctcp(target, ctcp_type, message)
+
+    def notice(self, message, target=None):
+        """sends a notice to the current channel/user or a specific channel/user
+        :type message: str
+        :type target: str
+        """
+        if target is None:
+            if self.nick is None:
+                raise ValueError("Target must be specified when nick is not assigned")
+            target = self.nick
+
+        self.conn.notice(target, message)
+
+    def has_permission(self, permission, notice=True):
+        """ returns whether or not the current user has a given permission
+        :type permission: str
+        :rtype: bool
+        """
+        if not self.mask:
+            raise ValueError("has_permission requires mask is not assigned")
+        return self.conn.permissions.has_perm_mask(self.mask, permission, notice=notice)
+
+    @asyncio.coroutine
+    def async(self, function, *args, **kwargs):
+        if self.db_executor is not None:
+            executor = self.db_executor
+        else:
+            executor = None
+        if kwargs:
+            result = yield from self.loop.run_in_executor(executor, function, *args)
+        else:
+            result = yield from self.loop.run_in_executor(executor, lambda: function(*args, **kwargs))
+        return result
+
+
+class CommandEvent(BaseEvent):
+    """
+    :type hook: cloudbot.pluginmanager.CommandHook
+    :type text: str
+    :type triggered_command: str
+    """
+
+    def __init__(self, *, bot=None, hook, text, triggered_command, conn=None, base_event=None, event_type=None,
+                 content=None, target=None, channel=None, nick=None, user=None, host=None, mask=None, irc_raw=None,
+                 irc_prefix=None, irc_command=None, irc_paramlist=None):
+        """
+        :param text: The arguments for the command
+        :param triggered_command: The command that was triggered
+        :type text: str
+        :type triggered_command: str
+        """
+        super().__init__(bot=bot, hook=hook, conn=conn, base_event=base_event, event_type=event_type, content=content,
+                         target=target, channel=channel, nick=nick, user=user, host=host, mask=mask, irc_raw=irc_raw,
+                         irc_prefix=irc_prefix, irc_command=irc_command, irc_paramlist=irc_paramlist)
+        self.hook = hook
+        self.text = text
+        self.triggered_command = triggered_command
+
+    def notice_doc(self, target=None):
+        """sends a notice containing this command's docstring to the current channel/user or a specific channel/user
+        :type target: str
+        """
+        if self.triggered_command is None:
+            raise ValueError("Triggered command not set on this event")
+        if self.hook.doc is None:
+            message = "{}{} requires additional arguments.".format(self.conn.config["command_prefix"],
+                                                                   self.triggered_command)
+        else:
+            if self.hook.doc.split()[0].isalpha():
+                # this is using the old format of `name <args> - doc`
+                message = "{}{}".format(self.conn.config["command_prefix"], self.hook.doc)
+            else:
+                # this is using the new format of `<args> - doc`
+                message = "{}{} {}".format(self.conn.config["command_prefix"], self.triggered_command, self.hook.doc)
+
+        self.notice(message, target=target)
+
+
+class RegexEvent(BaseEvent):
+    """
+    :type hook: cloudbot.pluginmanager.RegexHook
+    :type match: re.__Match
+    """
+
+    def __init__(self, *, bot=None, hook, match, conn=None, base_event=None, event_type=None, content=None, target=None,
+                 channel=None, nick=None, user=None, host=None, mask=None, irc_raw=None, irc_prefix=None,
+                 irc_command=None, irc_paramlist=None):
+        """
+        :param: match: The match objected returned by the regex search method
+        :type match: re.__Match
+        """
+        super().__init__(bot=bot, conn=conn, hook=hook, base_event=base_event, event_type=event_type, content=content,
+                         target=target, channel=channel, nick=nick, user=user, host=host, mask=mask, irc_raw=irc_raw,
+                         irc_prefix=irc_prefix, irc_command=irc_command, irc_paramlist=irc_paramlist)
+        self.match = match
diff --git a/cloudbot/hook.py b/cloudbot/hook.py
new file mode 100644
index 0000000..c03aeb2
--- /dev/null
+++ b/cloudbot/hook.py
@@ -0,0 +1,297 @@
+import inspect
+import re
+import collections
+
+from cloudbot.events import EventType
+
+valid_command_re = re.compile(r"^\w+$")
+
+
+class _Hook():
+    """
+    :type function: function
+    :type type: str
+    :type kwargs: dict[str, unknown]
+    """
+
+    def __init__(self, function, _type):
+        """
+        :type function: function
+        :type _type: str
+        """
+        self.function = function
+        self.type = _type
+        self.kwargs = {}
+
+    def _add_hook(self, kwargs):
+        """
+        :type kwargs: dict[str, unknown]
+        """
+        # update kwargs, overwriting duplicates
+        self.kwargs.update(kwargs)
+
+
+class _CommandHook(_Hook):
+    """
+    :type main_alias: str
+    :type aliases: set[str]
+    """
+
+    def __init__(self, function):
+        """
+        :type function: function
+        """
+        _Hook.__init__(self, function, "command")
+        self.aliases = set()
+        self.main_alias = None
+
+        if function.__doc__:
+            self.doc = function.__doc__.split('\n', 1)[0]
+        else:
+            self.doc = None
+
+    def add_hook(self, alias_param, kwargs):
+        """
+        :type alias_param: list[str] | str
+        """
+        self._add_hook(kwargs)
+
+        if not alias_param:
+            alias_param = self.function.__name__
+        if isinstance(alias_param, str):
+            alias_param = [alias_param]
+        if not self.main_alias:
+            self.main_alias = alias_param[0]
+        for alias in alias_param:
+            if not valid_command_re.match(alias):
+                raise ValueError("Invalid command name {}".format(alias))
+        self.aliases.update(alias_param)
+
+
+class _RegexHook(_Hook):
+    """
+    :type regexes: list[re.__Regex]
+    """
+
+    def __init__(self, function):
+        """
+        :type function: function
+        """
+        _Hook.__init__(self, function, "regex")
+        self.regexes = []
+
+    def add_hook(self, regex_param, kwargs):
+        """
+        :type regex_param: Iterable[str | re.__Regex] | str | re.__Regex
+        :type kwargs: dict[str, unknown]
+        """
+        self._add_hook(kwargs)
+        # add all regex_parameters to valid regexes
+        if isinstance(regex_param, str):
+            # if the parameter is a string, compile and add
+            self.regexes.append(re.compile(regex_param))
+        elif hasattr(regex_param, "search"):
+            # if the parameter is an re.__Regex, just add it
+            # we only use regex.search anyways, so this is a good determiner
+            self.regexes.append(regex_param)
+        else:
+            assert isinstance(regex_param, collections.Iterable)
+            # if the parameter is a list, add each one
+            for re_to_match in regex_param:
+                if isinstance(re_to_match, str):
+                    re_to_match = re.compile(re_to_match)
+                else:
+                    # make sure that the param is either a compiled regex, or has a search attribute.
+                    assert hasattr(regex_param, "search")
+                self.regexes.append(re_to_match)
+
+
+class _RawHook(_Hook):
+    """
+    :type triggers: set[str]
+    """
+
+    def __init__(self, function):
+        """
+        :type function: function
+        """
+        _Hook.__init__(self, function, "irc_raw")
+        self.triggers = set()
+
+    def add_hook(self, trigger_param, kwargs):
+        """
+        :type trigger_param: list[str] | str
+        :type kwargs: dict[str, unknown]
+        """
+        self._add_hook(kwargs)
+
+        if isinstance(trigger_param, str):
+            self.triggers.add(trigger_param)
+        else:
+            # it's a list
+            self.triggers.update(trigger_param)
+
+
+class _EventHook(_Hook):
+    """
+    :type types: set[cloudbot.events.EventType]
+    """
+
+    def __init__(self, function):
+        """
+        :type function: function
+        """
+        _Hook.__init__(self, function, "event")
+        self.types = set()
+
+    def add_hook(self, trigger_param, kwargs):
+        """
+        :type trigger_param: cloudbot.events.EventType | list[cloudbot.events.EventType]
+        :type kwargs: dict[str, unknown]
+        """
+        self._add_hook(kwargs)
+
+        if isinstance(trigger_param, EventType):
+            self.types.add(trigger_param)
+        else:
+            # it's a list
+            self.types.update(trigger_param)
+
+
+def _add_hook(func, hook):
+    if not hasattr(func, "_cloudbot_hook"):
+        func._cloudbot_hook = {}
+    else:
+        assert hook.type not in func._cloudbot_hook  # in this case the hook should be using the add_hook method
+    func._cloudbot_hook[hook.type] = hook
+
+
+def _get_hook(func, hook_type):
+    if hasattr(func, "_cloudbot_hook") and hook_type in func._cloudbot_hook:
+        return func._cloudbot_hook[hook_type]
+
+    return None
+
+
+def command(*args, **kwargs):
+    """External command decorator. Can be used directly as a decorator, or with args to return a decorator.
+    :type param: str | list[str] | function
+    """
+
+    def _command_hook(func, alias_param=None):
+        hook = _get_hook(func, "command")
+        if hook is None:
+            hook = _CommandHook(func)
+            _add_hook(func, hook)
+
+        hook.add_hook(alias_param, kwargs)
+        return func
+
+    if len(args) == 1 and callable(args[0]):  # this decorator is being used directly
+        return _command_hook(args[0])
+    else:  # this decorator is being used indirectly, so return a decorator function
+        return lambda func: _command_hook(func, alias_param=args)
+
+
+def irc_raw(triggers_param, **kwargs):
+    """External raw decorator. Must be used as a function to return a decorator
+    :type triggers_param: str | list[str]
+    """
+
+    def _raw_hook(func):
+        hook = _get_hook(func, "irc_raw")
+        if hook is None:
+            hook = _RawHook(func)
+            _add_hook(func, hook)
+
+        hook.add_hook(triggers_param, kwargs)
+        return func
+
+    if callable(triggers_param):  # this decorator is being used directly, which isn't good
+        raise TypeError("@irc_raw() must be used as a function that returns a decorator")
+    else:  # this decorator is being used as a function, so return a decorator
+        return lambda func: _raw_hook(func)
+
+
+def event(types_param, **kwargs):
+    """External event decorator. Must be used as a function to return a decorator
+    :type types_param: cloudbot.events.EventType | list[cloudbot.events.EventType]
+    """
+
+    def _event_hook(func):
+        hook = _get_hook(func, "event")
+        if hook is None:
+            hook = _EventHook(func)
+            _add_hook(func, hook)
+
+        hook.add_hook(types_param, kwargs)
+        return func
+
+    if callable(types_param):  # this decorator is being used directly, which isn't good
+        raise TypeError("@irc_raw() must be used as a function that returns a decorator")
+    else:  # this decorator is being used as a function, so return a decorator
+        return lambda func: _event_hook(func)
+
+
+def regex(regex_param, **kwargs):
+    """External regex decorator. Must be used as a function to return a decorator.
+    :type regex_param: str | re.__Regex | list[str | re.__Regex]
+    :type flags: int
+    """
+
+    def _regex_hook(func):
+        hook = _get_hook(func, "regex")
+        if hook is None:
+            hook = _RegexHook(func)
+            _add_hook(func, hook)
+
+        hook.add_hook(regex_param, kwargs)
+        return func
+
+    if callable(regex_param):  # this decorator is being used directly, which isn't good
+        raise TypeError("@regex() hook must be used as a function that returns a decorator")
+    else:  # this decorator is being used as a function, so return a decorator
+        return lambda func: _regex_hook(func)
+
+
+def sieve(param=None, **kwargs):
+    """External sieve decorator. Can be used directly as a decorator, or with args to return a decorator
+    :type param: function | None
+    """
+
+    def _sieve_hook(func):
+        assert len(inspect.getargspec(func).args) == 3, \
+            "Sieve plugin has incorrect argument count. Needs params: bot, input, plugin"
+
+        hook = _get_hook(func, "sieve")
+        if hook is None:
+            hook = _Hook(func, "sieve")  # there's no need to have a specific SieveHook object
+            _add_hook(func, hook)
+
+        hook._add_hook(kwargs)
+        return func
+
+    if callable(param):
+        return _sieve_hook(param)
+    else:
+        return lambda func: _sieve_hook(func)
+
+
+def onload(param=None, **kwargs):
+    """External onload decorator. Can be used directly as a decorator, or with args to return a decorator
+    :type param: function | None
+    """
+
+    def _onload_hook(func):
+        hook = _get_hook(func, "onload")
+        if hook is None:
+            hook = _Hook(func, "onload")
+            _add_hook(func, hook)
+
+        hook._add_hook(kwargs)
+        return func
+
+    if callable(param):
+        return _onload_hook(param)
+    else:
+        return lambda func: _onload_hook(func)
diff --git a/cloudbot/permissions.py b/cloudbot/permissions.py
index 4e42ec1..6652252 100644
--- a/cloudbot/permissions.py
+++ b/cloudbot/permissions.py
@@ -16,7 +16,7 @@ class PermissionManager(object):
 
     def __init__(self, conn):
         """
-        :type conn: cloudbot.core.connection.Client
+        :type conn: cloudbot.connection.Connection
         """
         logger.info("[{}] Created permission manager for {}.".format(conn.readable_name, conn.name))
 
diff --git a/cloudbot/plugin.py b/cloudbot/plugin.py
deleted file mode 100644
index 29b6936..0000000
--- a/cloudbot/plugin.py
+++ /dev/null
@@ -1,710 +0,0 @@
-import asyncio
-import glob
-import importlib
-import inspect
-import logging
-import os
-import re
-
-import sqlalchemy
-
-from cloudbot import event
-from cloudbot.util import botvars
-
-logger = logging.getLogger("cloudbot")
-
-
-def find_hooks(parent, module):
-    """
-    :type parent: Plugin
-    :type module: object
-    :rtype: (list[CommandHook], list[RegexHook], list[RawHook], list[SieveHook], List[EventHook], list[OnloadHook])
-    """
-    # set the loaded flag
-    module._cloudbot_loaded = True
-    command = []
-    regex = []
-    raw = []
-    sieve = []
-    event = []
-    onload = []
-    type_lists = {"command": command, "regex": regex, "irc_raw": raw, "sieve": sieve, "event": event, "onload": onload}
-    for name, func in module.__dict__.items():
-        if hasattr(func, "_cloudbot_hook"):
-            # if it has cloudbot hook
-            func_hooks = func._cloudbot_hook
-
-            for hook_type, func_hook in func_hooks.items():
-                type_lists[hook_type].append(_hook_name_to_plugin[hook_type](parent, func_hook))
-
-            # delete the hook to free memory
-            del func._cloudbot_hook
-
-    return command, regex, raw, sieve, event, onload
-
-
-def find_tables(code):
-    """
-    :type code: object
-    :rtype: list[sqlalchemy.Table]
-    """
-    tables = []
-    for name, obj in code.__dict__.items():
-        if isinstance(obj, sqlalchemy.Table) and obj.metadata == botvars.metadata:
-            # if it's a Table, and it's using our metadata, append it to the list
-            tables.append(obj)
-
-    return tables
-
-
-class PluginManager:
-    """
-    PluginManager is the core of CloudBot plugin loading.
-
-    PluginManager loads Plugins, and adds their Hooks to easy-access dicts/lists.
-
-    Each Plugin represents a file, and loads hooks onto itself using find_hooks.
-
-    Plugins are the lowest level of abstraction in this class. There are four different plugin types:
-    - CommandPlugin is for bot commands
-    - RawPlugin hooks onto irc_raw irc lines
-    - RegexPlugin loads a regex parameter, and executes on irc lines which match the regex
-    - SievePlugin is a catch-all sieve, which all other plugins go through before being executed.
-
-    :type bot: cloudbot.core.bot.CloudBot
-    :type plugins: dict[str, Plugin]
-    :type commands: dict[str, CommandHook]
-    :type raw_triggers: dict[str, list[RawHook]]
-    :type catch_all_triggers: list[RawHook]
-    :type event_type_hooks: dict[cloudbot.core.events.EventType, list[EventHook]]
-    :type regex_hooks: list[(re.__Regex, RegexHook)]
-    :type sieves: list[SieveHook]
-    """
-
-    def __init__(self, bot):
-        """
-        Creates a new PluginManager. You generally only need to do this from inside cloudbot.core.bot.CloudBot
-        :type bot: cloudbot.core.bot.CloudBot
-        """
-        self.bot = bot
-
-        self.plugins = {}
-        self.commands = {}
-        self.raw_triggers = {}
-        self.catch_all_triggers = []
-        self.event_type_hooks = {}
-        self.regex_hooks = []
-        self.sieves = []
-        self._hook_waiting_queues = {}
-
-    @asyncio.coroutine
-    def load_all(self, plugin_dir):
-        """
-        Load a plugin from each *.py file in the given directory.
-
-        Won't load any plugins listed in "disabled_plugins".
-
-        :type plugin_dir: str
-        """
-        path_list = glob.iglob(os.path.join(plugin_dir, '*.py'))
-        # Load plugins asynchronously :O
-        yield from asyncio.gather(*[self.load_plugin(path) for path in path_list], loop=self.bot.loop)
-
-    @asyncio.coroutine
-    def load_plugin(self, path):
-        """
-        Loads a plugin from the given path and plugin object, then registers all hooks from that plugin.
-
-        Won't load any plugins listed in "disabled_plugins".
-
-        :type path: str
-        """
-        file_path = os.path.abspath(path)
-        file_name = os.path.basename(path)
-        title = os.path.splitext(file_name)[0]
-
-        if "plugin_loading" in self.bot.config:
-            pl = self.bot.config.get("plugin_loading")
-
-            if pl.get("use_whitelist", False):
-                if title not in pl.get("whitelist", []):
-                    logger.info('Not loading plugin module "{}": plugin not whitelisted'.format(file_name))
-                    return
-            else:
-                if title in pl.get("blacklist", []):
-                    logger.info('Not loading plugin module "{}": plugin blacklisted'.format(file_name))
-                    return
-
-        # make sure to unload the previously loaded plugin from this path, if it was loaded.
-        if file_name in self.plugins:
-            yield from self._unload(file_path)
-
-        module_name = "plugins.{}".format(title)
-        try:
-            plugin_module = importlib.import_module(module_name)
-            # if this plugin was loaded before, reload it
-            if hasattr(plugin_module, "_cloudbot_loaded"):
-                importlib.reload(plugin_module)
-        except Exception:
-            logger.exception("Error loading {}:".format(file_name))
-            return
-
-        # create the plugin
-        plugin = Plugin(file_path, file_name, title, plugin_module)
-
-        # proceed to register hooks
-
-        # create database tables
-        yield from plugin.create_tables(self.bot)
-
-        # run onload hooks
-        for onload_hook in plugin.run_on_load:
-            success = yield from self.launch(onload_hook, event.Event(bot=self.bot, hook=onload_hook))
-            if not success:
-                logger.warning("Not registering hooks from plugin {}: onload hook errored".format(plugin.title))
-
-                # unregister databases
-                plugin.unregister_tables(self.bot)
-                return
-
-        self.plugins[plugin.file_name] = plugin
-
-        # register commands
-        for command_hook in plugin.commands:
-            for alias in command_hook.aliases:
-                if alias in self.commands:
-                    logger.warning(
-                        "Plugin {} attempted to register command {} which was already registered by {}. "
-                        "Ignoring new assignment.".format(plugin.title, alias, self.commands[alias].plugin.title))
-                else:
-                    self.commands[alias] = command_hook
-            self._log_hook(command_hook)
-
-        # register raw hooks
-        for raw_hook in plugin.raw_hooks:
-            if raw_hook.is_catch_all():
-                self.catch_all_triggers.append(raw_hook)
-            else:
-                for trigger in raw_hook.triggers:
-                    if trigger in self.raw_triggers:
-                        self.raw_triggers[trigger].append(raw_hook)
-                    else:
-                        self.raw_triggers[trigger] = [raw_hook]
-            self._log_hook(raw_hook)
-
-        # register events
-        for event_hook in plugin.events:
-            for event_type in event_hook.types:
-                if event_type in self.event_type_hooks:
-                    self.event_type_hooks[event_type].append(event_hook)
-                else:
-                    self.event_type_hooks[event_type] = [event_hook]
-            self._log_hook(event_hook)
-
-        # register regexps
-        for regex_hook in plugin.regexes:
-            for regex_match in regex_hook.regexes:
-                self.regex_hooks.append((regex_match, regex_hook))
-            self._log_hook(regex_hook)
-
-        # register sieves
-        for sieve_hook in plugin.sieves:
-            self.sieves.append(sieve_hook)
-            self._log_hook(sieve_hook)
-
-        # we don't need this anymore
-        del plugin.run_on_load
-
-    @asyncio.coroutine
-    def _unload(self, path):
-        """
-        Unloads the plugin from the given path, unregistering all hooks from the plugin.
-
-        Returns True if the plugin was unloaded, False if the plugin wasn't loaded in the first place.
-
-        :type path: str
-        :rtype: bool
-        """
-        file_name = os.path.basename(path)
-        title = os.path.splitext(file_name)[0]
-        if "disabled_plugins" in self.bot.config and title in self.bot.config['disabled_plugins']:
-            # this plugin hasn't been loaded, so no need to unload it
-            return False
-
-        # make sure this plugin is actually loaded
-        if not file_name in self.plugins:
-            return False
-
-        # get the loaded plugin
-        plugin = self.plugins[file_name]
-
-        # unregister commands
-        for command_hook in plugin.commands:
-            for alias in command_hook.aliases:
-                if alias in self.commands and self.commands[alias] == command_hook:
-                    # we need to make sure that there wasn't a conflict, so we don't delete another plugin's command
-                    del self.commands[alias]
-
-        # unregister raw hooks
-        for raw_hook in plugin.raw_hooks:
-            if raw_hook.is_catch_all():
-                self.catch_all_triggers.remove(raw_hook)
-            else:
-                for trigger in raw_hook.triggers:
-                    assert trigger in self.raw_triggers  # this can't be not true
-                    self.raw_triggers[trigger].remove(raw_hook)
-                    if not self.raw_triggers[trigger]:  # if that was the last hook for this trigger
-                        del self.raw_triggers[trigger]
-
-        # unregister events
-        for event_hook in plugin.events:
-            for event_type in event_hook.types:
-                assert event_type in self.event_type_hooks  # this can't be not true
-                self.event_type_hooks[event_type].remove(event_hook)
-                if not self.event_type_hooks[event_type]:  # if that was the last hook for this event type
-                    del self.event_type_hooks[event_type]
-
-        # unregister regexps
-        for regex_hook in plugin.regexes:
-            for regex_match in regex_hook.regexes:
-                self.regex_hooks.remove((regex_match, regex_hook))
-
-        # unregister sieves
-        for sieve_hook in plugin.sieves:
-            self.sieves.remove(sieve_hook)
-
-        # unregister databases
-        plugin.unregister_tables(self.bot)
-
-        # remove last reference to plugin
-        del self.plugins[plugin.file_name]
-
-        if self.bot.config.get("logging", {}).get("show_plugin_loading", True):
-            logger.info("Unloaded all plugins from {}".format(plugin.title))
-
-        return True
-
-    def _log_hook(self, hook):
-        """
-        Logs registering a given hook
-
-        :type hook: Hook
-        """
-        if self.bot.config.get("logging", {}).get("show_plugin_loading", True):
-            logger.info("Loaded {}".format(hook))
-            logger.debug("Loaded {}".format(repr(hook)))
-
-    def _prepare_parameters(self, hook, event):
-        """
-        Prepares arguments for the given hook
-
-        :type hook: cloudbot.core.pluginmanager.Hook
-        :type event: cloudbot.core.events.Event
-        :rtype: list
-        """
-        parameters = []
-        for required_arg in hook.required_args:
-            if hasattr(event, required_arg):
-                value = getattr(event, required_arg)
-                parameters.append(value)
-            else:
-                logger.error("Plugin {} asked for invalid argument '{}', cancelling execution!"
-                             .format(hook.description, required_arg))
-                logger.debug("Valid arguments are: {} ({})".format(dir(event), event))
-                return None
-        return parameters
-
-    def _execute_hook_threaded(self, hook, event):
-        """
-        :type hook: Hook
-        :type event: cloudbot.core.events.Event
-        """
-        event.prepare_threaded()
-
-        parameters = self._prepare_parameters(hook, event)
-        if parameters is None:
-            return None
-
-        try:
-            return hook.function(*parameters)
-        finally:
-            event.close_threaded()
-
-    @asyncio.coroutine
-    def _execute_hook_sync(self, hook, event):
-        """
-        :type hook: Hook
-        :type event: cloudbot.core.events.Event
-        """
-        yield from event.prepare()
-
-        parameters = self._prepare_parameters(hook, event)
-        if parameters is None:
-            return None
-
-        try:
-            return (yield from hook.function(*parameters))
-        finally:
-            yield from event.close()
-
-    @asyncio.coroutine
-    def _execute_hook(self, hook, event):
-        """
-        Runs the specific hook with the given bot and event.
-
-        Returns False if the hook errored, True otherwise.
-
-        :type hook: cloudbot.core.pluginmanager.Hook
-        :type event: cloudbot.core.events.Event
-        :rtype: bool
-        """
-        try:
-            # _internal_run_threaded and _internal_run_coroutine prepare the database, and run the hook.
-            # _internal_run_* will prepare parameters and the database session, but won't do any error catching.
-            if hook.threaded:
-                out = yield from self.bot.loop.run_in_executor(None, self._execute_hook_threaded, hook, event)
-            else:
-                out = yield from self._execute_hook_sync(hook, event)
-        except Exception:
-            logger.exception("Error in hook {}".format(hook.description))
-            return False
-
-        if out is not None:
-            # if there are multiple items in the response, return them on multiple lines
-            if isinstance(out, (list, tuple)):
-                event.reply(out[0])
-                for line in out[1:]:
-                    event.message(line)
-            else:
-                event.reply(str(out))
-        return True
-
-    @asyncio.coroutine
-    def _sieve(self, sieve, event, hook):
-        """
-        :type sieve: cloudbot.core.pluginmanager.Hook
-        :type event: cloudbot.core.events.Event
-        :type hook: cloudbot.core.pluginmanager.Hook
-        :rtype: cloudbot.core.events.Event
-        """
-        try:
-            if sieve.threaded:
-                result = yield from self.bot.loop.run_in_executor(None, sieve.function, self.bot, event, hook)
-            else:
-                result = yield from sieve.function(self.bot, event, hook)
-        except Exception:
-            logger.exception("Error running sieve {} on {}:".format(sieve.description, hook.description))
-            return None
-        else:
-            return result
-
-    @asyncio.coroutine
-    def launch(self, hook, event):
-        """
-        Dispatch a given event to a given hook using a given bot object.
-
-        Returns False if the hook didn't run successfully, and True if it ran successfully.
-
-        :type event: cloudbot.core.events.Event | cloudbot.core.events.CommandEvent
-        :type hook: cloudbot.core.pluginmanager.Hook | cloudbot.core.pluginmanager.CommandHook
-        :rtype: bool
-        """
-        if hook.type != "onload":  # we don't need sieves on onload hooks.
-            for sieve in self.bot.plugin_manager.sieves:
-                event = yield from self._sieve(sieve, event, hook)
-                if event is None:
-                    return False
-
-        if hook.type == "command" and hook.auto_help and not event.text and hook.doc is not None:
-            event.notice_doc()
-            return False
-
-        if hook.single_thread:
-            # There should only be one running instance of this hook, so let's wait for the last event to be processed
-            # before starting this one.
-
-            key = (hook.plugin.title, hook.function_name)
-            if key in self._hook_waiting_queues:
-                queue = self._hook_waiting_queues[key]
-                if queue is None:
-                    # there's a hook running, but the queue hasn't been created yet, since there's only one hook
-                    queue = asyncio.Queue()
-                    self._hook_waiting_queues[key] = queue
-                assert isinstance(queue, asyncio.Queue)
-                # create a future to represent this task
-                future = asyncio.Future()
-                queue.put_nowait(future)
-                # wait until the last task is completed
-                yield from future
-            else:
-                # set to None to signify that this hook is running, but there's no need to create a full queue
-                # in case there are no more hooks that will wait
-                self._hook_waiting_queues[key] = None
-
-            # Run the plugin with the message, and wait for it to finish
-            result = yield from self._execute_hook(hook, event)
-
-            queue = self._hook_waiting_queues[key]
-            if queue is None or queue.empty():
-                # We're the last task in the queue, we can delete it now.
-                del self._hook_waiting_queues[key]
-            else:
-                # set the result for the next task's future, so they can execute
-                next_future = yield from queue.get()
-                next_future.set_result(None)
-        else:
-            # Run the plugin with the message, and wait for it to finish
-            result = yield from self._execute_hook(hook, event)
-
-        # Return the result
-        return result
-
-
-class Plugin:
-    """
-    Each Plugin represents a plugin file, and contains loaded hooks.
-
-    :type file_path: str
-    :type file_name: str
-    :type title: str
-    :type commands: list[CommandHook]
-    :type regexes: list[RegexHook]
-    :type raw_hooks: list[RawHook]
-    :type sieves: list[SieveHook]
-    :type events: list[EventHook]
-    :type tables: list[sqlalchemy.Table]
-    """
-
-    def __init__(self, filepath, filename, title, code):
-        """
-        :type filepath: str
-        :type filename: str
-        :type code: object
-        """
-        self.file_path = filepath
-        self.file_name = filename
-        self.title = title
-        self.commands, self.regexes, self.raw_hooks, self.sieves, self.events, self.run_on_load = find_hooks(self, code)
-        # we need to find tables for each plugin so that they can be unloaded from the global metadata when the
-        # plugin is reloaded
-        self.tables = find_tables(code)
-
-    @asyncio.coroutine
-    def create_tables(self, bot):
-        """
-        Creates all sqlalchemy Tables that are registered in this plugin
-
-        :type bot: cloudbot.core.bot.CloudBot
-        """
-        if self.tables:
-            # if there are any tables
-
-            logger.info("Registering tables for {}".format(self.title))
-
-            for table in self.tables:
-                if not (yield from bot.loop.run_in_executor(None, table.exists, bot.db_engine)):
-                    yield from bot.loop.run_in_executor(None, table.create, bot.db_engine)
-
-    def unregister_tables(self, bot):
-        """
-        Unregisters all sqlalchemy Tables registered to the global metadata by this plugin
-        :type bot: cloudbot.core.bot.CloudBot
-        """
-        if self.tables:
-            # if there are any tables
-            logger.info("Unregistering tables for {}".format(self.title))
-
-            for table in self.tables:
-                bot.db_metadata.remove(table)
-
-
-class Hook:
-    """
-    Each hook is specific to one function. This class is never used by itself, rather extended.
-
-    :type type; str
-    :type plugin: Plugin
-    :type function: callable
-    :type function_name: str
-    :type required_args: list[str]
-    :type threaded: bool
-    :type ignore_bots: bool
-    :type permissions: list[str]
-    :type single_thread: bool
-    """
-
-    def __init__(self, _type, plugin, func_hook):
-        """
-        :type _type: str
-        :type plugin: Plugin
-        :type func_hook: hook._Hook
-        """
-        self.type = _type
-        self.plugin = plugin
-        self.function = func_hook.function
-        self.function_name = self.function.__name__
-
-        self.required_args = inspect.getargspec(self.function)[0]
-        if self.required_args is None:
-            self.required_args = []
-
-        if asyncio.iscoroutine(self.function) or asyncio.iscoroutinefunction(self.function):
-            self.threaded = False
-        else:
-            self.threaded = True
-
-        self.ignore_bots = func_hook.kwargs.pop("ignorebots", False)
-        self.permissions = func_hook.kwargs.pop("permissions", [])
-        self.single_thread = func_hook.kwargs.pop("singlethread", False)
-
-        if func_hook.kwargs:
-            # we should have popped all the args, so warn if there are any left
-            logger.warning("Ignoring extra args {} from {}".format(func_hook.kwargs, self.description))
-
-    @property
-    def description(self):
-        return "{}:{}".format(self.plugin.title, self.function_name)
-
-    def __repr__(self):
-        return "type: {}, plugin: {}, ignore_bots: {}, permissions: {}, single_thread: {}, threaded: {}".format(
-            self.type, self.plugin.title, self.ignore_bots, self.permissions, self.single_thread, self.threaded
-        )
-
-
-class CommandHook(Hook):
-    """
-    :type name: str
-    :type aliases: list[str]
-    :type doc: str
-    :type auto_help: bool
-    """
-
-    def __init__(self, plugin, cmd_hook):
-        """
-        :type plugin: Plugin
-        :type cmd_hook: cloudbot.util.hook._CommandHook
-        """
-        self.auto_help = cmd_hook.kwargs.pop("autohelp", True)
-
-        self.name = cmd_hook.main_alias
-        self.aliases = list(cmd_hook.aliases)  # turn the set into a list
-        self.aliases.remove(self.name)
-        self.aliases.insert(0, self.name)  # make sure the name, or 'main alias' is in position 0
-        self.doc = cmd_hook.doc
-
-        super().__init__("command", plugin, cmd_hook)
-
-    def __repr__(self):
-        return "Command[name: {}, aliases: {}, {}]".format(self.name, self.aliases[1:], Hook.__repr__(self))
-
-    def __str__(self):
-        return "command {} from {}".format("/".join(self.aliases), self.plugin.file_name)
-
-
-class RegexHook(Hook):
-    """
-    :type regexes: set[re.__Regex]
-    """
-
-    def __init__(self, plugin, regex_hook):
-        """
-        :type plugin: Plugin
-        :type regex_hook: cloudbot.util.hook._RegexHook
-        """
-        self.regexes = regex_hook.regexes
-
-        super().__init__("regex", plugin, regex_hook)
-
-    def __repr__(self):
-        return "Regex[regexes: [{}], {}]".format(", ".join(regex.pattern for regex in self.regexes),
-                                                 Hook.__repr__(self))
-
-    def __str__(self):
-        return "regex {} from {}".format(self.function_name, self.plugin.file_name)
-
-
-class RawHook(Hook):
-    """
-    :type triggers: set[str]
-    """
-
-    def __init__(self, plugin, irc_raw_hook):
-        """
-        :type plugin: Plugin
-        :type irc_raw_hook: cloudbot.util.hook._RawHook
-        """
-        super().__init__("irc_raw", plugin, irc_raw_hook)
-
-        self.triggers = irc_raw_hook.triggers
-
-    def is_catch_all(self):
-        return "*" in self.triggers
-
-    def __repr__(self):
-        return "Raw[triggers: {}, {}]".format(list(self.triggers), Hook.__repr__(self))
-
-    def __str__(self):
-        return "irc raw {} ({}) from {}".format(self.function_name, ",".join(self.triggers), self.plugin.file_name)
-
-
-class SieveHook(Hook):
-    def __init__(self, plugin, sieve_hook):
-        """
-        :type plugin: Plugin
-        :type sieve_hook: cloudbot.util.hook._SieveHook
-        """
-        # We don't want to thread sieves by default - this is retaining old behavior for compatibility
-        super().__init__("sieve", plugin, sieve_hook)
-
-    def __repr__(self):
-        return "Sieve[{}]".format(Hook.__repr__(self))
-
-    def __str__(self):
-        return "sieve {} from {}".format(self.function_name, self.plugin.file_name)
-
-
-class EventHook(Hook):
-    """
-    :type types: set[cloudbot.core.events.EventType]
-    """
-
-    def __init__(self, plugin, event_hook):
-        """
-        :type plugin: Plugin
-        :type event_hook: cloudbot.util.hook._EventHook
-        """
-        super().__init__("event", plugin, event_hook)
-
-        self.types = event_hook.types
-
-    def __repr__(self):
-        return "Event[types: {}, {}]".format(list(self.types), Hook.__repr__(self))
-
-    def __str__(self):
-        return "event {} ({}) from {}".format(self.function_name, ",".join(str(t) for t in self.types),
-                                              self.plugin.file_name)
-
-
-class OnloadHook(Hook):
-    def __init__(self, plugin, on_load_hook):
-        """
-        :type plugin: Plugin
-        :type on_load_hook: cloudbot.util.hook._OnLoadHook
-        """
-        super().__init__("onload", plugin, on_load_hook)
-
-    def __repr__(self):
-        return "Onload[{}]".format(Hook.__repr__(self))
-
-    def __str__(self):
-        return "onload {} from {}".format(self.function_name, self.plugin.file_name)
-
-
-_hook_name_to_plugin = {
-    "command": CommandHook,
-    "regex": RegexHook,
-    "irc_raw": RawHook,
-    "sieve": SieveHook,
-    "event": EventHook,
-    "onload": OnloadHook
-}
diff --git a/cloudbot/pluginmanager.py b/cloudbot/pluginmanager.py
new file mode 100644
index 0000000..5fec67b
--- /dev/null
+++ b/cloudbot/pluginmanager.py
@@ -0,0 +1,710 @@
+import asyncio
+import glob
+import importlib
+import inspect
+import logging
+import os
+import re
+
+import sqlalchemy
+
+from cloudbot import events
+from cloudbot.util import botvars
+
+logger = logging.getLogger("cloudbot")
+
+
+def find_hooks(parent, module):
+    """
+    :type parent: Plugin
+    :type module: object
+    :rtype: (list[CommandHook], list[RegexHook], list[RawHook], list[SieveHook], List[EventHook], list[OnloadHook])
+    """
+    # set the loaded flag
+    module._cloudbot_loaded = True
+    command = []
+    regex = []
+    raw = []
+    sieve = []
+    event = []
+    onload = []
+    type_lists = {"command": command, "regex": regex, "irc_raw": raw, "sieve": sieve, "event": event, "onload": onload}
+    for name, func in module.__dict__.items():
+        if hasattr(func, "_cloudbot_hook"):
+            # if it has cloudbot hook
+            func_hooks = func._cloudbot_hook
+
+            for hook_type, func_hook in func_hooks.items():
+                type_lists[hook_type].append(_hook_name_to_plugin[hook_type](parent, func_hook))
+
+            # delete the hook to free memory
+            del func._cloudbot_hook
+
+    return command, regex, raw, sieve, event, onload
+
+
+def find_tables(code):
+    """
+    :type code: object
+    :rtype: list[sqlalchemy.Table]
+    """
+    tables = []
+    for name, obj in code.__dict__.items():
+        if isinstance(obj, sqlalchemy.Table) and obj.metadata == botvars.metadata:
+            # if it's a Table, and it's using our metadata, append it to the list
+            tables.append(obj)
+
+    return tables
+
+
+class PluginManager:
+    """
+    PluginManager is the core of CloudBot plugin loading.
+
+    PluginManager loads Plugins, and adds their Hooks to easy-access dicts/lists.
+
+    Each Plugin represents a file, and loads hooks onto itself using find_hooks.
+
+    Plugins are the lowest level of abstraction in this class. There are four different plugin types:
+    - CommandPlugin is for bot commands
+    - RawPlugin hooks onto irc_raw irc lines
+    - RegexPlugin loads a regex parameter, and executes on irc lines which match the regex
+    - SievePlugin is a catch-all sieve, which all other plugins go through before being executed.
+
+    :type bot: cloudbot.bot.CloudBot
+    :type plugins: dict[str, Plugin]
+    :type commands: dict[str, CommandHook]
+    :type raw_triggers: dict[str, list[RawHook]]
+    :type catch_all_triggers: list[RawHook]
+    :type event_type_hooks: dict[cloudbot.events.EventType, list[EventHook]]
+    :type regex_hooks: list[(re.__Regex, RegexHook)]
+    :type sieves: list[SieveHook]
+    """
+
+    def __init__(self, bot):
+        """
+        Creates a new PluginManager. You generally only need to do this from inside cloudbot.bot.CloudBot
+        :type bot: cloudbot.bot.CloudBot
+        """
+        self.bot = bot
+
+        self.plugins = {}
+        self.commands = {}
+        self.raw_triggers = {}
+        self.catch_all_triggers = []
+        self.event_type_hooks = {}
+        self.regex_hooks = []
+        self.sieves = []
+        self._hook_waiting_queues = {}
+
+    @asyncio.coroutine
+    def load_all(self, plugin_dir):
+        """
+        Load a plugin from each *.py file in the given directory.
+
+        Won't load any plugins listed in "disabled_plugins".
+
+        :type plugin_dir: str
+        """
+        path_list = glob.iglob(os.path.join(plugin_dir, '*.py'))
+        # Load plugins asynchronously :O
+        yield from asyncio.gather(*[self.load_plugin(path) for path in path_list], loop=self.bot.loop)
+
+    @asyncio.coroutine
+    def load_plugin(self, path):
+        """
+        Loads a plugin from the given path and plugin object, then registers all hooks from that plugin.
+
+        Won't load any plugins listed in "disabled_plugins".
+
+        :type path: str
+        """
+        file_path = os.path.abspath(path)
+        file_name = os.path.basename(path)
+        title = os.path.splitext(file_name)[0]
+
+        if "plugin_loading" in self.bot.config:
+            pl = self.bot.config.get("plugin_loading")
+
+            if pl.get("use_whitelist", False):
+                if title not in pl.get("whitelist", []):
+                    logger.info('Not loading plugin module "{}": plugin not whitelisted'.format(file_name))
+                    return
+            else:
+                if title in pl.get("blacklist", []):
+                    logger.info('Not loading plugin module "{}": plugin blacklisted'.format(file_name))
+                    return
+
+        # make sure to unload the previously loaded plugin from this path, if it was loaded.
+        if file_name in self.plugins:
+            yield from self._unload(file_path)
+
+        module_name = "plugins.{}".format(title)
+        try:
+            plugin_module = importlib.import_module(module_name)
+            # if this plugin was loaded before, reload it
+            if hasattr(plugin_module, "_cloudbot_loaded"):
+                importlib.reload(plugin_module)
+        except Exception:
+            logger.exception("Error loading {}:".format(file_name))
+            return
+
+        # create the plugin
+        plugin = Plugin(file_path, file_name, title, plugin_module)
+
+        # proceed to register hooks
+
+        # create database tables
+        yield from plugin.create_tables(self.bot)
+
+        # run onload hooks
+        for onload_hook in plugin.run_on_load:
+            success = yield from self.launch(onload_hook, events.BaseEvent(bot=self.bot, hook=onload_hook))
+            if not success:
+                logger.warning("Not registering hooks from plugin {}: onload hook errored".format(plugin.title))
+
+                # unregister databases
+                plugin.unregister_tables(self.bot)
+                return
+
+        self.plugins[plugin.file_name] = plugin
+
+        # register commands
+        for command_hook in plugin.commands:
+            for alias in command_hook.aliases:
+                if alias in self.commands:
+                    logger.warning(
+                        "Plugin {} attempted to register command {} which was already registered by {}. "
+                        "Ignoring new assignment.".format(plugin.title, alias, self.commands[alias].plugin.title))
+                else:
+                    self.commands[alias] = command_hook
+            self._log_hook(command_hook)
+
+        # register raw hooks
+        for raw_hook in plugin.raw_hooks:
+            if raw_hook.is_catch_all():
+                self.catch_all_triggers.append(raw_hook)
+            else:
+                for trigger in raw_hook.triggers:
+                    if trigger in self.raw_triggers:
+                        self.raw_triggers[trigger].append(raw_hook)
+                    else:
+                        self.raw_triggers[trigger] = [raw_hook]
+            self._log_hook(raw_hook)
+
+        # register events
+        for event_hook in plugin.events:
+            for event_type in event_hook.types:
+                if event_type in self.event_type_hooks:
+                    self.event_type_hooks[event_type].append(event_hook)
+                else:
+                    self.event_type_hooks[event_type] = [event_hook]
+            self._log_hook(event_hook)
+
+        # register regexps
+        for regex_hook in plugin.regexes:
+            for regex_match in regex_hook.regexes:
+                self.regex_hooks.append((regex_match, regex_hook))
+            self._log_hook(regex_hook)
+
+        # register sieves
+        for sieve_hook in plugin.sieves:
+            self.sieves.append(sieve_hook)
+            self._log_hook(sieve_hook)
+
+        # we don't need this anymore
+        del plugin.run_on_load
+
+    @asyncio.coroutine
+    def _unload(self, path):
+        """
+        Unloads the plugin from the given path, unregistering all hooks from the plugin.
+
+        Returns True if the plugin was unloaded, False if the plugin wasn't loaded in the first place.
+
+        :type path: str
+        :rtype: bool
+        """
+        file_name = os.path.basename(path)
+        title = os.path.splitext(file_name)[0]
+        if "disabled_plugins" in self.bot.config and title in self.bot.config['disabled_plugins']:
+            # this plugin hasn't been loaded, so no need to unload it
+            return False
+
+        # make sure this plugin is actually loaded
+        if not file_name in self.plugins:
+            return False
+
+        # get the loaded plugin
+        plugin = self.plugins[file_name]
+
+        # unregister commands
+        for command_hook in plugin.commands:
+            for alias in command_hook.aliases:
+                if alias in self.commands and self.commands[alias] == command_hook:
+                    # we need to make sure that there wasn't a conflict, so we don't delete another plugin's command
+                    del self.commands[alias]
+
+        # unregister raw hooks
+        for raw_hook in plugin.raw_hooks:
+            if raw_hook.is_catch_all():
+                self.catch_all_triggers.remove(raw_hook)
+            else:
+                for trigger in raw_hook.triggers:
+                    assert trigger in self.raw_triggers  # this can't be not true
+                    self.raw_triggers[trigger].remove(raw_hook)
+                    if not self.raw_triggers[trigger]:  # if that was the last hook for this trigger
+                        del self.raw_triggers[trigger]
+
+        # unregister events
+        for event_hook in plugin.events:
+            for event_type in event_hook.types:
+                assert event_type in self.event_type_hooks  # this can't be not true
+                self.event_type_hooks[event_type].remove(event_hook)
+                if not self.event_type_hooks[event_type]:  # if that was the last hook for this event type
+                    del self.event_type_hooks[event_type]
+
+        # unregister regexps
+        for regex_hook in plugin.regexes:
+            for regex_match in regex_hook.regexes:
+                self.regex_hooks.remove((regex_match, regex_hook))
+
+        # unregister sieves
+        for sieve_hook in plugin.sieves:
+            self.sieves.remove(sieve_hook)
+
+        # unregister databases
+        plugin.unregister_tables(self.bot)
+
+        # remove last reference to plugin
+        del self.plugins[plugin.file_name]
+
+        if self.bot.config.get("logging", {}).get("show_plugin_loading", True):
+            logger.info("Unloaded all plugins from {}".format(plugin.title))
+
+        return True
+
+    def _log_hook(self, hook):
+        """
+        Logs registering a given hook
+
+        :type hook: Hook
+        """
+        if self.bot.config.get("logging", {}).get("show_plugin_loading", True):
+            logger.info("Loaded {}".format(hook))
+            logger.debug("Loaded {}".format(repr(hook)))
+
+    def _prepare_parameters(self, hook, event):
+        """
+        Prepares arguments for the given hook
+
+        :type hook: cloudbot.pluginmanager.Hook
+        :type event: cloudbot.events.BaseEvent
+        :rtype: list
+        """
+        parameters = []
+        for required_arg in hook.required_args:
+            if hasattr(event, required_arg):
+                value = getattr(event, required_arg)
+                parameters.append(value)
+            else:
+                logger.error("Plugin {} asked for invalid argument '{}', cancelling execution!"
+                             .format(hook.description, required_arg))
+                logger.debug("Valid arguments are: {} ({})".format(dir(event), event))
+                return None
+        return parameters
+
+    def _execute_hook_threaded(self, hook, event):
+        """
+        :type hook: Hook
+        :type event: cloudbot.events.BaseEvent
+        """
+        event.prepare_threaded()
+
+        parameters = self._prepare_parameters(hook, event)
+        if parameters is None:
+            return None
+
+        try:
+            return hook.function(*parameters)
+        finally:
+            event.close_threaded()
+
+    @asyncio.coroutine
+    def _execute_hook_sync(self, hook, event):
+        """
+        :type hook: Hook
+        :type event: cloudbot.events.BaseEvent
+        """
+        yield from event.prepare()
+
+        parameters = self._prepare_parameters(hook, event)
+        if parameters is None:
+            return None
+
+        try:
+            return (yield from hook.function(*parameters))
+        finally:
+            yield from event.close()
+
+    @asyncio.coroutine
+    def _execute_hook(self, hook, event):
+        """
+        Runs the specific hook with the given bot and event.
+
+        Returns False if the hook errored, True otherwise.
+
+        :type hook: cloudbot.pluginmanager.Hook
+        :type event: cloudbot.events.BaseEvent
+        :rtype: bool
+        """
+        try:
+            # _internal_run_threaded and _internal_run_coroutine prepare the database, and run the hook.
+            # _internal_run_* will prepare parameters and the database session, but won't do any error catching.
+            if hook.threaded:
+                out = yield from self.bot.loop.run_in_executor(None, self._execute_hook_threaded, hook, event)
+            else:
+                out = yield from self._execute_hook_sync(hook, event)
+        except Exception:
+            logger.exception("Error in hook {}".format(hook.description))
+            return False
+
+        if out is not None:
+            # if there are multiple items in the response, return them on multiple lines
+            if isinstance(out, (list, tuple)):
+                event.reply(out[0])
+                for line in out[1:]:
+                    event.message(line)
+            else:
+                event.reply(str(out))
+        return True
+
+    @asyncio.coroutine
+    def _sieve(self, sieve, event, hook):
+        """
+        :type sieve: cloudbot.pluginmanager.Hook
+        :type event: cloudbot.events.BaseEvent
+        :type hook: cloudbot.pluginmanager.Hook
+        :rtype: cloudbot.events.BaseEvent
+        """
+        try:
+            if sieve.threaded:
+                result = yield from self.bot.loop.run_in_executor(None, sieve.function, self.bot, event, hook)
+            else:
+                result = yield from sieve.function(self.bot, event, hook)
+        except Exception:
+            logger.exception("Error running sieve {} on {}:".format(sieve.description, hook.description))
+            return None
+        else:
+            return result
+
+    @asyncio.coroutine
+    def launch(self, hook, event):
+        """
+        Dispatch a given event to a given hook using a given bot object.
+
+        Returns False if the hook didn't run successfully, and True if it ran successfully.
+
+        :type event: cloudbot.events.BaseEvent | cloudbot.events.CommandEvent
+        :type hook: cloudbot.pluginmanager.Hook | cloudbot.pluginmanager.CommandHook
+        :rtype: bool
+        """
+        if hook.type != "onload":  # we don't need sieves on onload hooks.
+            for sieve in self.bot.plugin_manager.sieves:
+                event = yield from self._sieve(sieve, event, hook)
+                if event is None:
+                    return False
+
+        if hook.type == "command" and hook.auto_help and not event.text and hook.doc is not None:
+            event.notice_doc()
+            return False
+
+        if hook.single_thread:
+            # There should only be one running instance of this hook, so let's wait for the last event to be processed
+            # before starting this one.
+
+            key = (hook.plugin.title, hook.function_name)
+            if key in self._hook_waiting_queues:
+                queue = self._hook_waiting_queues[key]
+                if queue is None:
+                    # there's a hook running, but the queue hasn't been created yet, since there's only one hook
+                    queue = asyncio.Queue()
+                    self._hook_waiting_queues[key] = queue
+                assert isinstance(queue, asyncio.Queue)
+                # create a future to represent this task
+                future = asyncio.Future()
+                queue.put_nowait(future)
+                # wait until the last task is completed
+                yield from future
+            else:
+                # set to None to signify that this hook is running, but there's no need to create a full queue
+                # in case there are no more hooks that will wait
+                self._hook_waiting_queues[key] = None
+
+            # Run the plugin with the message, and wait for it to finish
+            result = yield from self._execute_hook(hook, event)
+
+            queue = self._hook_waiting_queues[key]
+            if queue is None or queue.empty():
+                # We're the last task in the queue, we can delete it now.
+                del self._hook_waiting_queues[key]
+            else:
+                # set the result for the next task's future, so they can execute
+                next_future = yield from queue.get()
+                next_future.set_result(None)
+        else:
+            # Run the plugin with the message, and wait for it to finish
+            result = yield from self._execute_hook(hook, event)
+
+        # Return the result
+        return result
+
+
+class Plugin:
+    """
+    Each Plugin represents a plugin file, and contains loaded hooks.
+
+    :type file_path: str
+    :type file_name: str
+    :type title: str
+    :type commands: list[CommandHook]
+    :type regexes: list[RegexHook]
+    :type raw_hooks: list[RawHook]
+    :type sieves: list[SieveHook]
+    :type events: list[EventHook]
+    :type tables: list[sqlalchemy.Table]
+    """
+
+    def __init__(self, filepath, filename, title, code):
+        """
+        :type filepath: str
+        :type filename: str
+        :type code: object
+        """
+        self.file_path = filepath
+        self.file_name = filename
+        self.title = title
+        self.commands, self.regexes, self.raw_hooks, self.sieves, self.events, self.run_on_load = find_hooks(self, code)
+        # we need to find tables for each plugin so that they can be unloaded from the global metadata when the
+        # plugin is reloaded
+        self.tables = find_tables(code)
+
+    @asyncio.coroutine
+    def create_tables(self, bot):
+        """
+        Creates all sqlalchemy Tables that are registered in this plugin
+
+        :type bot: cloudbot.bot.CloudBot
+        """
+        if self.tables:
+            # if there are any tables
+
+            logger.info("Registering tables for {}".format(self.title))
+
+            for table in self.tables:
+                if not (yield from bot.loop.run_in_executor(None, table.exists, bot.db_engine)):
+                    yield from bot.loop.run_in_executor(None, table.create, bot.db_engine)
+
+    def unregister_tables(self, bot):
+        """
+        Unregisters all sqlalchemy Tables registered to the global metadata by this plugin
+        :type bot: cloudbot.bot.CloudBot
+        """
+        if self.tables:
+            # if there are any tables
+            logger.info("Unregistering tables for {}".format(self.title))
+
+            for table in self.tables:
+                bot.db_metadata.remove(table)
+
+
+class Hook:
+    """
+    Each hook is specific to one function. This class is never used by itself, rather extended.
+
+    :type type; str
+    :type plugin: Plugin
+    :type function: callable
+    :type function_name: str
+    :type required_args: list[str]
+    :type threaded: bool
+    :type ignore_bots: bool
+    :type permissions: list[str]
+    :type single_thread: bool
+    """
+
+    def __init__(self, _type, plugin, func_hook):
+        """
+        :type _type: str
+        :type plugin: Plugin
+        :type func_hook: hook._Hook
+        """
+        self.type = _type
+        self.plugin = plugin
+        self.function = func_hook.function
+        self.function_name = self.function.__name__
+
+        self.required_args = inspect.getargspec(self.function)[0]
+        if self.required_args is None:
+            self.required_args = []
+
+        if asyncio.iscoroutine(self.function) or asyncio.iscoroutinefunction(self.function):
+            self.threaded = False
+        else:
+            self.threaded = True
+
+        self.ignore_bots = func_hook.kwargs.pop("ignorebots", False)
+        self.permissions = func_hook.kwargs.pop("permissions", [])
+        self.single_thread = func_hook.kwargs.pop("singlethread", False)
+
+        if func_hook.kwargs:
+            # we should have popped all the args, so warn if there are any left
+            logger.warning("Ignoring extra args {} from {}".format(func_hook.kwargs, self.description))
+
+    @property
+    def description(self):
+        return "{}:{}".format(self.plugin.title, self.function_name)
+
+    def __repr__(self):
+        return "type: {}, plugin: {}, ignore_bots: {}, permissions: {}, single_thread: {}, threaded: {}".format(
+            self.type, self.plugin.title, self.ignore_bots, self.permissions, self.single_thread, self.threaded
+        )
+
+
+class CommandHook(Hook):
+    """
+    :type name: str
+    :type aliases: list[str]
+    :type doc: str
+    :type auto_help: bool
+    """
+
+    def __init__(self, plugin, cmd_hook):
+        """
+        :type plugin: Plugin
+        :type cmd_hook: cloudbot.util.hook._CommandHook
+        """
+        self.auto_help = cmd_hook.kwargs.pop("autohelp", True)
+
+        self.name = cmd_hook.main_alias
+        self.aliases = list(cmd_hook.aliases)  # turn the set into a list
+        self.aliases.remove(self.name)
+        self.aliases.insert(0, self.name)  # make sure the name, or 'main alias' is in position 0
+        self.doc = cmd_hook.doc
+
+        super().__init__("command", plugin, cmd_hook)
+
+    def __repr__(self):
+        return "Command[name: {}, aliases: {}, {}]".format(self.name, self.aliases[1:], Hook.__repr__(self))
+
+    def __str__(self):
+        return "command {} from {}".format("/".join(self.aliases), self.plugin.file_name)
+
+
+class RegexHook(Hook):
+    """
+    :type regexes: set[re.__Regex]
+    """
+
+    def __init__(self, plugin, regex_hook):
+        """
+        :type plugin: Plugin
+        :type regex_hook: cloudbot.util.hook._RegexHook
+        """
+        self.regexes = regex_hook.regexes
+
+        super().__init__("regex", plugin, regex_hook)
+
+    def __repr__(self):
+        return "Regex[regexes: [{}], {}]".format(", ".join(regex.pattern for regex in self.regexes),
+                                                 Hook.__repr__(self))
+
+    def __str__(self):
+        return "regex {} from {}".format(self.function_name, self.plugin.file_name)
+
+
+class RawHook(Hook):
+    """
+    :type triggers: set[str]
+    """
+
+    def __init__(self, plugin, irc_raw_hook):
+        """
+        :type plugin: Plugin
+        :type irc_raw_hook: cloudbot.util.hook._RawHook
+        """
+        super().__init__("irc_raw", plugin, irc_raw_hook)
+
+        self.triggers = irc_raw_hook.triggers
+
+    def is_catch_all(self):
+        return "*" in self.triggers
+
+    def __repr__(self):
+        return "Raw[triggers: {}, {}]".format(list(self.triggers), Hook.__repr__(self))
+
+    def __str__(self):
+        return "irc raw {} ({}) from {}".format(self.function_name, ",".join(self.triggers), self.plugin.file_name)
+
+
+class SieveHook(Hook):
+    def __init__(self, plugin, sieve_hook):
+        """
+        :type plugin: Plugin
+        :type sieve_hook: cloudbot.util.hook._SieveHook
+        """
+        # We don't want to thread sieves by default - this is retaining old behavior for compatibility
+        super().__init__("sieve", plugin, sieve_hook)
+
+    def __repr__(self):
+        return "Sieve[{}]".format(Hook.__repr__(self))
+
+    def __str__(self):
+        return "sieve {} from {}".format(self.function_name, self.plugin.file_name)
+
+
+class EventHook(Hook):
+    """
+    :type types: set[cloudbot.events.EventType]
+    """
+
+    def __init__(self, plugin, event_hook):
+        """
+        :type plugin: Plugin
+        :type event_hook: cloudbot.util.hook._EventHook
+        """
+        super().__init__("event", plugin, event_hook)
+
+        self.types = event_hook.types
+
+    def __repr__(self):
+        return "Event[types: {}, {}]".format(list(self.types), Hook.__repr__(self))
+
+    def __str__(self):
+        return "event {} ({}) from {}".format(self.function_name, ",".join(str(t) for t in self.types),
+                                              self.plugin.file_name)
+
+
+class OnloadHook(Hook):
+    def __init__(self, plugin, on_load_hook):
+        """
+        :type plugin: Plugin
+        :type on_load_hook: cloudbot.util.hook._OnLoadHook
+        """
+        super().__init__("onload", plugin, on_load_hook)
+
+    def __repr__(self):
+        return "Onload[{}]".format(Hook.__repr__(self))
+
+    def __str__(self):
+        return "onload {} from {}".format(self.function_name, self.plugin.file_name)
+
+
+_hook_name_to_plugin = {
+    "command": CommandHook,
+    "regex": RegexHook,
+    "irc_raw": RawHook,
+    "sieve": SieveHook,
+    "event": EventHook,
+    "onload": OnloadHook
+}
diff --git a/cloudbot/reloader.py b/cloudbot/reloader.py
index 44fdef9..49ef886 100644
--- a/cloudbot/reloader.py
+++ b/cloudbot/reloader.py
@@ -7,7 +7,7 @@ from watchdog.tricks import Trick
 class PluginReloader(object):
     def __init__(self, bot):
         """
-        :type bot: cloudbot.core.bot.CloudBot
+        :type bot: cloudbot.bot.CloudBot
         """
         self.observer = Observer()
         self.bot = bot
diff --git a/cloudbot/util/hook.py b/cloudbot/util/hook.py
deleted file mode 100644
index 43b4690..0000000
--- a/cloudbot/util/hook.py
+++ /dev/null
@@ -1,298 +0,0 @@
-import inspect
-import re
-import collections
-
-from cloudbot.event import EventType
-
-
-valid_command_re = re.compile(r"^\w+$")
-
-
-class _Hook():
-    """
-    :type function: function
-    :type type: str
-    :type kwargs: dict[str, unknown]
-    """
-
-    def __init__(self, function, _type):
-        """
-        :type function: function
-        :type _type: str
-        """
-        self.function = function
-        self.type = _type
-        self.kwargs = {}
-
-    def _add_hook(self, kwargs):
-        """
-        :type kwargs: dict[str, unknown]
-        """
-        # update kwargs, overwriting duplicates
-        self.kwargs.update(kwargs)
-
-
-class _CommandHook(_Hook):
-    """
-    :type main_alias: str
-    :type aliases: set[str]
-    """
-
-    def __init__(self, function):
-        """
-        :type function: function
-        """
-        _Hook.__init__(self, function, "command")
-        self.aliases = set()
-        self.main_alias = None
-
-        if function.__doc__:
-            self.doc = function.__doc__.split('\n', 1)[0]
-        else:
-            self.doc = None
-
-    def add_hook(self, alias_param, kwargs):
-        """
-        :type alias_param: list[str] | str
-        """
-        self._add_hook(kwargs)
-
-        if not alias_param:
-            alias_param = self.function.__name__
-        if isinstance(alias_param, str):
-            alias_param = [alias_param]
-        if not self.main_alias:
-            self.main_alias = alias_param[0]
-        for alias in alias_param:
-            if not valid_command_re.match(alias):
-                raise ValueError("Invalid command name {}".format(alias))
-        self.aliases.update(alias_param)
-
-
-class _RegexHook(_Hook):
-    """
-    :type regexes: list[re.__Regex]
-    """
-
-    def __init__(self, function):
-        """
-        :type function: function
-        """
-        _Hook.__init__(self, function, "regex")
-        self.regexes = []
-
-    def add_hook(self, regex_param, kwargs):
-        """
-        :type regex_param: Iterable[str | re.__Regex] | str | re.__Regex
-        :type kwargs: dict[str, unknown]
-        """
-        self._add_hook(kwargs)
-        # add all regex_parameters to valid regexes
-        if isinstance(regex_param, str):
-            # if the parameter is a string, compile and add
-            self.regexes.append(re.compile(regex_param))
-        elif hasattr(regex_param, "search"):
-            # if the parameter is an re.__Regex, just add it
-            # we only use regex.search anyways, so this is a good determiner
-            self.regexes.append(regex_param)
-        else:
-            assert isinstance(regex_param, collections.Iterable)
-            # if the parameter is a list, add each one
-            for re_to_match in regex_param:
-                if isinstance(re_to_match, str):
-                    re_to_match = re.compile(re_to_match)
-                else:
-                    # make sure that the param is either a compiled regex, or has a search attribute.
-                    assert hasattr(regex_param, "search")
-                self.regexes.append(re_to_match)
-
-
-class _RawHook(_Hook):
-    """
-    :type triggers: set[str]
-    """
-
-    def __init__(self, function):
-        """
-        :type function: function
-        """
-        _Hook.__init__(self, function, "irc_raw")
-        self.triggers = set()
-
-    def add_hook(self, trigger_param, kwargs):
-        """
-        :type trigger_param: list[str] | str
-        :type kwargs: dict[str, unknown]
-        """
-        self._add_hook(kwargs)
-
-        if isinstance(trigger_param, str):
-            self.triggers.add(trigger_param)
-        else:
-            # it's a list
-            self.triggers.update(trigger_param)
-
-
-class _EventHook(_Hook):
-    """
-    :type types: set[cloudbot.core.events.EventType]
-    """
-
-    def __init__(self, function):
-        """
-        :type function: function
-        """
-        _Hook.__init__(self, function, "event")
-        self.types = set()
-
-    def add_hook(self, trigger_param, kwargs):
-        """
-        :type trigger_param: cloudbot.core.events.EventType | list[cloudbot.core.events.EventType]
-        :type kwargs: dict[str, unknown]
-        """
-        self._add_hook(kwargs)
-
-        if isinstance(trigger_param, EventType):
-            self.types.add(trigger_param)
-        else:
-            # it's a list
-            self.types.update(trigger_param)
-
-
-def _add_hook(func, hook):
-    if not hasattr(func, "_cloudbot_hook"):
-        func._cloudbot_hook = {}
-    else:
-        assert hook.type not in func._cloudbot_hook  # in this case the hook should be using the add_hook method
-    func._cloudbot_hook[hook.type] = hook
-
-
-def _get_hook(func, hook_type):
-    if hasattr(func, "_cloudbot_hook") and hook_type in func._cloudbot_hook:
-        return func._cloudbot_hook[hook_type]
-
-    return None
-
-
-def command(*args, **kwargs):
-    """External command decorator. Can be used directly as a decorator, or with args to return a decorator.
-    :type param: str | list[str] | function
-    """
-
-    def _command_hook(func, alias_param=None):
-        hook = _get_hook(func, "command")
-        if hook is None:
-            hook = _CommandHook(func)
-            _add_hook(func, hook)
-
-        hook.add_hook(alias_param, kwargs)
-        return func
-
-    if len(args) == 1 and callable(args[0]):  # this decorator is being used directly
-        return _command_hook(args[0])
-    else:  # this decorator is being used indirectly, so return a decorator function
-        return lambda func: _command_hook(func, alias_param=args)
-
-
-def irc_raw(triggers_param, **kwargs):
-    """External raw decorator. Must be used as a function to return a decorator
-    :type triggers_param: str | list[str]
-    """
-
-    def _raw_hook(func):
-        hook = _get_hook(func, "irc_raw")
-        if hook is None:
-            hook = _RawHook(func)
-            _add_hook(func, hook)
-
-        hook.add_hook(triggers_param, kwargs)
-        return func
-
-    if callable(triggers_param):  # this decorator is being used directly, which isn't good
-        raise TypeError("@irc_raw() must be used as a function that returns a decorator")
-    else:  # this decorator is being used as a function, so return a decorator
-        return lambda func: _raw_hook(func)
-
-
-def event(types_param, **kwargs):
-    """External event decorator. Must be used as a function to return a decorator
-    :type types_param: cloudbot.core.events.EventType | list[cloudbot.core.events.EventType]
-    """
-
-    def _event_hook(func):
-        hook = _get_hook(func, "event")
-        if hook is None:
-            hook = _EventHook(func)
-            _add_hook(func, hook)
-
-        hook.add_hook(types_param, kwargs)
-        return func
-
-    if callable(types_param):  # this decorator is being used directly, which isn't good
-        raise TypeError("@irc_raw() must be used as a function that returns a decorator")
-    else:  # this decorator is being used as a function, so return a decorator
-        return lambda func: _event_hook(func)
-
-
-def regex(regex_param, **kwargs):
-    """External regex decorator. Must be used as a function to return a decorator.
-    :type regex_param: str | re.__Regex | list[str | re.__Regex]
-    :type flags: int
-    """
-
-    def _regex_hook(func):
-        hook = _get_hook(func, "regex")
-        if hook is None:
-            hook = _RegexHook(func)
-            _add_hook(func, hook)
-
-        hook.add_hook(regex_param, kwargs)
-        return func
-
-    if callable(regex_param):  # this decorator is being used directly, which isn't good
-        raise TypeError("@regex() hook must be used as a function that returns a decorator")
-    else:  # this decorator is being used as a function, so return a decorator
-        return lambda func: _regex_hook(func)
-
-
-def sieve(param=None, **kwargs):
-    """External sieve decorator. Can be used directly as a decorator, or with args to return a decorator
-    :type param: function | None
-    """
-
-    def _sieve_hook(func):
-        assert len(inspect.getargspec(func).args) == 3, \
-            "Sieve plugin has incorrect argument count. Needs params: bot, input, plugin"
-
-        hook = _get_hook(func, "sieve")
-        if hook is None:
-            hook = _Hook(func, "sieve")  # there's no need to have a specific SieveHook object
-            _add_hook(func, hook)
-
-        hook._add_hook(kwargs)
-        return func
-
-    if callable(param):
-        return _sieve_hook(param)
-    else:
-        return lambda func: _sieve_hook(func)
-
-
-def onload(param=None, **kwargs):
-    """External onload decorator. Can be used directly as a decorator, or with args to return a decorator
-    :type param: function | None
-    """
-
-    def _onload_hook(func):
-        hook = _get_hook(func, "onload")
-        if hook is None:
-            hook = _Hook(func, "onload")
-            _add_hook(func, hook)
-
-        hook._add_hook(kwargs)
-        return func
-
-    if callable(param):
-        return _onload_hook(param)
-    else:
-        return lambda func: _onload_hook(func)
diff --git a/plugins/admin.py b/plugins/admin.py
index def13a9..c36b572 100644
--- a/plugins/admin.py
+++ b/plugins/admin.py
@@ -8,7 +8,7 @@ from cloudbot import hook
 @hook.command("groups", "listgroups", "permgroups", permissions=["permissions_users"], autohelp=False)
 def get_permission_groups(conn):
     """- lists all valid groups
-    :type conn: cloudbot.core.connection.Client
+    :type conn: cloudbot.connection.Connection
     """
     return "Valid groups: {}".format(conn.permissions.get_groups())
 
@@ -18,7 +18,7 @@ def get_permission_groups(conn):
 def get_group_permissions(text, conn, notice):
     """<group> - lists permissions given to <group>
     :type text: str
-    :type conn: cloudbot.core.connection.Client
+    :type conn: cloudbot.connection.Connection
     """
     group = text.strip().lower()
     permission_manager = conn.permissions
@@ -37,7 +37,7 @@ def get_group_permissions(text, conn, notice):
 def get_group_users(text, conn, notice):
     """<group> - lists users in <group>
     :type text: str
-    :type conn: cloudbot.core.connection.Client
+    :type conn: cloudbot.connection.Connection
     """
     group = text.strip().lower()
     permission_manager = conn.permissions
@@ -56,7 +56,7 @@ def get_group_users(text, conn, notice):
 def get_user_permissions(text, conn, mask, has_permission, notice):
     """[user] - lists all permissions given to [user], or the caller if no user is specified
     :type text: str
-    :type conn: cloudbot.core.connection.Client
+    :type conn: cloudbot.connection.Connection
     :type mask: str
     """
     if text:
@@ -81,7 +81,7 @@ def get_user_permissions(text, conn, mask, has_permission, notice):
 def get_user_groups(text, conn, mask, has_permission, notice):
     """[user] - lists all permissions given to [user], or the caller if no user is specified
     :type text: str
-    :type conn: cloudbot.core.connection.Client
+    :type conn: cloudbot.connection.Connection
     :type mask: str
     """
     if text:
@@ -106,8 +106,8 @@ def get_user_groups(text, conn, mask, has_permission, notice):
 def remove_permission_user(text, bot, conn, notice, reply):
     """<user> [group] - removes <user> from [group], or from all groups if no group is specified
     :type text: str
-    :type bot: cloudbot.core.bot.CloudBot
-    :type conn: cloudbot.core.connection.Client
+    :type bot: cloudbot.bot.CloudBot
+    :type conn: cloudbot.connection.Connection
     """
     split = text.split()
     if len(split) > 2:
@@ -162,8 +162,8 @@ def remove_permission_user(text, bot, conn, notice, reply):
 def add_permissions_user(text, conn, bot, notice, reply):
     """<user> <group> - adds <user> to <group>
     :type text: str
-    :type conn: cloudbot.core.connection.Client
-    :type bot: cloudbot.core.bot.CloudBot
+    :type conn: cloudbot.connection.Connection
+    :type bot: cloudbot.bot.CloudBot
     """
     split = text.split()
     if len(split) > 2:
@@ -204,7 +204,7 @@ def add_permissions_user(text, conn, bot, notice, reply):
 def stop(text, bot):
     """[reason] - stops me with [reason] as its quit message.
     :type text: str
-    :type bot: cloudbot.core.bot.CloudBot
+    :type bot: cloudbot.bot.CloudBot
     """
     if text:
         yield from bot.stop(reason=text)
@@ -216,7 +216,7 @@ def stop(text, bot):
 def restart(text, bot):
     """[reason] - restarts me with [reason] as its quit message.
     :type text: str
-    :type bot: cloudbot.core.bot.CloudBot
+    :type bot: cloudbot.bot.CloudBot
     """
     if text:
         yield from bot.restart(reason=text)
@@ -229,7 +229,7 @@ def restart(text, bot):
 def join(text, conn, notice):
     """<channel> - joins <channel>
     :type text: str
-    :type conn: cloudbot.core.connection.Client
+    :type conn: cloudbot.connection.Connection
     """
     for target in text.split():
         if not target.startswith("#"):
@@ -243,7 +243,7 @@ def join(text, conn, notice):
 def part(text, conn, chan, notice):
     """[#channel] - parts [#channel], or the caller's channel if no channel is specified
     :type text: str
-    :type conn: cloudbot.core.connection.Client
+    :type conn: cloudbot.connection.Connection
     :type chan: str
     """
     if text:
@@ -262,7 +262,7 @@ def part(text, conn, chan, notice):
 def cycle(text, conn, chan, notice):
     """[#channel] - cycles [#channel], or the caller's channel if no channel is specified
     :type text: str
-    :type conn: cloudbot.core.connection.Client
+    :type conn: cloudbot.connection.Connection
     :type chan: str
     """
     if text:
@@ -282,7 +282,7 @@ def cycle(text, conn, chan, notice):
 def nick(text, conn, notice):
     """<nick> - changes my nickname to <nick>
     :type text: str
-    :type conn: cloudbot.core.connection.Client
+    :type conn: cloudbot.connection.Connection
     """
     if not re.match("^[a-z0-9_|.-\]\[]*$", text.lower()):
         notice("Invalid username '{}'".format(text))
@@ -296,7 +296,7 @@ def nick(text, conn, notice):
 def raw(text, conn, notice):
     """<command> - sends <command> as a raw IRC command
     :type text: str
-    :type conn: cloudbot.core.connection.Client
+    :type conn: cloudbot.connection.Connection
     """
     notice("Raw command sent.")
     conn.send(text)
@@ -307,7 +307,7 @@ def raw(text, conn, notice):
 def say(text, conn, chan):
     """[#channel] <message> - says <message> to [#channel], or to the caller's channel if no channel is specified
     :type text: str
-    :type conn: cloudbot.core.connection.Client
+    :type conn: cloudbot.connection.Connection
     :type chan: str
     """
     text = text.strip()
@@ -326,7 +326,7 @@ def say(text, conn, chan):
 def message(text, conn):
     """<name> <message> - says <message> to <name>
     :type text: str
-    :type conn: cloudbot.core.connection.Client
+    :type conn: cloudbot.connection.Connection
     """
     split = text.split(None, 1)
     channel = split[0]
@@ -339,7 +339,7 @@ def message(text, conn):
 def me(text, conn, chan):
     """[#channel] <action> - acts out <action> in a [#channel], or in the current channel of none is specified
     :type text: str
-    :type conn: cloudbot.core.connection.Client
+    :type conn: cloudbot.connection.Connection
     :type chan: str
     """
     text = text.strip()
diff --git a/plugins/attacks.py b/plugins/attacks.py
index 5e8831a..cacca55 100644
--- a/plugins/attacks.py
+++ b/plugins/attacks.py
@@ -12,7 +12,7 @@ from cloudbot.util import textgen
 @hook.onload()
 def load_attacks(bot):
     """
-    :type bot: cloudbot.core.bot.CloudBot
+    :type bot: cloudbot.bot.CloudBot
     """
     global larts, insults, flirts, kills
 
@@ -31,7 +31,7 @@ def load_attacks(bot):
 
 def is_self(conn, target):
     """
-    :type conn: cloudbot.core.connection.Client
+    :type conn: cloudbot.connection.Connection
     :type target: str
     """
     if re.search("(^..?.?.?self|{})".format(re.escape(conn.nick.lower())), target.lower()):
@@ -45,7 +45,7 @@ def is_self(conn, target):
 def lart(text, conn, nick, notice, action):
     """<user> - LARTs <user>
     :type text: str
-    :type conn: cloudbot.core.connection.Client
+    :type conn: cloudbot.connection.Connection
     :type nick: str
     """
     target = text.strip()
@@ -69,7 +69,7 @@ def lart(text, conn, nick, notice, action):
 def insult(text, conn, nick, notice, message):
     """<user> - insults <user>
     :type text: str
-    :type conn: cloudbot.core.connection.Client
+    :type conn: cloudbot.connection.Connection
     :type nick: str
     """
     target = text.strip()
@@ -90,7 +90,7 @@ def insult(text, conn, nick, notice, message):
 def flirt(text, conn, nick, notice, message):
     """<user> - flirts with <user>
     :type text: str
-    :type conn: cloudbot.core.connection.Client
+    :type conn: cloudbot.connection.Connection
     :type nick: str
     """
     target = text.strip()
@@ -111,7 +111,7 @@ def flirt(text, conn, nick, notice, message):
 def kill(text, conn, nick, notice, action):
     """<user> - kills <user>
     :type text: str
-    :type conn: cloudbot.core.connection.Client
+    :type conn: cloudbot.connection.Connection
     :type nick: str
     """
     target = text.strip()
diff --git a/plugins/core_misc.py b/plugins/core_misc.py
index af1eeb4..ba9f23e 100644
--- a/plugins/core_misc.py
+++ b/plugins/core_misc.py
@@ -12,7 +12,7 @@ socket.setdefaulttimeout(10)
 def invite(irc_paramlist, conn):
     """
     :type irc_paramlist: list[str]
-    :type conn: cloudbot.core.connection.Client
+    :type conn: cloudbot.connection.Connection
     """
     invite_join = conn.config.get('invite_join', True)
     if invite_join:
@@ -24,8 +24,8 @@ def invite(irc_paramlist, conn):
 @hook.irc_raw('004')
 def onjoin(conn, bot):
     """
-    :type conn: cloudbot.core.connection.IRCClient
-    :type bot: cloudbot.core.bot.CloudBot
+    :type conn: cloudbot.connection.IrcConnection
+    :type bot: cloudbot.bot.CloudBot
     """
     bot.logger.info("ONJOIN hook triggered.")
     nickserv = conn.config.get('nickserv')
@@ -64,7 +64,7 @@ def onjoin(conn, bot):
 @hook.irc_raw('004')
 def keep_alive(conn):
     """
-    :type conn: cloudbot.core.connection.IRCClient
+    :type conn: cloudbot.connection.IrcConnection
     """
     keepalive = conn.config.get('keep_alive', False)
     if keepalive:
diff --git a/plugins/core_sieve.py b/plugins/core_sieve.py
index df19e51..c2e1f6c 100644
--- a/plugins/core_sieve.py
+++ b/plugins/core_sieve.py
@@ -1,5 +1,6 @@
 import asyncio
-from cloudbot import bucket, hook
+from cloudbot import hook
+from cloudbot.util import bucket
 
 TOKENS = 10
 RESTORE_RATE = 2
@@ -12,9 +13,9 @@ buckets = {}
 @hook.sieve
 def sieve_suite(bot, event, _hook):
     """
-    :type bot: cloudbot.core.bot.CloudBot
-    :type event: cloudbot.core.events.Event
-    :type _hook: cloudbot.core.pluginmanager.Hook
+    :type bot: cloudbot.bot.CloudBot
+    :type event: cloudbot.events.BaseEvent
+    :type _hook: cloudbot.pluginmanager.Hook
     """
     conn = event.conn
     # check ignore bots
diff --git a/plugins/core_tracker.py b/plugins/core_tracker.py
index d1131f4..2c68aaf 100644
--- a/plugins/core_tracker.py
+++ b/plugins/core_tracker.py
@@ -15,7 +15,7 @@ nick_re = re.compile(":(.+?)!")
 @hook.irc_raw("KICK")
 def on_kick(conn, chan, nick):
     """
-    :type conn: cloudbot.core.connection.Client
+    :type conn: cloudbot.connection.Connection
     :type chan: str
     :type nick: str
     """
@@ -32,7 +32,7 @@ def on_kick(conn, chan, nick):
 def on_nick(irc_paramlist, conn, irc_raw):
     """
     :type irc_paramlist: list[str]
-    :type conn: cloudbot.core.connection.Client
+    :type conn: cloudbot.connection.Connection
     :type irc_raw: str
     """
     old_nick = nick_re.search(irc_raw).group(1)
@@ -48,7 +48,7 @@ def on_nick(irc_paramlist, conn, irc_raw):
 @hook.irc_raw("JOIN")
 def on_join(conn, chan, nick):
     """
-    :type conn: cloudbot.core.connection.Client
+    :type conn: cloudbot.connection.Connection
     :type chan: str
     :type nick: str
     """
diff --git a/plugins/correction.py b/plugins/correction.py
index c0d7aae..674f4fe 100644
--- a/plugins/correction.py
+++ b/plugins/correction.py
@@ -11,7 +11,7 @@ correction_re = re.compile(r"^[sS]/([^/]*)/([^/]*)(/.*)?\s*$")
 def correction(match, conn, chan, message):
     """
     :type match: re.__Match
-    :type conn: cloudbot.core.connection.Client
+    :type conn: cloudbot.connection.Connection
     :type chan: str
     """
     print(match.groups())
diff --git a/plugins/dbtest.py b/plugins/dbtest.py
index 53bd0da..703241e 100644
--- a/plugins/dbtest.py
+++ b/plugins/dbtest.py
@@ -1,6 +1,7 @@
 from sqlalchemy import Table, Column, String
 
-from cloudbot import hook, botvars
+from cloudbot import hook
+from cloudbot.util import botvars
 
 users = Table(
     'user_table', botvars.metadata,
diff --git a/plugins/domainr.py b/plugins/domainr.py
index 1e0e3d6..d800677 100644
--- a/plugins/domainr.py
+++ b/plugins/domainr.py
@@ -1,4 +1,5 @@
-from cloudbot import hook, http
+from cloudbot import hook
+from cloudbot.util import http
 
 formats = {
     "taken": "\x034{domain}\x0f{path}",
diff --git a/plugins/drama.py b/plugins/drama.py
index 34c1b47..d359a5f 100644
--- a/plugins/drama.py
+++ b/plugins/drama.py
@@ -5,7 +5,8 @@ from lxml import html
 
 import requests
 
-from cloudbot import hook, formatting
+from cloudbot import hook
+from cloudbot.util import formatting
 
 api_url = "http://encyclopediadramatica.se/api.php"
 ed_url = "http://encyclopediadramatica.se/"
diff --git a/plugins/eightball.py b/plugins/eightball.py
index 91687b5..72f258d 100644
--- a/plugins/eightball.py
+++ b/plugins/eightball.py
@@ -2,7 +2,8 @@ import os
 import asyncio
 import random
 
-from cloudbot import hook, formatting
+from cloudbot import hook
+from cloudbot.util import formatting
 
 color_codes = {
     "<r>": "\x02\x0305",
diff --git a/plugins/encrypt.py b/plugins/encrypt.py
index 0acd546..22966af 100644
--- a/plugins/encrypt.py
+++ b/plugins/encrypt.py
@@ -56,7 +56,7 @@ def create_db(db):
 
 def get_salt(bot):
     """generate an encryption salt if none exists, then returns the salt
-    :type bot: cloudbot.core.bot.CloudBot
+    :type bot: cloudbot.bot.CloudBot
     """
     if not bot.config.get("random_salt", False):
         bot.config["random_salt"] = hashlib.md5(os.urandom(16)).hexdigest()
@@ -69,7 +69,7 @@ def get_salt(bot):
 def encrypt(text, bot, db, notice):
     """<pass> <string> - encrypts <string> with <pass>. (<string> can only be decrypted using this bot)
     :type text: str
-    :type bot: cloudbot.core.bot.CloudBot
+    :type bot: cloudbot.bot.CloudBot
     :type db: sqlalchemy.orm.session.Session
     """
 
@@ -107,7 +107,7 @@ def encrypt(text, bot, db, notice):
 @hook.command
 def decrypt(text, bot, db, notice):
     """<pass> <string> - decrypts <string> with <pass>. (can only decrypt strings encrypted on this bot)
-    :type bot: cloudbot.core.bot.CloudBot
+    :type bot: cloudbot.bot.CloudBot
     :type db: sqlalchemy.orm.session.Session
     """
 
diff --git a/plugins/fact.py b/plugins/fact.py
index 4b2386f..5228391 100644
--- a/plugins/fact.py
+++ b/plugins/fact.py
@@ -1,4 +1,5 @@
-from cloudbot import hook, http, web
+from cloudbot import hook
+from cloudbot.util import http, web
 
 
 @hook.command(autohelp=False)
diff --git a/plugins/factoids.py b/plugins/factoids.py
index efde4c5..7de5ae1 100644
--- a/plugins/factoids.py
+++ b/plugins/factoids.py
@@ -7,7 +7,8 @@ import requests
 
 from sqlalchemy import Table, Column, String
 
-from cloudbot import botvars, hook, formatting, web
+from cloudbot import hook
+from cloudbot.util import botvars, formatting, web
 
 re_lineends = re.compile(r'[\r\n]*')
 
diff --git a/plugins/fishbans.py b/plugins/fishbans.py
index 8f5cdb8..e365bd1 100644
--- a/plugins/fishbans.py
+++ b/plugins/fishbans.py
@@ -4,7 +4,8 @@ import asyncio
 import requests
 import requests.exceptions
 
-from cloudbot import hook, formatting
+from cloudbot import hook
+from cloudbot.util import formatting
 
 
 api_url = "http://api.fishbans.com/stats/{}/"
diff --git a/plugins/geoip.py b/plugins/geoip.py
index cb8c7da..61a695e 100644
--- a/plugins/geoip.py
+++ b/plugins/geoip.py
@@ -5,7 +5,8 @@ from io import BytesIO
 
 import pygeoip
 
-from cloudbot import hook, http
+from cloudbot import hook
+from cloudbot.util import http
 
 
 @hook.onload()
diff --git a/plugins/github.py b/plugins/github.py
index 5887a44..add37b7 100644
--- a/plugins/github.py
+++ b/plugins/github.py
@@ -1,6 +1,7 @@
 import requests
 
-from cloudbot import hook, web, formatting
+from cloudbot import hook
+from cloudbot.util import web, formatting
 
 shortcuts = {
     'cloudbot': 'CloudBotIRC/Refresh'
diff --git a/plugins/google.py b/plugins/google.py
index 09dcf8e..036c523 100644
--- a/plugins/google.py
+++ b/plugins/google.py
@@ -1,6 +1,7 @@
 import random
 
-from cloudbot import hook, http, formatting
+from cloudbot import hook
+from cloudbot.util import http, formatting
 
 
 def api_get(kind, query):
diff --git a/plugins/google_translate.py b/plugins/google_translate.py
index e2510e9..0e33447 100644
--- a/plugins/google_translate.py
+++ b/plugins/google_translate.py
@@ -6,7 +6,8 @@ Since December 1, 2011, the Google Translate API is a paid service only.
 import re
 import html.entities
 
-from cloudbot import hook, http
+from cloudbot import hook
+from cloudbot.util import http
 
 max_length = 100
 
diff --git a/plugins/help.py b/plugins/help.py
index 245abaf..72b51dd 100644
--- a/plugins/help.py
+++ b/plugins/help.py
@@ -10,8 +10,8 @@ from cloudbot import hook
 def help_command(text, conn, bot, notice, has_permission):
     """[command] - gives help for [command], or lists all available commands if no command is specified
     :type text: str
-    :type conn: cloudbot.core.connection.Client
-    :type bot: cloudbot.core.bot.CloudBot
+    :type conn: cloudbot.connection.Connection
+    :type bot: cloudbot.bot.CloudBot
     """
     if text:
         searching_for = text.lower().strip()
diff --git a/plugins/history.py b/plugins/history.py
index b7622b1..7408c5a 100644
--- a/plugins/history.py
+++ b/plugins/history.py
@@ -3,9 +3,9 @@ import time
 import asyncio
 import re
 
-from cloudbot import hook, timesince
-from cloudbot.event import EventType
-
+from cloudbot import hook
+from cloudbot.util import timesince
+from cloudbot.events import EventType
 
 db_ready = []
 
@@ -23,9 +23,9 @@ def db_init(db, conn_name):
 
 def track_seen(event, db, conn):
     """ Tracks messages for the .seen command
-    :type event: cloudbot.core.events.Event
+    :type event: cloudbot.events.BaseEvent
     :type db: sqlalchemy.orm.Session
-    :type conn: cloudbot.core.connection.Client
+    :type conn: cloudbot.connection.Connection
     """
     db_init(db, conn)
     # keep private messages private
@@ -37,8 +37,8 @@ def track_seen(event, db, conn):
 
 def track_history(event, message_time, conn):
     """
-    :type event: cloudbot.core.events.Event
-    :type conn: cloudbot.core.connection.Client
+    :type event: cloudbot.events.BaseEvent
+    :type conn: cloudbot.connection.Connection
     """
     try:
         history = conn.history[event.chan]
@@ -54,8 +54,8 @@ def track_history(event, message_time, conn):
 def chat_tracker(event, db, conn):
     """
     :type db: sqlalchemy.orm.Session
-    :type event: cloudbot.core.events.Event
-    :type conn: cloudbot.core.connection.Client
+    :type event: cloudbot.events.BaseEvent
+    :type conn: cloudbot.connection.Connection
     """
     message_time = time.time()
     track_seen(event, db, conn)
@@ -66,8 +66,8 @@ def chat_tracker(event, db, conn):
 @hook.command(autohelp=False)
 def resethistory(event, conn):
     """- resets chat history for the current channel
-    :type event: cloudbot.core.events.Event
-    :type conn: cloudbot.core.connection.Client
+    :type event: cloudbot.events.BaseEvent
+    :type conn: cloudbot.connection.Connection
     """
     try:
         conn.history[event.chan].clear()
@@ -81,8 +81,8 @@ def resethistory(event, conn):
 def seen(text, nick, chan, db, event, conn):
     """<nick> <channel> - tells when a nickname was last in active in one of my channels
     :type db: sqlalchemy.orm.Session
-    :type event: cloudbot.core.events.Event
-    :type conn: cloudbot.core.connection.Client
+    :type event: cloudbot.events.BaseEvent
+    :type conn: cloudbot.connection.Connection
     """
 
     if event.conn.nick.lower() == text.lower():
diff --git a/plugins/horoscope.py b/plugins/horoscope.py
index 1eff2b9..9af1630 100644
--- a/plugins/horoscope.py
+++ b/plugins/horoscope.py
@@ -1,6 +1,7 @@
 # Plugin by Infinity - <https://github.com/infinitylabs/UguuBot>
 
-from cloudbot import hook, http, formatting
+from cloudbot import hook
+from cloudbot.util import http, formatting
 
 
 @hook.onload()
diff --git a/plugins/hulu.py b/plugins/hulu.py
index 211252f..26dcc11 100644
--- a/plugins/hulu.py
+++ b/plugins/hulu.py
@@ -1,7 +1,8 @@
 import re
 from urllib.parse import urlencode
 
-from cloudbot import hook, http, timeformat
+from cloudbot import hook
+from cloudbot.util import http, timeformat
 
 hulu_re = re.compile(r'(.*://)(www.hulu.com|hulu.com)(.*)', re.I)
 
diff --git a/plugins/ignore.py b/plugins/ignore.py
index f1fd713..dbd422b 100644
--- a/plugins/ignore.py
+++ b/plugins/ignore.py
@@ -2,7 +2,7 @@ import asyncio
 from fnmatch import fnmatch
 
 from cloudbot import hook
-from cloudbot.event import EventType
+from cloudbot.events import EventType
 
 
 @hook.onload
@@ -27,9 +27,9 @@ def ensure_ignored(bot):
 @hook.sieve()
 def ignore_sieve(bot, event, _hook):
     """ blocks events from ignored channels/hosts
-    :type bot: cloudbot.core.bot.CloudBot
-    :type event: cloudbot.core.events.Event
-    :type _hook: cloudbot.core.pluginmanager.Hook
+    :type bot: cloudbot.bot.CloudBot
+    :type event: cloudbot.events.BaseEvent
+    :type _hook: cloudbot.pluginmanager.Hook
     """
     # don't block event hooks
     if _hook.type == "event":
diff --git a/plugins/imdb.py b/plugins/imdb.py
index 2940266..aa329ee 100644
--- a/plugins/imdb.py
+++ b/plugins/imdb.py
@@ -2,7 +2,8 @@
 
 import re
 
-from cloudbot import hook, http, formatting
+from cloudbot import hook
+from cloudbot.util import http, formatting
 
 id_re = re.compile("tt\d+")
 imdb_re = re.compile(r'(.*:)//(imdb.com|www.imdb.com)(:[0-9]+)?(.*)', re.I)
diff --git a/plugins/imgur.py b/plugins/imgur.py
index f951e47..492a789 100644
--- a/plugins/imgur.py
+++ b/plugins/imgur.py
@@ -1,7 +1,8 @@
 import re
 import random
 
-from cloudbot import hook, http, web
+from cloudbot import hook
+from cloudbot.util import http, web
 
 base_url = "http://reddit.com/r/{}/.json"
 imgur_re = re.compile(r'http://(?:i\.)?imgur\.com/(a/)?(\w+\b(?!/))\.?\w?')
diff --git a/plugins/kernel.py b/plugins/kernel.py
index ae8434d..56bd030 100644
--- a/plugins/kernel.py
+++ b/plugins/kernel.py
@@ -1,6 +1,7 @@
 import re
 
-from cloudbot import hook, http
+from cloudbot import hook
+from cloudbot.util import http
 
 
 @hook.command(autohelp=False)
diff --git a/plugins/lastfm.py b/plugins/lastfm.py
index 819264a..4f12bc3 100644
--- a/plugins/lastfm.py
+++ b/plugins/lastfm.py
@@ -1,6 +1,7 @@
 from datetime import datetime
 
-from cloudbot import hook, http, timesince
+from cloudbot import hook
+from cloudbot.util import http, timesince
 
 api_url = "http://ws.audioscrobbler.com/2.0/?format=json"
 
diff --git a/plugins/lmgtfy.py b/plugins/lmgtfy.py
index 60c1664..c97c383 100644
--- a/plugins/lmgtfy.py
+++ b/plugins/lmgtfy.py
@@ -1,4 +1,5 @@
-from cloudbot import hook, web, http
+from cloudbot import hook
+from cloudbot.util import web, http
 
 
 @hook.command("lmgtfy", "gfy")
diff --git a/plugins/log.py b/plugins/log.py
index fb4faea..6f61337 100644
--- a/plugins/log.py
+++ b/plugins/log.py
@@ -5,25 +5,7 @@ import time
 
 import cloudbot
 from cloudbot import hook
-from cloudbot.event import EventType
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
+from cloudbot.events import EventType
 
 
 
@@ -66,7 +48,7 @@ ctcp_unknown_with_message = ("[{server}:{channel}] {nick} [{user}@{host}] "
 def format_event(event):
     """
     Format an event
-    :type event: cloudbot.core.events.Event
+    :type event: cloudbot.events.BaseEvent
     :rtype: str
     """
 
@@ -220,7 +202,7 @@ def get_raw_log_stream(server):
 @hook.irc_raw("*", singlethread=True)
 def log_raw(event):
     """
-    :type event: cloudbot.core.events.Event
+    :type event: cloudbot.events.BaseEvent
     """
     logging_config = event.bot.config.get("logging", {})
     if not logging_config.get("raw_file_log", False):
@@ -232,7 +214,7 @@ def log_raw(event):
 @hook.irc_raw("*", singlethread=True)
 def log(event):
     """
-    :type event: cloudbot.core.events.Event
+    :type event: cloudbot.events.BaseEvent
     """
     text = format_event(event)
 
@@ -246,8 +228,8 @@ def log(event):
 @hook.irc_raw("*")
 def console_log(bot, event):
     """
-    :type bot: cloudbot.core.bot.CloudBot
-    :type event: cloudbot.core.events.Event
+    :type bot: cloudbot.bot.CloudBot
+    :type event: cloudbot.events.BaseEvent
     """
     text = format_event(event)
     if text is not None:
diff --git a/plugins/lyrics.py b/plugins/lyrics.py
index c2951d6..d35372e 100644
--- a/plugins/lyrics.py
+++ b/plugins/lyrics.py
@@ -1,4 +1,5 @@
-from cloudbot import hook, http, web
+from cloudbot import hook
+from cloudbot.util import http, web
 
 url = "http://search.azlyrics.com/search.php?q="
 
diff --git a/plugins/metacritic.py b/plugins/metacritic.py
index 53e77d4..1301842 100644
--- a/plugins/metacritic.py
+++ b/plugins/metacritic.py
@@ -3,7 +3,8 @@
 import re
 from urllib.error import HTTPError
 
-from cloudbot import hook, http
+from cloudbot import hook
+from cloudbot.util import http
 
 
 @hook.command("metacritic", "mc")
diff --git a/plugins/minecraft_bukget.py b/plugins/minecraft_bukget.py
index 9180d96..4f0fc2d 100644
--- a/plugins/minecraft_bukget.py
+++ b/plugins/minecraft_bukget.py
@@ -3,11 +3,11 @@ import time
 import random
 import requests
 
-from cloudbot import hook, http, web
+from cloudbot import hook
+from cloudbot.util import http, web, formatting
 
 
 # # CONSTANTS
-from cloudbot import formatting
 
 base_url = "http://api.bukget.org/3/"
 
diff --git a/plugins/minecraft_status.py b/plugins/minecraft_status.py
index f73452e..acd8c4f 100644
--- a/plugins/minecraft_status.py
+++ b/plugins/minecraft_status.py
@@ -1,6 +1,7 @@
 import json
 
-from cloudbot import hook, http
+from cloudbot import hook
+from cloudbot.util import http
 
 
 @hook.command(autohelp=False)
diff --git a/plugins/minecraft_user.py b/plugins/minecraft_user.py
index 27cb2a9..2de1e26 100644
--- a/plugins/minecraft_user.py
+++ b/plugins/minecraft_user.py
@@ -4,7 +4,8 @@ import requests
 import json
 import re
 
-from cloudbot import hook, http
+from cloudbot import hook
+from cloudbot.util import http
 
 
 # I need TREE apis, all on separate domains, to get basic account info
diff --git a/plugins/minecraft_wiki.py b/plugins/minecraft_wiki.py
index 570723d..9489c13 100644
--- a/plugins/minecraft_wiki.py
+++ b/plugins/minecraft_wiki.py
@@ -1,6 +1,7 @@
 import re
 
-from cloudbot import hook, http, formatting
+from cloudbot import hook
+from cloudbot.util import http, formatting
 
 api_url = "http://minecraft.gamepedia.com/api.php?action=opensearch"
 mc_url = "http://minecraft.gamepedia.com/"
diff --git a/plugins/mlia.py b/plugins/mlia.py
index 065e960..9d94253 100644
--- a/plugins/mlia.py
+++ b/plugins/mlia.py
@@ -2,7 +2,8 @@
 
 import random
 
-from cloudbot import hook, http
+from cloudbot import hook
+from cloudbot.util import http
 
 mlia_cache = []
 
diff --git a/plugins/namegen.py b/plugins/namegen.py
index 5d8d342..636095d 100644
--- a/plugins/namegen.py
+++ b/plugins/namegen.py
@@ -1,7 +1,8 @@
 import json
 import os
 
-from cloudbot import hook, formatting, textgen
+from cloudbot import hook
+from cloudbot.util import formatting, textgen
 
 
 def get_generator(_json):
@@ -13,7 +14,7 @@ def get_generator(_json):
 @hook.command(autohelp=False)
 def namegen(text, bot, notice):
     """[generator|list] - generates some names using the chosen generator, or lists all generators if 'list' is specified
-    :type bot: cloudbot.core.bot.CloudBot
+    :type bot: cloudbot.bot.CloudBot
     """
 
     # clean up the input
diff --git a/plugins/newegg.py b/plugins/newegg.py
index 81400db..1dda1b1 100644
--- a/plugins/newegg.py
+++ b/plugins/newegg.py
@@ -1,7 +1,8 @@
 import json
 import re
 
-from cloudbot import hook, http, formatting, web
+from cloudbot import hook
+from cloudbot.util import http, formatting, web
 
 
 
diff --git a/plugins/newgrounds.py b/plugins/newgrounds.py
index 7fea478..2d7095e 100644
--- a/plugins/newgrounds.py
+++ b/plugins/newgrounds.py
@@ -1,6 +1,7 @@
 import re
 
-from cloudbot import hook, http
+from cloudbot import hook
+from cloudbot.util import http
 
 newgrounds_re = re.compile(r'(.*:)//(www.newgrounds.com|newgrounds.com)(:[0-9]+)?(.*)', re.I)
 valid = set('0123456789')
diff --git a/plugins/osrc.py b/plugins/osrc.py
index 01a3a71..1150a96 100644
--- a/plugins/osrc.py
+++ b/plugins/osrc.py
@@ -1,4 +1,5 @@
-from cloudbot import hook, http, web
+from cloudbot import hook
+from cloudbot.util import http, web
 
 
 user_url = "http://osrc.dfm.io/{}"
diff --git a/plugins/pagecheck.py b/plugins/pagecheck.py
index 79f589c..bef604d 100644
--- a/plugins/pagecheck.py
+++ b/plugins/pagecheck.py
@@ -3,7 +3,8 @@ import requests
 import requests.exceptions
 import urllib.parse
 
-from cloudbot import hook, urlnorm
+from cloudbot import hook
+from cloudbot.util import urlnorm
 
 
 @hook.command("down", "offline", "up")
diff --git a/plugins/plpaste.py b/plugins/plpaste.py
index 273145f..12ac517 100644
--- a/plugins/plpaste.py
+++ b/plugins/plpaste.py
@@ -1,13 +1,14 @@
 from os import listdir
 
-from cloudbot import hook, web
+from cloudbot import hook
+from cloudbot.util import web
 
 
 @hook.command(permissions=["adminonly"])
 def plpaste(text, bot):
     """<command> - pastes the plugin file that contains <command>
     :type text: str
-    :type bot: cloudbot.core.bot.CloudBot
+    :type bot: cloudbot.bot.CloudBot
     """
     if text in bot.plugin_manager.commands:
         file_path = bot.plugin_manager.commands[text].plugin.file_path
diff --git a/plugins/profiling.py b/plugins/profiling.py
index 8dc485a..feb16e6 100644
--- a/plugins/profiling.py
+++ b/plugins/profiling.py
@@ -22,7 +22,8 @@ try:
 except ImportError:
     objgraph = None
 
-from cloudbot import hook, web
+from cloudbot import hook
+from cloudbot.util import web
 
 
 def get_name(thread_id):
diff --git a/plugins/qrcode.py b/plugins/qrcode.py
index 4f47cb1..7a35fda 100644
--- a/plugins/qrcode.py
+++ b/plugins/qrcode.py
@@ -1,5 +1,6 @@
 # Plugin by https://github.com/Mu5tank05
-from cloudbot import hook, web, http
+from cloudbot import hook
+from cloudbot.util import web, http
 
 
 @hook.command('qr')
diff --git a/plugins/recipe.py b/plugins/recipe.py
index 407e59b..1ca63c7 100644
--- a/plugins/recipe.py
+++ b/plugins/recipe.py
@@ -2,7 +2,8 @@ import random
 import microdata
 import requests
 
-from cloudbot import hook, http, web
+from cloudbot import hook
+from cloudbot.util import http, web
 
 
 base_url = "http://www.cookstr.com"
diff --git a/plugins/reddit.py b/plugins/reddit.py
index 5a3ca2d..3b527fb 100644
--- a/plugins/reddit.py
+++ b/plugins/reddit.py
@@ -2,7 +2,8 @@ from datetime import datetime
 import re
 import random
 
-from cloudbot import hook, http, timesince, formatting
+from cloudbot import hook
+from cloudbot.util import http, timesince, formatting
 
 reddit_re = re.compile(r'.*(((www\.)?reddit\.com/r|redd\.it)[^ ]+)', re.I)
 
diff --git a/plugins/regex_chans.py b/plugins/regex_chans.py
index e43a3a6..498f8a1 100644
--- a/plugins/regex_chans.py
+++ b/plugins/regex_chans.py
@@ -1,6 +1,7 @@
 from sqlalchemy import Table, Column, UniqueConstraint, String
 
-from cloudbot import hook, botvars
+from cloudbot import hook
+from cloudbot.util import botvars
 
 table = Table(
     "regex_chans",
diff --git a/plugins/rottentomatoes.py b/plugins/rottentomatoes.py
index 900dc71..5c34465 100644
--- a/plugins/rottentomatoes.py
+++ b/plugins/rottentomatoes.py
@@ -1,4 +1,5 @@
-from cloudbot import http, hook
+from cloudbot import hook
+from cloudbot.util import http
 
 api_root = 'http://api.rottentomatoes.com/api/public/v1.0/'
 movie_search_url = api_root + 'movies.json'
diff --git a/plugins/rss.py b/plugins/rss.py
index 0b851d3..1357cca 100644
--- a/plugins/rss.py
+++ b/plugins/rss.py
@@ -1,4 +1,5 @@
-from cloudbot import hook, formatting, web
+from cloudbot import hook
+from cloudbot.util import formatting, web
 
 
 @hook.command("feed")
diff --git a/plugins/scene.py b/plugins/scene.py
index 97bad91..ebd15f4 100644
--- a/plugins/scene.py
+++ b/plugins/scene.py
@@ -1,6 +1,7 @@
 import datetime
 
-from cloudbot import hook, http, timesince
+from cloudbot import hook
+from cloudbot.util import http, timesince
 
 
 @hook.command("scene")
diff --git a/plugins/shorten.py b/plugins/shorten.py
index 1414898..cd35937 100644
--- a/plugins/shorten.py
+++ b/plugins/shorten.py
@@ -1,4 +1,5 @@
-from cloudbot import hook, web
+from cloudbot import hook
+from cloudbot.util import web
 
 
 @hook.command()
diff --git a/plugins/slap.py b/plugins/slap.py
index 64042b7..2f72610 100644
--- a/plugins/slap.py
+++ b/plugins/slap.py
@@ -1,6 +1,7 @@
 import json
 
-from cloudbot import hook, textgen
+from cloudbot import hook
+from cloudbot.util import textgen
 
 
 def get_generator(_json, variables):
diff --git a/plugins/slogan.py b/plugins/slogan.py
index 73b3b38..f35d83c 100644
--- a/plugins/slogan.py
+++ b/plugins/slogan.py
@@ -1,6 +1,7 @@
 import random
 
-from cloudbot import hook, formatting
+from cloudbot import hook
+from cloudbot.util import formatting
 
 with open("./data/slogans.txt") as f:
     slogans = [line.strip() for line in f.readlines()
diff --git a/plugins/snopes.py b/plugins/snopes.py
index 6affa17..7cee11d 100644
--- a/plugins/snopes.py
+++ b/plugins/snopes.py
@@ -1,6 +1,7 @@
 import re
 
-from cloudbot import hook, http
+from cloudbot import hook
+from cloudbot.util import http
 
 search_url = "http://search.atomz.com/search/?sp_a=00062d45-sp00000000"
 
diff --git a/plugins/soundcloud.py b/plugins/soundcloud.py
index 909e7f3..0c45282 100644
--- a/plugins/soundcloud.py
+++ b/plugins/soundcloud.py
@@ -1,8 +1,8 @@
 import re
 from urllib.parse import urlencode
 
-from cloudbot import hook, http, web
-from cloudbot import formatting
+from cloudbot import hook
+from cloudbot.util import http, web, formatting
 
 sc_re = re.compile(r'(.*:)//(www.)?(soundcloud.com)(.*)', re.I)
 api_url = "http://api.soundcloud.com"
diff --git a/plugins/spotify.py b/plugins/spotify.py
index 96d5828..ca656d6 100644
--- a/plugins/spotify.py
+++ b/plugins/spotify.py
@@ -1,7 +1,8 @@
 import re
 from urllib.parse import urlencode
 
-from cloudbot import hook, http, web
+from cloudbot import hook
+from cloudbot.util import http, web
 
 gateway = 'http://open.spotify.com/{}/{}'  # http spotify gw address
 spuri = 'spotify:{}:{}'
diff --git a/plugins/steam.py b/plugins/steam.py
index 3f95afa..da56152 100644
--- a/plugins/steam.py
+++ b/plugins/steam.py
@@ -2,7 +2,8 @@ import re
 
 from bs4 import BeautifulSoup, NavigableString, Tag
 
-from cloudbot import hook, http, web
+from cloudbot import hook
+from cloudbot.util import http, web
 from cloudbot.util.formatting import truncate_str
 
 steam_re = re.compile(r'(.*:)//(store.steampowered.com)(:[0-9]+)?(.*)', re.I)
diff --git a/plugins/steam_calc.py b/plugins/steam_calc.py
index 948948c..b6bf6a7 100644
--- a/plugins/steam_calc.py
+++ b/plugins/steam_calc.py
@@ -1,7 +1,8 @@
 import csv
 import io
 
-from cloudbot import hook, http
+from cloudbot import hook
+from cloudbot.util import http
 
 gauge_url = "http://www.mysteamgauge.com/search?username={}"
 
diff --git a/plugins/stock.py b/plugins/stock.py
index efcf4ff..9356f55 100644
--- a/plugins/stock.py
+++ b/plugins/stock.py
@@ -1,4 +1,5 @@
-from cloudbot import hook, web
+from cloudbot import hook
+from cloudbot.util import web
 
 
 @hook.command()
diff --git a/plugins/suggest.py b/plugins/suggest.py
index de8c213..1c30574 100644
--- a/plugins/suggest.py
+++ b/plugins/suggest.py
@@ -2,7 +2,8 @@ import json
 
 from bs4 import BeautifulSoup
 
-from cloudbot import hook, http, formatting
+from cloudbot import hook
+from cloudbot.util import http, formatting
 
 
 @hook.command()
diff --git a/plugins/tell.py b/plugins/tell.py
index 940aa5f..db2f87a 100644
--- a/plugins/tell.py
+++ b/plugins/tell.py
@@ -4,9 +4,9 @@ from datetime import datetime
 from sqlalchemy import Table, Column, String, Boolean, DateTime
 from sqlalchemy.sql import select
 
-from cloudbot import hook, timesince, botvars
-from cloudbot.event import EventType
-
+from cloudbot import hook
+from cloudbot.util import timesince, botvars
+from cloudbot.events import EventType
 
 table = Table(
     'tells',
@@ -75,8 +75,8 @@ def add_tell(db, server, sender, target, message):
 @hook.event(EventType.message, singlethread=True)
 def tellinput(event, conn, db, nick, notice):
     """
-    :type event: cloudbot.core.events.Event
-    :type conn: cloudbot.core.connection.Client
+    :type event: cloudbot.events.BaseEvent
+    :type conn: cloudbot.connection.Connection
     :type db: sqlalchemy.orm.Session
     """
     if 'showtells' in event.content.lower():
diff --git a/plugins/time_plugin.py b/plugins/time_plugin.py
index dc979ca..45426af 100644
--- a/plugins/time_plugin.py
+++ b/plugins/time_plugin.py
@@ -1,7 +1,7 @@
 import time
 
-from cloudbot import hook, http
-from cloudbot.util.formatting import capitalize_first
+from cloudbot import hook
+from cloudbot.util import http, formatting
 
 api_url = 'http://api.wolframalpha.com/v2/query?format=plaintext'
 
@@ -25,7 +25,7 @@ def time_command(inp, bot=None):
         if inp.lower() == "unix":
             place = "Unix Epoch"
         else:
-            place = capitalize_first(" ".join(request.xpath("//pod[@"
+            place = formatting.capitalize_first(" ".join(request.xpath("//pod[@"
                                                             "title='Input interpretation']/subpod/plaintext/text()"))[
                                      16:])
         return "{} - \x02{}\x02".format(current_time, place)
diff --git a/plugins/title.py b/plugins/title.py
index ccd5fb2..def393e 100644
--- a/plugins/title.py
+++ b/plugins/title.py
@@ -1,6 +1,7 @@
 from bs4 import BeautifulSoup
 
-from cloudbot import hook, http, urlnorm
+from cloudbot import hook
+from cloudbot.util import http, urlnorm
 
 
 @hook.command()
diff --git a/plugins/tvdb.py b/plugins/tvdb.py
index c407df6..2e3852e 100644
--- a/plugins/tvdb.py
+++ b/plugins/tvdb.py
@@ -1,6 +1,7 @@
 import datetime
 
-from cloudbot import hook, http
+from cloudbot import hook
+from cloudbot.util import http
 
 base_url = "http://thetvdb.com/api/"
 api_key = "469B73127CA0C411"
diff --git a/plugins/twitch.py b/plugins/twitch.py
index 3e68046..1ae9a2d 100644
--- a/plugins/twitch.py
+++ b/plugins/twitch.py
@@ -1,7 +1,8 @@
 import re
 from html.parser import HTMLParser
 
-from cloudbot import hook, http
+from cloudbot import hook
+from cloudbot.util import http
 
 twitch_re = re.compile(r'(.*:)//(twitch.tv|www.twitch.tv)(:[0-9]+)?(.*)', re.I)
 multitwitch_re = re.compile(r'(.*:)//(www.multitwitch.tv|multitwitch.tv)/(.*)', re.I)
diff --git a/plugins/twitter.py b/plugins/twitter.py
index 2731e09..509ef0a 100644
--- a/plugins/twitter.py
+++ b/plugins/twitter.py
@@ -5,7 +5,8 @@ from datetime import datetime
 from twitter import Twitter, OAuth
 from twitter.api import TwitterHTTPError
 
-from cloudbot import hook, timesince
+from cloudbot import hook
+from cloudbot.util import timesince
 
 
 @hook.onload()
diff --git a/plugins/update.py b/plugins/update.py
index 89032d0..bd2eafe 100644
--- a/plugins/update.py
+++ b/plugins/update.py
@@ -1,6 +1,7 @@
 from git import Repo
 
-from cloudbot import hook, web
+from cloudbot import hook
+from cloudbot.util import web
 
 
 @hook.command()
diff --git a/plugins/urban.py b/plugins/urban.py
index 7ece74c..0f738c6 100644
--- a/plugins/urban.py
+++ b/plugins/urban.py
@@ -1,6 +1,7 @@
 import random
 
-from cloudbot import hook, http, formatting
+from cloudbot import hook
+from cloudbot.util import http, formatting
 
 base_url = 'http://api.urbandictionary.com/v0'
 define_url = base_url + "/define"
diff --git a/plugins/utility.py b/plugins/utility.py
index 97000c7..f153345 100644
--- a/plugins/utility.py
+++ b/plugins/utility.py
@@ -5,7 +5,8 @@ import collections
 import re
 import binascii
 
-from cloudbot import hook, formatting
+from cloudbot import hook
+from cloudbot.util import formatting
 
 colors = collections.OrderedDict([
     ('red', '\x0304'),
diff --git a/plugins/validate.py b/plugins/validate.py
index dc61c24..115106f 100644
--- a/plugins/validate.py
+++ b/plugins/validate.py
@@ -4,7 +4,8 @@ Runs a given url through the w3c validator
 by Vladi
 """
 
-from cloudbot import hook, http
+from cloudbot import hook
+from cloudbot.util import http
 
 
 @hook.command("validate", "w3c")
diff --git a/plugins/valvesounds.py b/plugins/valvesounds.py
index b1b186d..810a549 100644
--- a/plugins/valvesounds.py
+++ b/plugins/valvesounds.py
@@ -1,7 +1,8 @@
 import json
 import urllib
 
-from cloudbot import hook, http, web
+from cloudbot import hook
+from cloudbot.util import http, web
 
 
 def get_sound_info(game, search):
diff --git a/plugins/vimeo.py b/plugins/vimeo.py
index fb30ab9..d1f15cd 100644
--- a/plugins/vimeo.py
+++ b/plugins/vimeo.py
@@ -1,4 +1,5 @@
-from cloudbot import hook, http, timeformat
+from cloudbot import hook
+from cloudbot.util import http, timeformat
 
 
 @hook.regex(r'vimeo.com/([0-9]+)')
diff --git a/plugins/weather.py b/plugins/weather.py
index e71dd2c..0a78a1c 100644
--- a/plugins/weather.py
+++ b/plugins/weather.py
@@ -1,4 +1,5 @@
-from cloudbot import hook, http, web
+from cloudbot import hook
+from cloudbot.util import http, web
 
 base_url = "http://api.wunderground.com/api/{}/{}/q/{}.json"
 
diff --git a/plugins/wikipedia.py b/plugins/wikipedia.py
index 0467960..6e33fce 100644
--- a/plugins/wikipedia.py
+++ b/plugins/wikipedia.py
@@ -3,7 +3,8 @@ Scaevolus 2009"""
 
 import re
 
-from cloudbot import hook, http, formatting
+from cloudbot import hook
+from cloudbot.util import http, formatting
 
 api_prefix = "http://en.wikipedia.org/w/api.php"
 search_url = api_prefix + "?action=opensearch&format=xml"
diff --git a/plugins/wolframalpha.py b/plugins/wolframalpha.py
index 48e5620..d3bdeb4 100644
--- a/plugins/wolframalpha.py
+++ b/plugins/wolframalpha.py
@@ -1,6 +1,7 @@
 import re
 
-from cloudbot import hook, http, web, formatting
+from cloudbot import hook
+from cloudbot.util import http, web, formatting
 
 
 @hook.command("wa", "calc", "math", "wolframalpha")
diff --git a/plugins/wow.py b/plugins/wow.py
index 7e92b92..7dba65e 100644
--- a/plugins/wow.py
+++ b/plugins/wow.py
@@ -10,7 +10,8 @@ armoury, armory: Request data from the armoury API and format it into something
 import re
 import requests
 
-from cloudbot import hook, web
+from cloudbot import hook
+from cloudbot.util import web
 
 
 def wow_armoury_data(link):
diff --git a/plugins/xkcd.py b/plugins/xkcd.py
index 3a3ca34..0c451e9 100644
--- a/plugins/xkcd.py
+++ b/plugins/xkcd.py
@@ -1,6 +1,7 @@
 import re
 
-from cloudbot import hook, http
+from cloudbot import hook
+from cloudbot.util import http
 
 xkcd_re = re.compile(r'(.*:)//(www.xkcd.com|xkcd.com)(.*)', re.I)
 months = {1: 'January', 2: 'February', 3: 'March', 4: 'April', 5: 'May', 6: 'June', 7: 'July', 8: 'August',
diff --git a/plugins/yahooanswers.py b/plugins/yahooanswers.py
index 315baf5..f9f7d85 100644
--- a/plugins/yahooanswers.py
+++ b/plugins/yahooanswers.py
@@ -1,4 +1,5 @@
-from cloudbot import hook, web, formatting
+from cloudbot import hook
+from cloudbot.util import web, formatting
 
 
 @hook.command()
diff --git a/plugins/youtube.py b/plugins/youtube.py
index efcda9e..d2472d0 100644
--- a/plugins/youtube.py
+++ b/plugins/youtube.py
@@ -1,7 +1,8 @@
 import re
 import time
 
-from cloudbot import hook, http, timeformat
+from cloudbot import hook
+from cloudbot.util import http, timeformat
 
 youtube_re = re.compile(r'(?:youtube.*?(?:v=|/v/)|youtu\.be/|yooouuutuuube.*?id=)([-_a-zA-Z0-9]+)', re.I)
 
-- 
2.0.0

