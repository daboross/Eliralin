From 84fefc8c5833efa9f176d38bcedc78bd25b2d715 Mon Sep 17 00:00:00 2001
From: Dabo Ross <daboross@daboross.net>
Date: Tue, 10 Jun 2014 16:35:24 -0700
Subject: [PATCH] Majorly redo events.py, to have a new set of non-irc-specific
 parameters ready for abstraction.

- Rename event.irc_message to event.context. This allows for getting the content of a message in a non irc-specific manner
- Instead of having event.conn depend on event.irc_paramlist, instead have it be set in creation
- Add an event.target variable to show the target of an event. This is currently only set in INVITE and KICK events
- Add an event.irc_ctcp_text for when a CTCP is used from IRC. This makes it easier for plugins to access CTCP command/text
- Add an EventType enumeration for specifying different types of events in a non-irc-specific manner
- Update plugins to use event.content instead of event.irc_message
- Set event.bot when creating on connection.py, instead of setting it in child events in bot.process
- Remove event.server, as it's irc-specific and can be easily gotten from event.conn.server

diff --git a/cloudbot/core/bot.py b/cloudbot/core/bot.py
index 5788ff6..5760519 100644
--- a/cloudbot/core/bot.py
+++ b/cloudbot/core/bot.py
@@ -14,7 +14,7 @@ from cloudbot.core.connection import BotConnection
 from cloudbot.core.config import Config
 from cloudbot.core.reloader import PluginReloader
 from cloudbot.core.pluginmanager import PluginManager
-from cloudbot.core.events import BaseEvent, CommandEvent, RegexEvent
+from cloudbot.core.events import BaseEvent, CommandEvent, RegexEvent, EventType
 from cloudbot.util import botvars, formatting
 
 logger = logging.getLogger("cloudbot")
@@ -203,28 +203,27 @@ class CloudBot:
             # run catch-all coroutine hooks before all others - TODO: Make this a plugin argument
             if not raw_hook.threaded:
                 run_before_tasks.append(
-                    self.plugin_manager.launch(raw_hook, BaseEvent(bot=self, hook=raw_hook, base_event=event)))
+                    self.plugin_manager.launch(raw_hook, BaseEvent(hook=raw_hook, base_event=event)))
             else:
-                tasks.append(self.plugin_manager.launch(raw_hook, BaseEvent(bot=self, hook=raw_hook, base_event=event)))
+                tasks.append(self.plugin_manager.launch(raw_hook, BaseEvent(hook=raw_hook, base_event=event)))
         if event.irc_command in self.plugin_manager.raw_triggers:
             for raw_hook in self.plugin_manager.raw_triggers[event.irc_command]:
-                tasks.append(self.plugin_manager.launch(raw_hook, BaseEvent(bot=self, hook=raw_hook, base_event=event)))
+                tasks.append(self.plugin_manager.launch(raw_hook, BaseEvent(hook=raw_hook, base_event=event)))
 
-        if event.irc_command == 'PRIVMSG':
+        if event.type is EventType.message:
             # Commands
             if event.chan.lower() == event.nick.lower():  # private message, no command prefix
                 command_re = r'(?i)^(?:[{}]?|{}[,;:]+\s+)(\w+)(?:$|\s+)(.*)'.format(command_prefix, event.conn.nick)
             else:
                 command_re = r'(?i)^(?:[{}]|{}[,;:]+\s+)(\w+)(?:$|\s+)(.*)'.format(command_prefix, event.conn.nick)
 
-            match = re.match(command_re, event.irc_message)
+            match = re.match(command_re, event.content)
 
             if match:
                 command = match.group(1).lower()
                 if command in self.plugin_manager.commands:
                     command_hook = self.plugin_manager.commands[command]
-                    command_event = CommandEvent(bot=self, hook=command_hook, text=match.group(2).strip(),
-                                                 triggered_command=command, base_event=event)
+                    command_event = CommandEvent(hook=command_hook, text=match.group(2).strip(), triggered_command=command, base_event=event)
                     tasks.append(self.plugin_manager.launch(command_hook, command_event))
                 else:
                     potential_matches = []
@@ -234,8 +233,7 @@ class CloudBot:
                     if potential_matches:
                         if len(potential_matches) == 1:
                             command_hook = potential_matches[0][1]
-                            command_event = CommandEvent(bot=self, hook=command_hook, text=match.group(2).strip(),
-                                                         triggered_command=command, base_event=event)
+                            command_event = CommandEvent(hook=command_hook, text=match.group(2).strip(), triggered_command=command, base_event=event)
                             tasks.append(self.plugin_manager.launch(command_hook, command_event))
                         else:
                             event.notice("Possible matches: {}".format(
@@ -243,9 +241,9 @@ class CloudBot:
 
             # Regex hooks
             for regex, regex_hook in self.plugin_manager.regex_hooks:
-                match = regex.search(event.irc_message)
+                match = regex.search(event.content)
                 if match:
-                    regex_event = RegexEvent(bot=self, hook=regex_hook, match=match, base_event=event)
+                    regex_event = RegexEvent(hook=regex_hook, match=match, base_event=event)
                     tasks.append(self.plugin_manager.launch(regex_hook, regex_event))
 
         # Run the tasks
diff --git a/cloudbot/core/connection.py b/cloudbot/core/connection.py
index 64bb737..5eb12b1 100644
--- a/cloudbot/core/connection.py
+++ b/cloudbot/core/connection.py
@@ -6,7 +6,7 @@ import logging
 from ssl import SSLContext
 
 from cloudbot.core.permissions import PermissionManager
-from cloudbot.core.events import BaseEvent
+from cloudbot.core.events import BaseEvent, EventType
 
 logger = logging.getLogger("cloudbot")
 
@@ -15,6 +15,14 @@ irc_noprefix_re = re.compile(r"([^ ]*) (.*)")
 irc_netmask_re = re.compile(r"([^!@]*)!([^@]*)@(.*)")
 irc_param_re = re.compile(r"(?:^|(?<= ))(:.*|[^ ]+)")
 
+irc_command_to_event_type = {
+    "PRIVMSG": EventType.message,
+    "JOIN": EventType.join,
+    "PART": EventType.part,
+    "KICK": EventType.kick,
+    "NOTICE": EventType.notice
+}
+
 
 class BotConnection:
     """ A BotConnection represents each connection the bot makes to an IRC server
@@ -261,6 +269,18 @@ class IRCConnection:
 
 
 class IRCProtocol(asyncio.Protocol):
+    """
+    :type loop: asyncio.events.AbstractEventLoop
+    :type readable_name: str
+    :type describe_server: lambda
+    :type botconn: cloudbot.core.connection.BotConnection
+    :type bot: cloudbot.core.bot.CloudBot
+    :type _input_buffer: bytes
+    :type _connected: bool
+    :type _transport: asyncio.transports.Transport
+    :type _connected_future: asyncio.Future
+    """
+
     def __init__(self, ircconn):
         """
         :type ircconn: IRCConnection
@@ -270,19 +290,21 @@ class IRCProtocol(asyncio.Protocol):
         self.describe_server = lambda: ircconn.describe_server()
         self.botconn = ircconn.botconn
         self.bot = ircconn.botconn.bot
+
         # input buffer
         self._input_buffer = b""
+
         # connected
         self._connected = False
 
         # transport
-        self.transport = None
+        self._transport = None
 
         # Future that waits until we are connected
-        self._connected_future = asyncio.Future()
+        self._connected_future = asyncio.Future(loop=self.loop)
 
     def connection_made(self, transport):
-        self.transport = transport
+        self._transport = transport
         self._connected = True
         self._connected_future.set_result(None)
         # we don't need the _connected_future, everything uses it will check _connected first.
@@ -313,21 +335,21 @@ class IRCProtocol(asyncio.Protocol):
             yield from self._connected_future
         line = line.splitlines()[0][:500] + "\r\n"
         data = line.encode("utf-8", "replace")
-        self.transport.write(data)
+        self._transport.write(data)
 
     def data_received(self, data):
         self._input_buffer += data
+
         while b"\r\n" in self._input_buffer:
-            line, self._input_buffer = self._input_buffer.split(b"\r\n", 1)
-            line = line.decode()
+            line_data, self._input_buffer = self._input_buffer.split(b"\r\n", 1)
+            line = line_data.decode()
 
             # parse the line into a message
             if line.startswith(":"):
                 prefix_line_match = irc_prefix_re.match(line)
                 if prefix_line_match is None:
                     logger.critical("[{}] Received invalid IRC line '{}' from {}".format(
-                        self.readable_name, line, self.describe_server()
-                    ))
+                        self.readable_name, line, self.describe_server()))
                     continue
 
                 netmask_prefix, command, params = prefix_line_match.groups()
@@ -349,8 +371,7 @@ class IRCProtocol(asyncio.Protocol):
                 noprefix_line_match = irc_noprefix_re.match(line)
                 if noprefix_line_match is None:
                     logger.critical("[{}] Received invalid IRC line '{}' from {}".format(
-                        self.readable_name, line, self.describe_server()
-                    ))
+                        self.readable_name, line, self.describe_server()))
                     continue
                 command = noprefix_line_match.group(1)
                 params = noprefix_line_match.group(2)
@@ -361,24 +382,68 @@ class IRCProtocol(asyncio.Protocol):
 
             command_params = irc_param_re.findall(params)
 
-            if command_params:
-                # If the last param is in the format of `:message text` remove the `:` from it, so that it is just the content.
-                if command_params[-1].startswith(":"):
-                    command_params[-1] = command_params[-1][1:]
-                irc_message_content = command_params[-1]
-            else:
-                irc_message_content = None
-
             # Reply to pings immediately
+
             if command == "PING":
-                asyncio.async(self.send("PONG :" + irc_message_content))
+                asyncio.async(self.send("PONG " + command_params[-1]), loop=self.loop)
+
+            # Parse the command and params
+
+            # Content
+            if command_params and command_params[-1].startswith(":"):
+                # If the last param is in the format of `:content` remove the `:` from it, and set content from it
+                content = command_params[-1][1:]
+            else:
+                content = None
+
+            # Event type
+            if command in irc_command_to_event_type:
+                event_type = irc_command_to_event_type[command]
+            else:
+                event_type = EventType.other
+
+            # Target (for KICK, INVITE)
+            if event_type is EventType.kick:
+                target = command_params[1]
+            elif command == "INVITE":
+                target = command_params[0]
+            else:
+                # TODO: Find more commands which give a target
+                target = None
+
+            # Parse for CTCP
+            if event_type is EventType.message and content.count("\x01") >= 2 and content.startswith("\x01"):
+                # Remove the first \x01, then rsplit to remove the last one, and ignore text after the last \x01
+                ctcp_text = content[1:].rsplit("\x01", 1)[0]
+                ctcp_text_split = ctcp_text.split(None, 1)
+                if ctcp_text_split[0] == "ACTION":
+                    # this is a CTCP ACTION, set event_type and content accordingly
+                    event_type = EventType.action
+                    content = ctcp_text_split[1]
+                else:
+                    # this shouldn't be considered a regular message
+                    event_type = EventType.other
+            else:
+                ctcp_text = None
+
+            # Channel
+            # TODO: Migrate plugins using chan for storage to use chan.lower() instead so we can pass the original case
+            if command_params and (len(command_params) > 2 or not command_params[0].startswith(":")):
+
+                if command_params[0].lower() == self.botconn.nick.lower():
+                    # this is a private message - set the channel to the sender's nick
+                    channel = nick.lower()
+                else:
+                    channel = command_params[0].lower()
+            else:
+                channel = None
 
             # Set up parsed message
             # TODO: Do we really want to send the raw `prefix` and `command_params` here?
-            event = BaseEvent(conn=self.botconn, irc_raw=line, irc_prefix=prefix, irc_command=command,
-                              irc_paramlist=command_params, irc_message=irc_message_content, nick=nick, user=user,
-                              host=host,
-                              mask=mask)
+            event = BaseEvent(bot=self.bot, conn=self.botconn, event_type=event_type, content=content, target=target,
+                              channel=channel, nick=nick, user=user, host=host, mask=mask, irc_raw=line,
+                              irc_prefix=prefix, irc_command=command, irc_paramlist=command_params,
+                              irc_ctcp_text=ctcp_text)
 
             # handle the message, async
-            asyncio.async(self.bot.process(event))
+            asyncio.async(self.bot.process(event), loop=self.loop)
diff --git a/cloudbot/core/events.py b/cloudbot/core/events.py
index 949a597..62830c5 100644
--- a/cloudbot/core/events.py
+++ b/cloudbot/core/events.py
@@ -1,38 +1,63 @@
 import asyncio
+import enum
 import logging
 import concurrent.futures
 
 logger = logging.getLogger("cloudbot")
 
 
+@enum.unique
+class EventType(enum.Enum):
+    message = 0
+    action = 1
+    # TODO: Do we actually want to have a 'notice' event type? Should the NOTICE command be a 'message' type?
+    notice = 2
+    join = 3
+    part = 4
+    kick = 5
+    other = 6
+
+
 class BaseEvent:
     """
     :type bot: cloudbot.core.bot.CloudBot
     :type conn: cloudbot.core.connection.BotConnection
     :type hook: cloudbot.core.pluginmanager.Hook
+    :type type: EventType
+    :type content: str
+    :type target: str
+    :type chan: str
     :type nick: str
     :type user: str
     :type host: str
     :type mask: str
     :type db: sqlalchemy.orm.Session
     :type db_executor: concurrent.futures.ThreadPoolExecutor
-    :type irc_message: str
     :type irc_raw: str
     :type irc_prefix: str
     :type irc_command: str
     :type irc_paramlist: str
+    :type irc_ctcp_text: str
     """
 
-    def __init__(self, *, bot=None, hook=None, conn=None, base_event=None, irc_message=None, nick=None, user=None,
-                 host=None, mask=None, irc_raw=None, irc_prefix=None, irc_command=None, irc_paramlist=None):
+    def __init__(self, *, bot=None, hook=None, conn=None, base_event=None, event_type=EventType.other, content=None,
+                 target=None, channel=None, nick=None, user=None, host=None, mask=None, irc_raw=None, irc_prefix=None,
+                 irc_command=None, irc_paramlist=None, irc_ctcp_text=None):
         """
-        All of these parameters except for *bot* and *hook* are optional, *bot* may be left out when using base_event.
+        All of these parameters except for `bot` and `hook` are optional.
+        The irc_* parameters should only be specified for IRC events.
+
+        Note that the `bot` argument may be left out if you specify a `base_event`.
 
         :param bot: The CloudBot instance this event was triggered from
         :param conn: The Connection instance this event was triggered from
         :param hook: The hook this event will be passed to
         :param base_event: The base event that this event is based on. If this parameter is not None, then nick, user,
                             host, mask, and irc_* arguments are ignored
+        :param event_type: The type of the event
+        :param content: The content of the message, or the reason for an join or part
+        :param target: The target of the action, for example the user being kicked, or invited
+        :param channel: The channel that this action took place in
         :param nick: The nickname of the sender that triggered this event
         :param user: The user of the sender that triggered this event
         :param host: The host of the sender that triggered this event
@@ -42,20 +67,23 @@ class BaseEvent:
         :param irc_command: The IRC command
         :param irc_paramlist: The list of params for the IRC command. If the last param is a content param, the ':'
                                 should be removed from the front.
-        :param irc_message: The content of the message, or the reason for an join or part
+        :param irc_ctcp_text: CTCP text if this message is a CTCP command
         :type bot: cloudbot.core.bot.CloudBot
         :type conn: cloudbot.core.connection.BotConnection
         :type hook: cloudbot.core.pluginmanager.Hook
         :type base_event: cloudbot.core.events.BaseEvent
+        :type content: str
+        :type target: str
+        :type event_type: EventType
         :type nick: str
         :type user: str
         :type host: str
         :type mask: str
-        :type irc_message: str
         :type irc_raw: str
         :type irc_prefix: str
         :type irc_command: str
         :type irc_paramlist: list[str]
+        :type irc_ctcp_text: str
         """
         self.db = None
         self.db_executor = None
@@ -71,27 +99,37 @@ class BaseEvent:
             if self.hook is None and base_event.hook is not None:
                 self.hook = base_event.hook
 
-            # inherit nick/usr/host/mask/irc_* without checking internal values, as we always want to inherit these
+            # If base_event is provided, don't check these parameters, just inherit
+            self.type = base_event.type
+            self.content = base_event.content
+            self.target = base_event.target
+            self.chan = base_event.chan
             self.nick = base_event.nick
             self.user = base_event.user
             self.host = base_event.host
             self.mask = base_event.mask
-            self.irc_message = base_event.irc_message
+            # irc-specific parameters
             self.irc_raw = base_event.irc_raw
             self.irc_prefix = base_event.irc_prefix
             self.irc_command = base_event.irc_command
             self.irc_paramlist = base_event.irc_paramlist
+            self.irc_ctcp_text = base_event.irc_ctcp_text
         else:
-            # if we're not inheriting an event, we can take these parameters
-            self.irc_message = irc_message
-            self.irc_raw = irc_raw
-            self.irc_prefix = irc_prefix
-            self.irc_command = irc_command
-            self.irc_paramlist = irc_paramlist
+            # Since base_event wasn't provided, we can take these parameters
+            self.type = event_type
+            self.content = content
+            self.target = target
+            self.chan = channel
             self.nick = nick
             self.user = user
             self.host = host
             self.mask = mask
+            # irc-specific parameters
+            self.irc_raw = irc_raw
+            self.irc_prefix = irc_prefix
+            self.irc_command = irc_command
+            self.irc_paramlist = irc_paramlist
+            self.irc_ctcp_text = irc_ctcp_text
 
     @asyncio.coroutine
     def prepare(self):
@@ -169,30 +207,6 @@ class BaseEvent:
             self.db = None
 
     @property
-    def server(self):
-        """
-        :rtype: str
-        """
-        if self.conn is not None:
-            return self.conn.server
-        else:
-            return None
-
-    @property
-    def chan(self):
-        """
-        :rtype: str
-        """
-        if self.irc_paramlist:
-            if self.irc_paramlist[0].lower() == self.conn.nick.lower():
-                # this is a private message - set the nick to the sender's nick
-                return self.nick.lower()
-            else:
-                return self.irc_paramlist[0].lower()
-        else:
-            return None
-
-    @property
     def event(self):
         """
         :rtype; cloudbot.core.events.BaseEvent
@@ -301,18 +315,18 @@ class CommandEvent(BaseEvent):
     :type triggered_command: str
     """
 
-    def __init__(self, *, bot=None, hook, text, triggered_command, conn=None, base_event=None, irc_message=None,
-                 nick=None, user=None, host=None, mask=None, irc_raw=None, irc_prefix=None, irc_command=None,
-                 irc_paramlist=None):
+    def __init__(self, *, bot=None, hook, text, triggered_command, conn=None, base_event=None, event_type=None,
+                 content=None, target=None, channel=None, nick=None, user=None, host=None, mask=None, irc_raw=None,
+                 irc_prefix=None, irc_command=None, irc_paramlist=None):
         """
         :param text: The arguments for the command
         :param triggered_command: The command that was triggered
         :type text: str
         :type triggered_command: str
         """
-        super().__init__(bot=bot, hook=hook, conn=conn, base_event=base_event, nick=nick, user=user, host=host,
-                         mask=mask, irc_message=irc_message, irc_raw=irc_raw, irc_prefix=irc_prefix,
-                         irc_command=irc_command, irc_paramlist=irc_paramlist)
+        super().__init__(bot=bot, hook=hook, conn=conn, base_event=base_event, event_type=event_type, content=content,
+                         target=target, channel=channel, nick=nick, user=user, host=host, mask=mask, irc_raw=irc_raw,
+                         irc_prefix=irc_prefix, irc_command=irc_command, irc_paramlist=irc_paramlist)
         self.hook = hook
         self.text = text
         self.triggered_command = triggered_command
@@ -343,13 +357,14 @@ class RegexEvent(BaseEvent):
     :type match: re.__Match
     """
 
-    def __init__(self, *, bot=None, hook, match, conn=None, base_event=None, irc_message=None, nick=None, user=None,
-                 host=None, mask=None, irc_raw=None, irc_prefix=None, irc_command=None, irc_paramlist=None):
+    def __init__(self, *, bot=None, hook, match, conn=None, base_event=None, event_type=None, content=None, target=None,
+                 channel=None, nick=None, user=None, host=None, mask=None, irc_raw=None, irc_prefix=None,
+                 irc_command=None, irc_paramlist=None):
         """
         :param: match: The match objected returned by the regex search method
         :type match: re.__Match
         """
-        super().__init__(bot=bot, conn=conn, hook=hook, base_event=base_event, nick=nick, user=user, host=host,
-                         mask=mask, irc_message=irc_message, irc_raw=irc_raw, irc_prefix=irc_prefix,
-                         irc_command=irc_command, irc_paramlist=irc_paramlist)
+        super().__init__(bot=bot, conn=conn, hook=hook, base_event=base_event, event_type=event_type, content=content,
+                         target=target, channel=channel, nick=nick, user=user, host=host, mask=mask, irc_raw=irc_raw,
+                         irc_prefix=irc_prefix, irc_command=irc_command, irc_paramlist=irc_paramlist)
         self.match = match
diff --git a/plugins/history.py b/plugins/history.py
index 8f09019..4865ffc 100644
--- a/plugins/history.py
+++ b/plugins/history.py
@@ -27,13 +27,9 @@ def track_seen(event, db, conn):
     """
     db_init(db, conn)
     # keep private messages private
-    if event.chan[:1] == "#" and not re.findall('^s/.*/.*/$', event.irc_message.lower()):
-        db.execute("insert or replace into seen_user(name, time, quote, chan, host)"
-                   "values(:name,:time,:quote,:chan,:host)", {'name': event.nick.lower(),
-                                                              'time': time.time(),
-                                                              'quote': event.irc_message,
-                                                              'chan': event.chan,
-                                                              'host': event.mask})
+    if event.chan[:1] == "#" and not re.findall('^s/.*/.*/$', event.content.lower()):
+        db.execute("insert or replace into seen_user(name, time, quote, chan, host) values(:name,:time,:quote,:chan,:host)",
+                   {'name': event.nick.lower(), 'time': time.time(), 'quote': event.content, 'chan': event.chan, 'host': event.mask})
         db.commit()
 
 
@@ -48,7 +44,7 @@ def track_history(event, message_time, conn):
         conn.history[event.chan] = deque(maxlen=100)
         history = conn.history[event.chan]
 
-    data = (event.nick, message_time, event.irc_message)
+    data = (event.nick, message_time, event.content)
     history.append(data)
 
 
diff --git a/plugins/ignore.py b/plugins/ignore.py
index fed4128..a065146 100644
--- a/plugins/ignore.py
+++ b/plugins/ignore.py
@@ -2,6 +2,7 @@ import asyncio
 from fnmatch import fnmatch
 
 from cloudbot import hook
+from cloudbot.core.events import EventType
 
 
 @hook.onload
@@ -35,7 +36,7 @@ def ignore_sieve(bot, event, _hook):
         return event
 
     # don't block an event that could be unignoring
-    if event.irc_command == "PRIVMSG" and event.irc_message[1:] == "unignore":
+    if event.type is EventType.message and event.content[1:] == "unignore":
         return event
 
     if event.mask is None:
diff --git a/plugins/tell.py b/plugins/tell.py
index 046e2b9..8a8e5e1 100644
--- a/plugins/tell.py
+++ b/plugins/tell.py
@@ -77,7 +77,7 @@ def tellinput(event, conn, db, nick, notice):
     :type conn: cloudbot.core.connection.BotConnection
     :type db: sqlalchemy.orm.Session
     """
-    if 'showtells' in event.irc_message.lower():
+    if 'showtells' in event.content.lower():
         return
 
     tells = get_unread(db, conn.server, nick)
-- 
2.0.0

