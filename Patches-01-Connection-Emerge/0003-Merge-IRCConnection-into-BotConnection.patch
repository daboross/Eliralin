From 709e507d64c3649f2d97c6023a201477a9e6868c Mon Sep 17 00:00:00 2001
From: Dabo Ross <daboross@daboross.net>
Date: Tue, 10 Jun 2014 17:21:21 -0700
Subject: [PATCH] Merge IRCConnection into BotConnection


diff --git a/cloudbot/core/bot.py b/cloudbot/core/bot.py
index 8bdc59e..80c21ef 100644
--- a/cloudbot/core/bot.py
+++ b/cloudbot/core/bot.py
@@ -145,7 +145,7 @@ class CloudBot:
             self.reloader.stop()
 
         for connection in self.connections:
-            if not connection.connected:
+            if not connection._connected:
                 # Don't quit a connection that hasn't connected
                 continue
             logger.debug("[{}] Closing connection.".format(connection.readable_name))
@@ -155,7 +155,7 @@ class CloudBot:
         yield from asyncio.sleep(1.0)  # wait for 'QUIT' calls to take affect
 
         for connection in self.connections:
-            if not connection.connected:
+            if not connection._connected:
                 # Don't close a connection that hasn't connected
                 continue
             connection.close()
@@ -203,12 +203,12 @@ class CloudBot:
             # run catch-all coroutine hooks before all others - TODO: Make this a plugin argument
             if not raw_hook.threaded:
                 run_before_tasks.append(
-                    self.plugin_manager.launch(raw_hook, BaseEvent(bot=self, hook=raw_hook, base_event=event)))
+                    self.plugin_manager.launch(raw_hook, BaseEvent(hook=raw_hook, base_event=event)))
             else:
-                tasks.append(self.plugin_manager.launch(raw_hook, BaseEvent(bot=self, hook=raw_hook, base_event=event)))
+                tasks.append(self.plugin_manager.launch(raw_hook, BaseEvent(hook=raw_hook, base_event=event)))
         if event.irc_command in self.plugin_manager.raw_triggers:
             for raw_hook in self.plugin_manager.raw_triggers[event.irc_command]:
-                tasks.append(self.plugin_manager.launch(raw_hook, BaseEvent(bot=self, hook=raw_hook, base_event=event)))
+                tasks.append(self.plugin_manager.launch(raw_hook, BaseEvent(hook=raw_hook, base_event=event)))
 
         if event.content is not None:
             # Commands
@@ -223,8 +223,7 @@ class CloudBot:
                 command = match.group(1).lower()
                 if command in self.plugin_manager.commands:
                     command_hook = self.plugin_manager.commands[command]
-                    command_event = CommandEvent(bot=self, hook=command_hook, text=match.group(2).strip(),
-                                                 triggered_command=command, base_event=event)
+                    command_event = CommandEvent(hook=command_hook, text=match.group(2).strip(), triggered_command=command, base_event=event)
                     tasks.append(self.plugin_manager.launch(command_hook, command_event))
                 else:
                     potential_matches = []
@@ -234,8 +233,7 @@ class CloudBot:
                     if potential_matches:
                         if len(potential_matches) == 1:
                             command_hook = potential_matches[0][1]
-                            command_event = CommandEvent(bot=self, hook=command_hook, text=match.group(2).strip(),
-                                                         triggered_command=command, base_event=event)
+                            command_event = CommandEvent(hook=command_hook, text=match.group(2).strip(), triggered_command=command, base_event=event)
                             tasks.append(self.plugin_manager.launch(command_hook, command_event))
                         else:
                             event.notice("Possible matches: {}".format(
@@ -245,7 +243,7 @@ class CloudBot:
             for regex, regex_hook in self.plugin_manager.regex_hooks:
                 match = regex.search(event.content)
                 if match:
-                    regex_event = RegexEvent(bot=self, hook=regex_hook, match=match, base_event=event)
+                    regex_event = RegexEvent(hook=regex_hook, match=match, base_event=event)
                     tasks.append(self.plugin_manager.launch(regex_hook, regex_event))
 
         # Run the tasks
diff --git a/cloudbot/core/connection.py b/cloudbot/core/connection.py
index b47c387..a29c0f0 100644
--- a/cloudbot/core/connection.py
+++ b/cloudbot/core/connection.py
@@ -17,24 +17,27 @@ irc_param_re = re.compile(r"(?:^|(?<= ))(:.*|[^ ]+)")
 
 
 class BotConnection:
-    """ A BotConnection represents each connection the bot makes to an IRC server
+    """
+    A BotConnection represents each connection the bot makes to a single server
     :type bot: cloudbot.core.bot.CloudBot
+    :type loop: asyncio.events.AbstractEventLoop
     :type name: str
+    :type readable_name: str
     :type channels: list[str]
     :type config: dict[str, unknown]
-    :type ssl: bool
+    :type use_ssl: bool
     :type server: str
     :type port: int
     :type nick: str
     :type vars: dict
     :type history: dict[str, list[tuple]]
-    :type connection: IRCConnection
     :type permissions: PermissionManager
-    :type connected: bool
+    :type _connected: bool
+    :type _ignore_cert_errors: bool
     """
 
     def __init__(self, bot, name, server, nick, port=6667, use_ssl=False, channels=None, config=None,
-                 readable_name=None):
+                 readable_name=None, ignore_cert_errors=True, timeout=300):
         """
         :type bot: cloudbot.core.bot.CloudBot
         :type name: str
@@ -62,7 +65,9 @@ class BotConnection:
         else:
             self.config = config
 
-        self.ssl = use_ssl
+        self.use_ssl = use_ssl
+        self._ignore_cert_errors = ignore_cert_errors
+        self._timeout = timeout
         self.server = server
         self.port = port
         self.nick = nick
@@ -72,26 +77,50 @@ class BotConnection:
         # create permissions manager
         self.permissions = PermissionManager(self)
 
-        # create the IRC connection
-        self.connection = IRCConnection(self)
+        # create SSL context
+        if self.use_ssl:
+            self.ssl_context = SSLContext(PROTOCOL_SSLv23)
+            if self._ignore_cert_errors:
+                self.ssl_context.verify_mode = ssl.CERT_NONE
+            else:
+                self.ssl_context.verify_mode = ssl.CERT_REQUIRED
+        else:
+            self.ssl_context = None
 
-        self.connected = False
+        # if we're connected
+        self._connected = False
         # if we've quit
         self._quit = False
+        # transport and protocol
+        self._transport = None
+        self._protocol = None
+
+    def describe_server(self):
+        if self.use_ssl:
+            return "+{}:{}".format(self.server, self.port)
+        else:
+            return "{}:{}".format(self.server, self.port)
 
     @asyncio.coroutine
     def connect(self):
         """
-        Connects to the IRC server. This by itself doesn't start receiving or sending data.
+        Connects to the IRC server, or reconnects if already connected.
         """
         if self._quit:
             # we've quit, so close instead (because this has probably been called because of EOF received)
-            self.connection.close()
+            self.close()
             return
         # connect to the irc server
-        yield from self.connection.connect()
+        if self._connected:
+            logger.info("[{}] Reconnecting".format(self.readable_name))
+            self._transport.close()
+        else:
+            self._connected = True
+            logger.info("[{}] Connecting".format(self.readable_name))
 
-        self.connected = True
+        self._transport, self._protocol = yield from self.loop.create_connection(
+            lambda: IRCProtocol(self), host=self.server, port=self.port, ssl=self.ssl_context,
+        )
 
         # send the password, nick, and user
         self.set_pass(self.config["connection"].get("password"))
@@ -109,7 +138,10 @@ class BotConnection:
             self.cmd("QUIT")
 
     def close(self):
-        self.connection.close()
+        if not self._connected:
+            return
+        self._transport.close()
+        self._connected = False
 
     def set_pass(self, password):
         """
@@ -174,102 +206,22 @@ class BotConnection:
         Sends a raw IRC line
         :type line: str
         """
-        if not self.connected:
+        if not self._connected:
             raise ValueError("Connection must be connected to irc server to use send")
         logger.info("[{}] >> {}".format(self.readable_name, line))
-        self.loop.call_soon_threadsafe(asyncio.async, self.connection.send(line))
-
-
-class IRCConnection:
-    """
-    Handles an IRC Connection to a specific IRC server.
+        self.loop.call_soon_threadsafe(asyncio.async, self._protocol.send(line))
 
-    :type readable_name: str
-    :type host: str
-    :type port: int
-    :type use_ssl: bool
-    :type botconn: BotConnection
-    :type ignore_cert_errors: bool
-    :type timeout: int
-    :type _connected: bool
-    :type _protocol: IRCProtocol
-    """
 
-    def __init__(self, conn, ignore_cert_errors=True, timeout=300):
+class IRCProtocol(asyncio.Protocol):
+    def __init__(self, conn):
         """
         :type conn: BotConnection
         """
-        self.readable_name = conn.readable_name
-        self.host = conn.server
-        self.port = conn.port
-        self.use_ssl = conn.ssl
         self.loop = conn.loop
-        self.botconn = conn
-
-        if self.use_ssl:
-            self.ssl_context = SSLContext(PROTOCOL_SSLv23)
-            if ignore_cert_errors:
-                self.ssl_context.verify_mode = ssl.CERT_NONE
-            else:
-                self.ssl_context.verify_mode = ssl.CERT_REQUIRED
-        else:
-            self.ssl_context = None
-
-        self.timeout = timeout
-        # Stores if we're connected
-        self._connected = False
-        # transport and protocol
-        self._transport = None
-        self._protocol = None
-
-    def describe_server(self):
-        if self.use_ssl:
-            return "+{}:{}".format(self.host, self.port)
-        else:
-            return "{}:{}".format(self.host, self.port)
-
-    @asyncio.coroutine
-    def connect(self):
-        """
-        Connects to the irc server
-        """
-        if self._connected:
-            logger.info("[{}] Reconnecting".format(self.readable_name))
-            self._transport.close()
-        else:
-            self._connected = True
-            logger.info("[{}] Connecting".format(self.readable_name))
-
-        self._transport, self._protocol = yield from self.loop.create_connection(
-            lambda: IRCProtocol(self), host=self.host, port=self.port, ssl=self.ssl_context,
-        )
-
-    @asyncio.coroutine
-    def send(self, line):
-        """
-        Sends a raw IRC line to the connected server. If we aren't currently connected to the server, this method will
-        pause until we connect.
-        :param line: Line to send
-        """
-        yield from self._protocol.send(line)
-
-    def close(self):
-        if not self._connected:
-            return
-        self._transport.close()
-        self._connected = False
-
-
-class IRCProtocol(asyncio.Protocol):
-    def __init__(self, ircconn):
-        """
-        :type ircconn: IRCConnection
-        """
-        self.loop = ircconn.loop
-        self.readable_name = ircconn.readable_name
-        self.describe_server = lambda: ircconn.describe_server()
-        self.botconn = ircconn.botconn
-        self.bot = ircconn.botconn.bot
+        self.readable_name = conn.readable_name
+        self.describe_server = lambda: conn.describe_server()
+        self.conn = conn
+        self.bot = conn.bot
         # input buffer
         self._input_buffer = b""
         # connected
@@ -296,14 +248,14 @@ class IRCProtocol(asyncio.Protocol):
             # we've been closed intentionally, so don't reconnect
             return
         logger.exception("[{}] Connection lost.".format(self.readable_name))
-        asyncio.async(self.botconn.connect(), loop=self.loop)
+        asyncio.async(self.conn.connect(), loop=self.loop)
 
     def eof_received(self):
         self._connected = False
         # create a new connected_future for when we are connected.
         self._connected_future = asyncio.Future()
         logger.info("[{}] EOF received.".format(self.readable_name))
-        asyncio.async(self.botconn.connect(), loop=self.loop)
+        asyncio.async(self.conn.connect(), loop=self.loop)
         return True
 
     @asyncio.coroutine
@@ -376,9 +328,8 @@ class IRCProtocol(asyncio.Protocol):
 
             # Set up parsed message
             # TODO: Do we really want to send the raw `prefix` and `command_params` here?
-            event = BaseEvent(conn=self.botconn, irc_raw=line, irc_prefix=prefix, irc_command=command,
-                              irc_paramlist=command_params, content=content, nick=nick, user=user, host=host,
-                              mask=mask)
+            event = BaseEvent(bot=self.bot, conn=self.conn, content=content, nick=nick, user=user, host=host, mask=mask,
+                              irc_raw=line, irc_prefix=prefix, irc_command=command, irc_paramlist=command_params)
 
             # handle the message, async
             asyncio.async(self.bot.process(event))
-- 
2.0.0

