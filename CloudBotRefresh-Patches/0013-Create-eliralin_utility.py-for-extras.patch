From d434a55785d8d22db55f63cb0a813dbac3315d8d Mon Sep 17 00:00:00 2001
From: Dabo Ross <daboross@daboross.net>
Date: Mon, 13 Jan 2014 23:19:10 -0800
Subject: [PATCH] Create eliralin_utility.py for extras


diff --git a/modules/eliralin_utility.py b/modules/eliralin_utility.py
new file mode 100644
index 0000000..7314659
--- /dev/null
+++ b/modules/eliralin_utility.py
@@ -0,0 +1,133 @@
+from random import random
+import socket
+import sys
+import traceback
+
+from util import hook, web
+
+
+@hook.command(["josephus", "jose"])
+def josephus(text):
+    """jose [size] [every x] [starting person] - Calculates who dies last """
+    split = text.split()
+    if len(split) != 3:
+        return "Not enough / too many arguments. {}".format(len(split))
+    size, every_x, current = [int(x) for x in split]
+    alive, till_kill = [True] * size, 0
+    while True:
+        if alive[current]:
+            if sum(alive) == 1:
+                break
+            elif till_kill == 0:
+                alive[current] = False
+                till_kill = every_x - 1
+            else:
+                till_kill -= 1
+        current += 1 if current < size - 1 else 1 - size
+    return "Josephus should be at position {} to survive.".format(current)
+
+
+@hook.regex("(?i)(^ )*pets Eliralin *$")
+def pet(action, nick):
+    r = random()
+    if r > 0.7:
+        action("huggles {}".format(nick))
+
+
+@hook.command(["hug", "huggle"])
+def huggle(text, action, nick):
+    if text:
+        action("huggles {}".format(text))
+    else:
+        action("huggles {}".format(nick))
+
+
+@hook.command()
+def colors(text):
+    if text:
+        intinp = int(text)
+        if intinp > 70:
+            return "Please use a number smaller than or equal to 70"
+        forrange = range(intinp)
+    else:
+        forrange = range(30)
+    result = ""
+    for i in forrange if text else range(30):
+        result += "\x03{0:02d} {0}".format(i)
+    return result
+
+
+@hook.command(permissions=["adminonly"])
+def tree(text, message, notice):
+    """tree [type] [text] - Tree text"""
+    type_input = text.split(None, 1)
+    if len(type_input) < 2:
+        notice("tree [type] [text] - Tree text")
+        return
+    tree_type = type_input[0]
+    if tree_type == "1":
+        func = lambda c: c[1:-1]
+    elif tree_type == "2":
+        func = lambda c: c[2:]
+    elif tree_type == "3":
+        func = lambda c: c[:-2]
+    else:
+        return "Invalid tree type '{}'.".format(tree_type)
+    current = type_input[1]
+    spaces = 7
+    while len(current) > 0:
+        spaces += 1
+        message(spaces * ' ' + current)
+        current = func(current)
+
+    message((spaces - 1) * ' ' + ('----' if len(type_input[1]) % 2 == 0 else '---'))
+
+
+@hook.command(permissions=["permissions"])
+def threaddump():
+    print("Running thread dump")
+    code = []
+    for threadId, stack in sys._current_frames().items():
+        code.append("\n# ThreadID: %s" % threadId)
+        for filename, lineno, name, line in traceback.extract_stack(stack):
+            code.append('File: "%s", line %d, in %s' % (filename, lineno, name))
+            if line:
+                code.append("  %s" % (line.strip()))
+    return "Thread dump located at {}".format(web.haste("\n".join(code), ext='txt'))
+
+
+@hook.command
+def dns(text):
+    """dns [domain] - Resolves the IP of a domain"""
+    try:
+        socket.setdefaulttimeout(5)
+        ip = None
+        for info in socket.getaddrinfo(text, 80, 0, 0, socket.SOL_TCP):
+            print(info)
+            if ip is None:
+                ip = info[-1][0]
+            else:
+                ip = "{}, {}".format(ip, info[-1][0])
+        return "{} resolves to {}".format(text, ip)
+    except socket.gaierror:
+        return "Resolve Failed!"
+
+
+@hook.command
+def rdns(inp):
+    """rdns [ip] - Resolves the hostname of an IP"""
+    try:
+        socket.setdefaulttimeout(5)
+        domain = socket.gethostbyaddr(inp)[0]
+        return "{} resolves to {}".format(inp, domain)
+    except socket.gaierror:
+        return "Resolve Failed!"
+
+
+@hook.command("unicode")
+def unicodecommand(inp, reply):
+    try:
+        return "'{}'".format(chr(int(inp)))
+    except ValueError:
+        reply("Failed")
+        raise
-- 
1.9.2

