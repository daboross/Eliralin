From 35ad95696b6167e6b09f417332045043f2c1bab5 Mon Sep 17 00:00:00 2001
From: Dabo Ross <daboross@daboross.net>
Date: Sat, 5 Apr 2014 21:56:53 -0700
Subject: [PATCH] Various changes


diff --git a/cloudbot.py b/cloudbot.py
index f567315..906ca91 100755
--- a/cloudbot.py
+++ b/cloudbot.py
@@ -1,11 +1,17 @@
-#!/usr/bin/env python
-from core import bot
-
+#!/usr/bin/env python3
 import os
 import sys
 import time
 import signal
 
+from core import bot
+
+
+
+
+
+
+
 # check python version 
 if sys.version_info < (3, 2, 0):
     print("CloudBot3 requires Python 3.2 or newer.")
@@ -16,37 +22,50 @@ os.chdir(sys.path[0] or '.')  # do stuff relative to the install directory
 
 # this is not the code you are looking for
 if os.path.exists(os.path.abspath('lib')):
-    sys.path += ['lib'] 
+    sys.path += ['lib']
 
 print('CloudBot3 <http://git.io/cloudbotirc>')
 
 
-def exit_gracefully(signum, frame):
-    # this doesn't really work at all
-    cloudbot.stop()
-
-    # restore the original handler so if they do it again it triggers
-    signal.signal(signal.SIGINT, original_sigint)
-
-# store the original SIGINT handler
-original_sigint = signal.getsignal(signal.SIGINT)
-signal.signal(signal.SIGINT, exit_gracefully)
-
-# create a bot master and start it
-cloudbot = bot.CloudBot()
-cloudbot.start()
-
-# watch to see if the bot stops running or needs a restart
-while True:
-    if cloudbot.running:
-        time.sleep(.1)
-    else:
-        if cloudbot.do_restart:
-            # create a new bot thread and start it
-            # Todo: Make this work
-            del cloudbot
-            cloudbot = bot.Bot()
-            cloudbot.start()
-            continue
-        else:
-            break
\ No newline at end of file
+class CloudBotWrapper():
+    def __init__(self):
+        # create the master cloudbot
+        self.cloudbot = bot.CloudBot()
+
+        self.original_sigint = None
+
+    def set_signals(self):
+        # store the original SIGINT handler
+        self.original_sigint = signal.getsignal(signal.SIGINT)
+        signal.signal(signal.SIGINT, self.exit_gracefully)
+
+    def exit_gracefully(self, signum, frame):
+        # this doesn't really work at all
+        self.cloudbot.stop()
+
+        # restore the original handler so if they do it again it triggers
+        signal.signal(signal.SIGINT, self.original_sigint)
+
+    def run(self):
+        # start the bot master
+        self.cloudbot.start()
+
+        # watch to see if the bot stops running or needs a restart
+        while True:
+            if self.cloudbot.running:
+                time.sleep(.1)
+            else:
+                if self.cloudbot.do_restart:
+                    # create a new bot thread and start it
+                    del self.cloudbot
+                    self.cloudbot = bot.CloudBot()
+                    self.cloudbot.start()
+                    continue
+                else:
+                    break
+
+
+if __name__ == "__main__":
+    main_wrapper = CloudBotWrapper()
+    main_wrapper.set_signals()
+    main_wrapper.run()
\ No newline at end of file
diff --git a/core/bot.py b/core/bot.py
index 95d0dfe..9364b7d 100644
--- a/core/bot.py
+++ b/core/bot.py
@@ -15,12 +15,17 @@ from core.loader import PluginLoader
 
 
 def clean_name(n):
-    """strip all spaces and capitalization"""
+    """strip all spaces and capitalization
+    :type n: str
+    :rtype : str
+    """
     return re.sub('[^A-Za-z0-9_]+', '', n.replace(" ", "_"))
 
 
 def get_logger():
-    """create and return a new logger object"""
+    """create and return a new logger object
+    :rtype : logging.Logger
+    """
     # create logger
     logger = logging.getLogger("cloudbot")
     logger.setLevel(logging.DEBUG)
@@ -53,17 +58,36 @@ class CloudBot(threading.Thread):
         self.running = True
         self.do_restart = False
 
-        # stores each instance of the
-        self.instances = []
+        # stores each bot server connection
+        self.server_connections = []
 
-        # set up config and logging
-        self.setup()
+        # set up logging
+        self.logger = get_logger()
+        self.logger.debug("Logging system initalised.")
+
+        # declare and create data folder
+        self.data_dir = os.path.abspath('data')
+        if not os.path.exists(self.data_dir):
+            self.logger.debug("Data folder not found, creating.")
+            os.mkdir(self.data_dir)
+
+        # set up config
+        self.config = config.Config(self)
+        self.logger.debug("Config system initalised.")
+
+        # setup db
+        engine = create_engine('sqlite:///cloudbot.db')
+        db_factory = sessionmaker(bind=engine)
+        self.db_session = scoped_session(db_factory)
+        self.logger.debug("Database system initalised.")
+
+        # Bot initialisation complete
         self.logger.debug("Bot setup completed.")
 
         # start bot instances
-        self.create()
+        self.create_connections()
 
-        for instance in self.instances:
+        for instance in self.server_connections:
             instance.permissions = PermissionManager(self, instance)
 
         # run plugin loader
@@ -89,7 +113,7 @@ class CloudBot(threading.Thread):
         """recieves input from the IRC engine and processes it"""
         self.logger.info("Starting main thread.")
         while self.running:
-            for instance in self.instances:
+            for instance in self.server_connections:
                 try:
                     incoming = instance.parsed_queue.get_nowait()
                     if incoming == StopIteration:
@@ -101,35 +125,12 @@ class CloudBot(threading.Thread):
                     pass
 
             # if no messages are in the incoming queue, sleep
-            while self.running and all(i.parsed_queue.empty() for i in self.instances):
+            while self.running and all(connection.parsed_queue.empty() for connection in self.server_connections):
                 time.sleep(.1)
 
-    def setup(self):
-        """create the logger and config objects"""
-        # logging
-        self.logger = get_logger()
-        self.logger.debug("Logging system initalised.")
-
-        # data folder
-        self.data_dir = os.path.abspath('persist')
-        if not os.path.exists(self.data_dir):
-            self.logger.debug("Data folder not found, creating.")
-            os.mkdir(self.data_dir)
-
-        # config
-        self.config = config.Config(self)
-        self.logger.debug("Config system initalised.")
-
-        # db
-        engine = create_engine('sqlite:///cloudbot.db')
-        db_factory = sessionmaker(bind=engine)
-        self.db_session = scoped_session(db_factory)
-        self.logger.debug("Database system initalised.")
-
-    def create(self):
-        """ Create a BotInstance for all the networks defined in the config """
-        for conf in self.config['instances']:
-
+    def create_connections(self):
+        """ Create a BotConnection for all the networks defined in the config """
+        for conf in self.config['connections']:
             # strip all spaces and capitalization from the connection name
             name = clean_name(conf['name'])
             nick = conf['nick']
@@ -138,12 +139,11 @@ class CloudBot(threading.Thread):
 
             self.logger.debug("Creating BotInstance for {}.".format(name))
 
-            self.instances.append(irc.BotInstance(name, server, nick, config=conf,
-                                  port=port, logger=self.logger, channels=conf['channels'],
-                                  ssl=conf['connection'].get('ssl', False)))
+            self.server_connections.append(irc.BotConnection(name, server, nick, config=conf,
+                                                             port=port, logger=self.logger, channels=conf['channels'],
+                                                             ssl=conf['connection'].get('ssl', False)))
             self.logger.debug("({}) Created connection.".format(name))
 
-
     def stop(self, reason=None):
         """quits all networks and shuts the bot down"""
         self.logger.info("Stopping bot.")
@@ -154,7 +154,7 @@ class CloudBot(threading.Thread):
         self.loader.stop()
         self.logger.debug("Stopping plugin loader.")
 
-        for connection in self.connections:
+        for connection in self.server_connections:
             self.logger.debug("({}) Closing connection.".format(connection.name))
 
             if reason:
@@ -172,4 +172,17 @@ class CloudBot(threading.Thread):
     def restart(self, reason=None):
         """shuts the bot down and restarts it"""
         self.do_restart = True
-        self.stop(reason)
\ No newline at end of file
+        self.stop(reason)
+
+    # noinspection PyMethodMayBeStatic
+    def get_command_prefixes(self, inp):
+        return ""
+        # db = self.db_session
+        #
+        # db.execute("CREATE TABLE IF NOT EXISTS prefixes(channel, prefix, UNIQUE(channel, prefix) ON CONFLICT REPLACE)")
+        # db.commit()
+        # row = db.execute("SELECT prefix FROM prefixes WHERE channel = ?", [inp.chan]).fetchall()
+        # prefixes = ""
+        # for prefix in row:
+        #     prefixes += re.escape(prefix[0])
+        # return prefixes
diff --git a/core/config.py b/core/config.py
index 9d8d010..5a6a0ec 100644
--- a/core/config.py
+++ b/core/config.py
@@ -9,6 +9,10 @@ from watchdog.tricks import Trick
 
 class Config(dict):
     def __init__(self, bot, *args, **kwargs):
+        """
+
+        :type bot: core.bot.CloudBot
+        """
         self.filename = "config.json"
         self.path = os.path.abspath(self.filename)
         self.bot = bot
@@ -18,10 +22,12 @@ class Config(dict):
         # populate self with config data
         self.load_config()
 
+        # Declaring here, to be assigned later
+        self.observer = None
+        self.event_handler = None
         # start watcher
         self.watcher()
 
-
     def load_config(self):
         """(re)loads the bot config from the config file"""
         if not os.path.exists(self.path):
@@ -38,8 +44,8 @@ class Config(dict):
             self.logger.info("Config loaded from file.")
 
         # reload permissions
-        if self.bot.instances:
-            for instance in self.bot.instances:
+        if self.bot.server_connections:
+            for instance in self.bot.server_connections:
                 instance.permissions.reload()
 
     def save_config(self):
diff --git a/core/db.py b/core/db.py
deleted file mode 100644
index 30acb35..0000000
--- a/core/db.py
+++ /dev/null
@@ -1,39 +0,0 @@
-import os
-import sqlite3
-import _thread
-import re
-
-threaddbs = {}
-
-
-def get_db_connection(conn, name=''):
-    """returns an sqlite3 connection to a persistent database"""
-
-    if not name:
-        name = '{}.db'.format(conn.name)
-
-    threadid = _thread.get_ident()
-    if name in threaddbs and threadid in threaddbs[name]:
-        return threaddbs[name][threadid]
-    filename = os.path.join(bot.data_dir, name)
-
-    db = sqlite3.connect(filename, timeout=10)
-    if name in threaddbs:
-        threaddbs[name][threadid] = db
-    else:
-        threaddbs[name] = {threadid: db}
-    return db
-
-
-def get_command_prefixes(inp):
-    db = get_db_connection(inp.conn)
-    db.execute("CREATE TABLE IF NOT EXISTS prefixes(channel, prefix, UNIQUE(channel, prefix) ON CONFLICT REPLACE)")
-    db.commit()
-    row = db.execute("SELECT prefix FROM prefixes WHERE channel = ?", [inp.chan]).fetchall()
-    prefixes = ""
-    for prefix in row:
-        prefixes += re.escape(prefix[0])
-    return prefixes
-
-
-bot.get_db_connection = get_db_connection
diff --git a/core/irc.py b/core/irc.py
index 88357d5..2ae6358 100644
--- a/core/irc.py
+++ b/core/irc.py
@@ -4,8 +4,6 @@ import time
 import threading
 import queue
 
-from core import permissions
-
 from ssl import wrap_socket, CERT_NONE, CERT_REQUIRED, SSLError
 
 irc_prefix_rem = re.compile(r'(.*?) (.*?) (.*)').match
@@ -29,6 +27,7 @@ def censor(text):
 
 class ReceiveThread(threading.Thread):
     """receives messages from IRC and puts them in the input_queue"""
+
     def __init__(self, sock, input_queue, timeout):
         self.input_buffer = b""
         self.input_queue = input_queue
@@ -87,14 +86,15 @@ class SSLReceiveThread(ReceiveThread):
         return SSLError
 
     def handle_receive_exception(self, error, last_timestamp):
-       # this is terrible
+        # this is terrible
         if not "timed out" in error.args[0]:
-            raise
+            raise error
         return ReceiveThread.handle_receive_exception(self, error, last_timestamp)
 
 
 class SendThread(threading.Thread):
     """sends messages from output_queue to IRC"""
+
     def __init__(self, sock, conn_name, output_queue):
         self.output_buffer = b""
         self.output_queue = output_queue
@@ -115,6 +115,7 @@ class SendThread(threading.Thread):
 
 class ParseThread(threading.Thread):
     """parses messages from input_queue and puts them in parsed_queue"""
+
     def __init__(self, input_queue, output_queue, parsed_queue):
         self.input_queue = input_queue  # lines that were received
         self.output_queue = output_queue  # lines to be sent out
@@ -141,7 +142,7 @@ class ParseThread(threading.Thread):
             nick, user, host = irc_netmask_rem(prefix).groups()
             mask = nick + "!" + user + "@" + host
             paramlist = irc_param_ref(params)
-            lastparam = "" 
+            lastparam = ""
             if paramlist:
                 if paramlist[-1].startswith(':'):
                     paramlist[-1] = paramlist[-1][1:]
@@ -157,6 +158,7 @@ class ParseThread(threading.Thread):
 
 class IRCConnection(object):
     """handles an IRC connection"""
+
     def __init__(self, name, host, port, input_queue, output_queue):
         self.output_queue = output_queue  # lines to be sent out
         self.input_queue = input_queue  # lines that were received
@@ -202,13 +204,32 @@ class SSLIRCConnection(IRCConnection):
                            CERT_REQUIRED)
 
 
-class BotInstance(object):
-    """ A BotInstance represents each connection the bot makes to an IRC server """
-
-    def __init__(self, name, server, nick, port=6667, ssl=False, logger=None, channels=[], config={}):
+class BotConnection(object):
+    """ A BotConnection represents each connection the bot makes to an IRC server """
+
+    def __init__(self, name, server, nick, port=6667, ssl=False, logger=None, channels=None, config=None):
+        """
+        :type name: str
+        :type server: str
+        :type nick: str
+        :type port: int
+        :type ssl: bool
+        :type logger: logging.Logger
+        :type channels: list
+        :type config: map
+        """
         self.name = name
-        self.channels = channels
-        self.config = config
+
+        if channels is None:
+            self.channels = []
+        else:
+            self.channels = channels
+
+        if config is None:
+            self.config = {}
+        else:
+            self.config = config
+
         self.ssl = ssl
         self.server = server
         self.port = port
@@ -252,34 +273,56 @@ class BotInstance(object):
         self.connection.stop()
 
     def set_pass(self, password):
+        """
+
+        :type password: str
+        """
         if password:
             self.cmd("PASS", [password])
 
     def set_nick(self, nick):
+        """
+        :type nick: str
+        """
         self.cmd("NICK", [nick])
 
     def join(self, channel):
-        """ makes the bot join a channel """
+        """ makes the bot join a channel
+        :type channel: str
+        """
         self.send("JOIN {}".format(channel))
         if channel not in self.channels:
             self.channels.append(channel)
 
     def part(self, channel):
-        """ makes the bot leave a channel """
+        """ makes the bot leave a channel
+        :type channel: str
+        """
         self.cmd("PART", [channel])
         if channel in self.channels:
             self.channels.remove(channel)
 
     def msg(self, target, text):
-        """ makes the bot send a PRIVMSG to a target  """
+        """ makes the bot send a PRIVMSG to a target
+        :type text: str
+        :type target: str
+        """
         self.cmd("PRIVMSG", [target, text])
 
     def ctcp(self, target, ctcp_type, text):
-        """ makes the bot send a PRIVMSG CTCP to a target """
+        """ makes the bot send a PRIVMSG CTCP to a target
+        :type ctcp_type: str
+        :type text: str
+        :type target: str
+        """
         out = "\x01{} {}\x01".format(ctcp_type, text)
         self.cmd("PRIVMSG", [target, out])
 
     def cmd(self, command, params=None):
+        """
+        :type command: str
+        :type params: list
+        """
         if params:
             params[-1] = ':' + params[-1]
             self.send("{} {}".format(command, ' '.join(params)))
@@ -287,6 +330,9 @@ class BotInstance(object):
             self.send(command)
 
     def send(self, string):
+        """
+        :type string: str
+        """
         try:
             self.logger.info("{} >> {}".format(self.name.upper(), string))
         except:
diff --git a/core/main.py b/core/main.py
index aecc5be..8c2b675 100644
--- a/core/main.py
+++ b/core/main.py
@@ -1,10 +1,8 @@
 import _thread
-import traceback
+import inspect
 import queue
 import re
 
-from sqlalchemy.orm import scoped_session
-
 _thread.stack_size(1024 * 512)  # reduce vm size
 
 
@@ -26,7 +24,7 @@ class Input(dict):
             if target == nick:
                 conn.msg(target, message)
             else:
-                conn.msg(target, u"{}, {}".format(nick, message))
+                conn.msg(target, "{}, {}".format(nick, message))
 
         def action(message, target=chan):
             """sends an action to the current channel/user or a specific channel/user"""
@@ -48,28 +46,62 @@ class Input(dict):
 
     # make dict keys accessible as attributes
     def __getattr__(self, key):
-        return self[key]
+        return self.get(key)
 
     def __setattr__(self, key, value):
         self[key] = value
 
 
 def run(bot, func, input):
+    """
+
+    :type func: func
+    :type bot: core.bot.CloudBot
+    :type input: Input
+    """
     uses_db = True
     # TODO: change to bot.get_db_session()
-    print(input)
-    if 'text' not in input:
+
+    if not 'text' in input:
         input.text = input.paraml
 
+    if not 'input' in input:
+        input.input = input
+
     if uses_db:
         # create SQLAlchemy session
         bot.logger.debug("Opened DB session for: {}".format(func._filename))
         input.db = input.bot.db_session()
 
+    # parameters is an array of
+    parameters = []
+    named_parameters = {}
+    specifications = inspect.getargspec(func)
+    required_args = specifications[0]
+    default_args = specifications[3]
+    if len(required_args) - len(default_args) == 1:
+        # The function is using the old format, with all arguments with defaults except for 'text'
+        # Assume that the funct want the first non-default arg to be 'input'
+        parameters.append(input.param1)
+        required_args = required_args[1:]  # Trim the first argument, as it's been assigned as a non-named parameter
+
+        for required_arg in required_args:
+            # Assign the rest of the named parameters to values from input
+            value = getattr(input, required_arg)
+
+            named_parameters[required_arg] = value
+    else:
+        # We're assuming that this function is using the new format
+        # We're ignoring all parameters with default values, and treating all other parameters as named
+        # TODO: Implement this
+        print("Warning, ignoring function which doesn't fit arg spec. Argument specs: {}".format(specifications))
+        pass
+    out = None
     try:
-        out = func(input, input.conn)
+        out = func(*parameters, **named_parameters)
     except:
         bot.logger.exception("Error in plugin {}:".format(func._filename))
+        bot.logger.info("Parameters used: {}, named parameters used: {}".format(parameters, named_parameters))
         return
     finally:
         if uses_db:
@@ -81,6 +113,10 @@ def run(bot, func, input):
 
 
 def do_sieve(sieve, bot, input, func, type, args):
+    """
+
+    :type bot: core.bot.CloudBot
+    """
     try:
         return sieve(bot, input, func, type, args)
     except Exception:
@@ -107,7 +143,6 @@ class Handler(object):
 
             run(self.bot, self.func, input)
 
-
     def stop(self):
         self.input_queue.put(StopIteration)
 
@@ -116,12 +151,18 @@ class Handler(object):
 
 
 def dispatch(bot, input, kind, func, args, autohelp=False):
+    """
+
+
+    :type bot: core.bot.CloudBot
+    :type input: Input
+    """
     for sieve, in bot.plugins['sieve']:
         input = do_sieve(sieve, bot, input, func, kind, args)
         if input is None:
             return
 
-    if not (not autohelp or not args.get('autohelp', True) or input.inp or not (func.__doc__ is not None)):
+    if autohelp and args.get('autohelp', True) and not input.inp and func.__doc__ is not None:
         input.notice(input.conn.config["command_prefix"] + func.__doc__)
         return
 
@@ -155,9 +196,9 @@ def main(bot, conn, out):
     if inp.command == 'PRIVMSG':
         # COMMANDS
         if inp.chan == inp.nick:  # private message, no command prefix
-            prefix = '^(?:[{}{}]?|'.format(command_prefix, get_command_prefixes(inp))
+            prefix = '^(?:[{}{}]?|'.format(command_prefix, bot.get_command_prefixes(inp))
         else:
-            prefix = '^(?:[{}{}]|'.format(command_prefix, get_command_prefixes(inp))
+            prefix = '^(?:[{}{}]|'.format(command_prefix, bot.get_command_prefixes(inp))
 
         command_re = prefix + inp.conn.nick
         command_re += r'[,;:]+\s+)(\w+)(?:$|\s+)(.*)'
diff --git a/plugins/correction.py b/plugins/correction.py
index 9e66371..4beedf7 100644
--- a/plugins/correction.py
+++ b/plugins/correction.py
@@ -1,63 +1,63 @@
-from util import hook
-
-import re
-
-<<<<<<< HEAD
-@hook.regex(r'^(s|S)/.*/.*/\S*$')
-def correction(inp, message=None, input=None, notice=None, db=None):
-    splitinput = input.msg.split("/")
-    if splitinput[3]:
-        nick = splitinput[3]
-    else:
-        nick = input.nick
-    last_message = db.execute("select name, quote from seen_user where name"
-                              " like :nick and chan = :chan", {'nick': nick.lower(),
-                                                               'chan': input.chan.lower()}).fetchone()
-
-    if last_message:
-        splitinput = input.msg.split("/")
-        find = splitinput[1]
-        replace = splitinput[2]
-        if find in last_message[1]:
-            if "\x01ACTION" in last_message[1]:
-                msg = last_message[1].replace("\x01ACTION ", "/me ").replace("\x01", "")
-            else:
-                msg = last_message[1]
-            message(u"Correction, <{}> {}".format(nick, msg.replace(find, "\x02" + replace + "\x02")))
-        else:
-            notice(u"{} can't be found in your last message".format(find))
-=======
-CORRECTION_RE = r'^(s|S)/.*/.*/?\S*$'
-
-
-@hook.regex(CORRECTION_RE)
-def correction(match, input=None, conn=None, message=None):
-    split = input.msg.split("/")
-
-    if len(split) == 4:
-        nick = split[3].lower()
->>>>>>> develop
-    else:
-        nick = None
-
-    find = split[1]
-    replace = split[2]
-
-    for item in conn.history[input.chan].__reversed__():
-        name, timestamp, msg = item
-        if msg.startswith("s/"):
-            # don't correct corrections, it gets really confusing
-            continue
-        if nick:
-            if nick != name.lower():
-                continue
-        if find in msg:
-            if "\x01ACTION" in msg:
-                msg = msg.replace("\x01ACTION ", "/me ").replace("\x01", "")
-            message(u"Correction, <{}> {}".format(name, msg.replace(find, "\x02" + replace + "\x02")))
-            return
-        else:
-            continue
-
-    return u"Did not find {} in any recent messages.".format(find)
-
+# from util import hook
+#
+# import re
+#
+# <<<<<<< HEAD
+# @hook.regex(r'^(s|S)/.*/.*/\S*$')
+# def correction(inp, message=None, input=None, notice=None, db=None):
+#     splitinput = input.msg.split("/")
+#     if splitinput[3]:
+#         nick = splitinput[3]
+#     else:
+#         nick = input.nick
+#     last_message = db.execute("select name, quote from seen_user where name"
+#                               " like :nick and chan = :chan", {'nick': nick.lower(),
+#                                                                'chan': input.chan.lower()}).fetchone()
+#
+#     if last_message:
+#         splitinput = input.msg.split("/")
+#         find = splitinput[1]
+#         replace = splitinput[2]
+#         if find in last_message[1]:
+#             if "\x01ACTION" in last_message[1]:
+#                 msg = last_message[1].replace("\x01ACTION ", "/me ").replace("\x01", "")
+#             else:
+#                 msg = last_message[1]
+#             message(u"Correction, <{}> {}".format(nick, msg.replace(find, "\x02" + replace + "\x02")))
+#         else:
+#             notice(u"{} can't be found in your last message".format(find))
+# =======
+# CORRECTION_RE = r'^(s|S)/.*/.*/?\S*$'
+#
+#
+# @hook.regex(CORRECTION_RE)
+# def correction(match, input=None, conn=None, message=None):
+#     split = input.msg.split("/")
+#
+#     if len(split) == 4:
+#         nick = split[3].lower()
+# >>>>>>> develop
+#     else:
+#         nick = None
+#
+#     find = split[1]
+#     replace = split[2]
+#
+#     for item in conn.history[input.chan].__reversed__():
+#         name, timestamp, msg = item
+#         if msg.startswith("s/"):
+#             # don't correct corrections, it gets really confusing
+#             continue
+#         if nick:
+#             if nick != name.lower():
+#                 continue
+#         if find in msg:
+#             if "\x01ACTION" in msg:
+#                 msg = msg.replace("\x01ACTION ", "/me ").replace("\x01", "")
+#             message(u"Correction, <{}> {}".format(name, msg.replace(find, "\x02" + replace + "\x02")))
+#             return
+#         else:
+#             continue
+#
+#     return u"Did not find {} in any recent messages.".format(find)
+#
diff --git a/plugins/eliralin_teamcity.py b/plugins/eliralin_teamcity.py
index 6a1f83c..07c8e8f 100644
--- a/plugins/eliralin_teamcity.py
+++ b/plugins/eliralin_teamcity.py
@@ -1,13 +1,14 @@
 from xml.etree.ElementTree import ParseError
 import traceback
 from xml.etree import ElementTree
+import time
+
 import requests
 from requests.auth import HTTPBasicAuth
 
-import time
-
 from util import hook
 
+
 teamcity_url = "http://ci.daboross.net/ci"
 
 
@@ -33,7 +34,7 @@ class ProjectDatabase:
         try:
             return ElementTree.fromstring(data)
         except ParseError:
-            print "Error loading {} ({})".format(url, data)
+            print("Error loading {} ({})".format(url, data))
             raise
 
     def load_key(self, bot):
@@ -44,7 +45,7 @@ class ProjectDatabase:
                 self.password = api_keys.get("teamcity_password")
                 self.loaded_key = True
             else:
-                print "Warning, couldn't find teamcity api key"
+                print("Warning, couldn't find teamcity api key")
 
     def reload_database(self):
         self.reload_timestamp = time.time()
diff --git a/plugins/eliralin_utility.py b/plugins/eliralin_utility.py
index c37a455..0934b98 100644
--- a/plugins/eliralin_utility.py
+++ b/plugins/eliralin_utility.py
@@ -101,7 +101,7 @@ def tree(inp, message=None, notice=None):
 
 @hook.command
 def threaddump(inp):
-    print "Running thread dump"
+    print("Running thread dump")
     code = []
     for threadId, stack in sys._current_frames().items():
         code.append("\n# ThreadID: %s" % threadId)
@@ -119,7 +119,7 @@ def dns(inp):
         socket.setdefaulttimeout(5)
         ip = None
         for info in socket.getaddrinfo(inp, 80, 0, 0, socket.SOL_TCP):
-            print info
+            print(info)
             if ip is None:
                 ip = info[-1][0]
             else:
@@ -143,7 +143,7 @@ def rdns(inp):
 @hook.command("unicode")
 def unicodecommand(inp, reply=None):
     try:
-        return u"'{}'".format(unichr(int(inp)))
+        return u"'{}'".format(chr(int(inp)))
     except Exception:
         reply("Failed")
         raise
diff --git a/plugins/encrypt.py b/plugins/encrypt.py
index 119e37d..b1be1f0 100644
--- a/plugins/encrypt.py
+++ b/plugins/encrypt.py
@@ -1,12 +1,10 @@
 import os
 import base64
-import json
 import hashlib
 
 from Crypto import Random
 from Crypto.Cipher import AES
-from Crypto.Protocol.KDF import PBKDF2
-
+import Crypto.Protocol.KDF as crypto_kdf
 from util import hook
 
 
@@ -56,7 +54,7 @@ def encrypt(inp, bot=None, db=None, notice=None):
     # generate the key from the password and salt
     password = split[0]
     salt = get_salt(bot)
-    key = PBKDF2(password, salt)
+    key = crypto_kdf.PBKDF2(password, salt)
 
     # generate the IV and encode it to store in the database
     iv = Random.new().read(AES.block_size)
@@ -92,7 +90,7 @@ def decrypt(inp, bot=None, db=None, notice=None):
     # generate the key from the password and salt
     password = split[0]
     salt = get_salt(bot)
-    key = PBKDF2(password, salt)
+    key = crypto_kdf.PBKDF2(password, salt)
 
     text = " ".join(split[1:])
 
diff --git a/plugins/log.py b/plugins/log.py
index a08832f..9b1c694 100644
--- a/plugins/log.py
+++ b/plugins/log.py
@@ -92,6 +92,10 @@ def get_log_fd(dir, server, chan):
 #@hook.singlethread
 @hook.event('*')
 def log(paraml, input=None, bot=None):
+    """
+
+    :type bot: core.bot.CloudBot
+    """
     timestamp = gmtime(timestamp_format)
 
     fd = get_log_fd(bot.data_dir, input.server, 'raw')
diff --git a/plugins/minecraft_status.py b/plugins/minecraft_status.py
index d9e416d..7e884fe 100644
--- a/plugins/minecraft_status.py
+++ b/plugins/minecraft_status.py
@@ -2,12 +2,12 @@ import json
 
 from util import hook, http
 
-green_prefix = u"\x02\x0f"
-green_suffix = u": \x033\x02\u2714"
-yellow_prefix = u"\x02\x0f"
-yellow_suffix = u": \x037\x02\u26A0"
-red_prefix = u"\x02\x0f"
-red_suffix = u": \x034\x02\u2716"
+green_prefix = "\x02\x0f"
+green_suffix = ": \x033\x02\u2714"
+yellow_prefix = "\x02\x0f"
+yellow_suffix = ": \x037\x02\u26A0"
+red_prefix = "\x02\x0f"
+red_suffix = ": \x034\x02\u2716"
 
 
 @hook.command(autohelp=False)
@@ -34,9 +34,9 @@ def mcstatus(inp):
             server = "MC|{}".format(server[:-14].capitalize())
 
         if status == "green":
-            servers.append(u"{}{}{}".format(green_prefix, server, green_suffix))
+            servers.append("{}{}{}".format(green_prefix, server, green_suffix))
         elif status == "yellow":
-            servers.append(u"{}{}{}".format(yellow_prefix, server, yellow_suffix))
+            servers.append("{}{}{}".format(yellow_prefix, server, yellow_suffix))
         else:
-            servers.append(u"{}{}{}".format(red_prefix, server, red_suffix))
+            servers.append("{}{}{}".format(red_prefix, server, red_suffix))
     return "  ".join(servers)
diff --git a/plugins/recipe.py b/plugins/recipe.py
index 6fa4aea..bec27da 100644
--- a/plugins/recipe.py
+++ b/plugins/recipe.py
@@ -11,17 +11,17 @@ RANDOM_URL = SEARCH_URL + "/surprise"
 # set this to true to censor this plugin!
 censor = True
 phrases = [
-    u"EAT SOME FUCKING \x02{}\x02",
-    u"YOU WON'T NOT MAKE SOME FUCKING \x02{}\x02",
-    u"HOW ABOUT SOME FUCKING \x02{}?\x02",
-    u"WHY DON'T YOU EAT SOME FUCKING \x02{}?\x02",
-    u"MAKE SOME FUCKING \x02{}\x02",
-    u"INDUCE FOOD COMA WITH SOME FUCKING \x02{}\x02"
-    u"CLASSILY PARTAKE IN SOME FUCKING \x02{}\x02",
-    u"COOK UP SOME FUCKING \x02{}\x02",
-    u"CURE YOUR MOUTH'S POST TRAUMATIC STRESS DISORDER WITH SOME FUCKING \x02{}\x02",
-    u"PROCURE SOME CHILD LABOR TO COOK UP SOME FUCKING \x02{}\x02",
-    u"YOUR INDECISION IS FAR LESS APPETIZING THAN SOME FUCKING \x02{}\x02"
+    "EAT SOME FUCKING \x02{}\x02",
+    "YOU WON'T NOT MAKE SOME FUCKING \x02{}\x02",
+    "HOW ABOUT SOME FUCKING \x02{}?\x02",
+    "WHY DON'T YOU EAT SOME FUCKING \x02{}?\x02",
+    "MAKE SOME FUCKING \x02{}\x02",
+    "INDUCE FOOD COMA WITH SOME FUCKING \x02{}\x02"
+    "CLASSILY PARTAKE IN SOME FUCKING \x02{}\x02",
+    "COOK UP SOME FUCKING \x02{}\x02",
+    "CURE YOUR MOUTH'S POST TRAUMATIC STRESS DISORDER WITH SOME FUCKING \x02{}\x02",
+    "PROCURE SOME CHILD LABOR TO COOK UP SOME FUCKING \x02{}\x02",
+    "YOUR INDECISION IS FAR LESS APPETIZING THAN SOME FUCKING \x02{}\x02"
 ]
 
 clean_key = lambda i: i.split("#")[1]
@@ -85,7 +85,7 @@ def recipe(inp):
         return "Could not parse recipe: {}".format(e)
 
     name = data["name"].strip()
-    return u"Try eating \x02{}!\x02 - {}".format(name, web.try_isgd(url))
+    return "Try eating \x02{}!\x02 - {}".format(name, web.try_isgd(url))
 
 
 @hook.command(autohelp=False)
@@ -108,4 +108,4 @@ def dinner(inp):
     if censor:
         text = text.replace("FUCK", "F**K")
 
-    return u"{} - {}".format(text, web.try_isgd(url))
\ No newline at end of file
+    return "{} - {}".format(text, web.try_isgd(url))
\ No newline at end of file
diff --git a/plugins/regex_chans.py b/plugins/regex_chans.py
index dec2f2c..d9c902b 100644
--- a/plugins/regex_chans.py
+++ b/plugins/regex_chans.py
@@ -26,12 +26,12 @@ def get_status(db, channel):
 
 
 def set_status(db, channel, status):
-    row = db.execute("REPLACE INTO regexchans (channel, status) VALUES(?, ?)", [channel, status])
+    db.execute("REPLACE INTO regexchans (channel, status) VALUES(?, ?)", [channel, status])
     db.commit()
 
 
 def delete_status(db, channel):
-    row = db.execute("DELETE FROM regexchans WHERE channel = ?", [channel])
+    db.execute("DELETE FROM regexchans WHERE channel = ?", [channel])
     db.commit()
 
 
@@ -53,9 +53,9 @@ def sieve_regex(bot, inp, func, kind, args):
     if kind == 'regex' and inp.chan.startswith("#") and func.__name__ != 'factoid':
         chanstatus = get_status(db, inp.chan)
         if chanstatus != "ENABLED" and (chanstatus == "DISABLED" or not default_enabled):
-            print u"Denying input.raw={}, kind={}, args={} from {}".format(inp.raw, kind, args, inp.chan)
+            print("Denying input.raw={}, kind={}, args={} from {}".format(inp.raw, kind, args, inp.chan))
             return None
-        print u"Allowing input.raw={}, kind={}, args={} from {}".format(inp.raw, kind, args, inp.chan)
+        print("Allowing input.raw={}, kind={}, args={} from {}".format(inp.raw, kind, args, inp.chan))
 
     return inp
 
diff --git a/requirements.txt b/requirements.txt
index 9a1f73e..0884a93 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -1,3 +1,4 @@
+Crypto
 sqlalchemy
 oauth2
 pygeoip
@@ -12,3 +13,6 @@ pygeoip
 BeautifulSoup4
 pycrypto
 requests
+kdf
+pygeoip
+requests
\ No newline at end of file
-- 
1.9.1

