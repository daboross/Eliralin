From ba808f770d86c2ee368bca4feea9625b5007a51f Mon Sep 17 00:00:00 2001
From: Dabo Ross <daboross@daboross.net>
Date: Sat, 19 Apr 2014 14:26:19 -0700
Subject: [PATCH] Experimental plugin manager stuff


diff --git a/core/pluginmanager.py b/core/pluginmanager.py
new file mode 100644
index 0000000..67b9725
--- /dev/null
+++ b/core/pluginmanager.py
@@ -0,0 +1,251 @@
+import inspect
+import os
+import re
+
+from util import hook
+
+
+def find_hooks(code):
+    """
+    :type code: object
+    :rtype: (list[CommandPlugin], list[RegexPlugin], list[EventPlugin], list[SievePlugin])
+    """
+    commands = []
+    regexes = []
+    events = []
+    sieves = []
+    for name, func in code.__dict__.items():
+        if inspect.isfunction(func) and inspect.getmodule(func) == inspect.getmodule(code):
+            # if it's a function, and is in the right module
+            if hasattr(func, "_cloudbot_hook") and isinstance(func._cloudbot_hook, hook._Hook):
+                # if it has cloudbot magic hook
+
+                func_hooks = func._cloudbot_hook
+                assert isinstance(func_hooks, dict)
+                for func_hook in func_hooks.values():
+                    # we just need the values, which are the actual Hooks
+                    # the keys are for the type of hook, but we can tell that anyways
+                    assert func_hook.function == func  # make sure this is the right function
+
+                    if isinstance(func_hook, hook._CommandHook):
+                        commands.append(CommandPlugin(func_hook))
+                    elif isinstance(func_hook, hook._RegexHook):
+                        regexes.append(RegexPlugin(func_hook))
+                    elif isinstance(func_hook, hook._EventHook):
+                        events.append(EventPlugin(func_hook))
+                    elif isinstance(func_hook, hook._SieveHook):
+                        sieves.append(SievePlugin(hook._SieveHook))
+                    else:
+                        print("Warning, unknown plugin: {}".format(func_hook))
+
+    return commands, regexes, events, sieves
+
+
+class PluginManager:
+    """
+    plugins is dict from file name to FilePlugin
+
+    :type bot: core.bot.CloudBot
+    :type plugins: dict[str, FilePlugin]
+    :type commands_by_alias: dict[str, CommandPlugin]
+    :type event_plugins_by_event: dict[str, list[EventPlugin]]
+    :type catch_all_events: list[EventPlugin]
+    :type regex_plugins: list[(re.__Regex, RegexPlugin)]
+    :type sieves: list[SievePlugin]
+    """
+
+    def __init__(self, bot):
+        """
+        :type bot: core.bot.CloudBot
+        """
+        self.bot = bot
+
+        self.plugins = {}
+        self.commands_by_alias = {}
+        self.event_plugins_by_event = {}
+        self.catch_all_events = []
+        self.regex_plugins = []
+        self.sieves = []
+
+    def register_plugins(self, plugins):
+        """
+        :param plugins: list of (file path, file code)
+        :type plugins: list[(str, object)]
+        """
+        for path, code in plugins:
+            filepath = os.path.abspath(path)
+            filename = os.path.basename(path)
+            plugin = FilePlugin(filepath, filename, code)
+            self.register_plugin(plugin)
+
+    def register_plugin(self, plugin, check_if_exists=True):
+        """
+        :type plugin: FilePlugin
+        """
+        if check_if_exists and plugin.filename in self.plugins:
+            self.unregister_plugin(plugin.filename)
+
+        self.plugins[plugin.filename] = plugin
+
+        # register commands
+        for command in plugin.commands:
+            for alias in command.aliases:
+                self.commands_by_alias[alias] = command
+
+        # register events
+        for event_plugin in plugin.events:
+            if event_plugin.is_catch_all():
+                self.catch_all_events.append(event_plugin)
+            else:
+                for event_name in event_plugin.events:
+                    if event_name in self.event_plugins_by_event:
+                        self.event_plugins_by_event[event_name].append(event_plugin)
+                    else:
+                        self.event_plugins_by_event[event_name] = [event_plugin]
+
+        # register regexes
+        for regex_plugin in plugin.regexes:
+            for regex_match in regex_plugin.regexes:
+                self.regex_plugins.append((regex_match, regex_plugin))
+
+        # register sieves
+        for sieve_plugin in plugin.sieves:
+            self.sieves.append(sieve_plugin)
+
+    def unregister_plugin(self, plugin):
+        """
+        :param plugin: FilePlugin to directly unload, or str to lookup via filename and then unload.
+        :type plugin: FilePlugin | str
+        """
+        if isinstance(plugin, str):
+            assert plugin in self.plugins
+            plugin = self.plugins[plugin]
+        else:
+            assert plugin.filename in self.plugins and self.plugins[plugin.filename] is plugin
+            # we don't want to be unload a plugin which isn't loaded
+
+        # unregister commands
+        for command in plugin.commands:
+            for alias in command.aliases:
+                del self.commands_by_alias[alias]
+
+        # unregister events
+        for event_plugin in plugin.events:
+            if event_plugin.is_catch_all():
+                self.catch_all_events.remove(event_plugin)
+            else:
+                for event_name in event_plugin.events:
+                    assert event_name in self.event_plugins_by_event  # this can't be not true
+                    self.event_plugins_by_event[event_name].remove(event_plugin)
+
+        # unregister regexes
+        for regex_plugin in plugin.regexes:
+            for regex_match in regex_plugin.regexes:
+                self.regex_plugins.remove((regex_match, regex_plugin))
+
+        # unregister sieves
+        for sieve_plugin in plugin.sieves:
+            self.sieves.remove(sieve_plugin)
+
+        # remove last reference to plugin
+        del self.plugins[plugin.filename]
+
+
+class FilePlugin:
+    """
+    :type filepath: str
+    :type filename: str
+    :type code: object
+    :type commands: list[CommandPlugin]
+    :type regexes: list[RegexPlugin]
+    :type events: list[EventPlugin]
+    :type sieves: list[SievePlugin]
+    """
+
+    def __init__(self, filepath, filename, code):
+        """
+        :type filepath: str
+        :type filename: str
+        :type code: object
+        """
+        self.filepath = filepath
+        self.filename = filename
+        self.code = code
+        self.commands, self.regexes, self.events, self.sieves = find_hooks(code)
+
+
+class _Plugin:
+    """
+    :type function: function
+    """
+
+    def __init__(self, func_hook):
+        """
+        :type func_hook: hook._Hook
+        """
+        self.function = func_hook.function
+        for key, value in func_hook.kwargs.items():
+            setattr(self, key.lower(), value)
+
+
+class CommandPlugin(_Plugin):
+    """
+    :type name: str
+    :type aliases: list[str]
+    :type doc: str
+    :type autohelp: bool
+    :type permissions: list[str]
+    """
+
+    def __init__(self, cmd_hook):
+        """
+        :type cmd_hook: hook._CommandHook
+        """
+        _Plugin.__init__(self, cmd_hook)
+
+        # make sure that autohelp and permissions are set
+        if not "autohelp" in cmd_hook.kwargs:
+            self.autohelp = False
+        if not "permissions" in cmd_hook.kwargs:
+            self.permissions = []
+
+        self.name = cmd_hook.main_alias
+        self.aliases = cmd_hook.aliases
+        self.doc = cmd_hook.doc
+
+
+class RegexPlugin(_Plugin):
+    """
+    :type regexes: set[re.__Regex]
+    """
+
+    def __init__(self, regex_hook):
+        """
+        :type regex_hook: hook._RegexHook
+        """
+        _Plugin.__init__(self, regex_hook)
+        self.regexes = regex_hook.regexes
+
+
+class EventPlugin(_Plugin):
+    """
+    :type events: set[str]
+    """
+
+    def __init__(self, event_hook):
+        """
+        :type event_hook: hook._EventHook
+        """
+        _Plugin.__init__(self, event_hook)
+        self.events = event_hook.events
+
+    def is_catch_all(self):
+        return "*" in self.events
+
+
+class SievePlugin(_Plugin):
+    def __init__(self, sieve_hook):
+        """
+        :type sieve_hook: hook._SieveHook
+        """
+        _Plugin.__init__(self, sieve_hook)
\ No newline at end of file
diff --git a/util/hook.py b/util/hook.py
index 31e069b..3a5e705 100644
--- a/util/hook.py
+++ b/util/hook.py
@@ -2,6 +2,161 @@ import inspect
 import re
 
 
+class _Hook():
+    """
+    :type function: function
+    :type kwargs: dict[str, V]
+    """
+
+    def __init__(self, function, kwargs):
+        """
+        :type function: function
+        :type kwargs: dict[str, V]
+        """
+        self.function = function
+        self.kwargs = kwargs
+
+
+class _CommandHook(_Hook):
+    """
+    :type main_alias: str
+    :type aliases: set[str]
+    """
+
+    def __init__(self, alias_param, function, kwargs):
+        """
+        :type alias_param: list[str] | str
+        :type function: function
+        :type kwargs: dict[str, V]
+        """
+        _Hook.__init__(self, function, kwargs)
+
+        if isinstance(alias_param, str):
+            self.main_alias = alias_param
+            self.aliases = {alias_param}  # construct a set with one str
+        else:
+            assert isinstance(alias_param, list)
+            self.main_alias = alias_param[0]
+            self.aliases = set(alias_param)  # turn the list into a set
+
+        self.doc = function.__doc__.split('\n', 1)[0]
+
+    def add_hook(self, aliases, kwargs):
+        """
+        :type aliases: list[str] | str
+        """
+        # update kwargs, overwriting duplicates
+        self.kwargs.update(kwargs)
+
+        if isinstance(aliases, str):
+            self.aliases.add(aliases)
+        else:
+            assert isinstance(aliases, list)
+            self.aliases.update(aliases)
+
+
+class _RegexHook(_Hook):
+    """
+    :type regexes: list[re.__Regex]
+    """
+
+    def __init__(self, function, regex_param, regex_flags, kwargs):
+        """
+        :type function: function
+        :type regex_param: list[str | re.__Regex] | str | re.__Regex
+        :type kwargs: dict[str, V]
+        """
+        _Hook.__init__(self, function, kwargs)
+
+        self.regexes = []
+        if isinstance(regex_param, str):
+            # if the paramater is a string, compile and add
+            self.regexes.append(re.compile(regex_param, regex_flags))
+        elif isinstance(regex_param, re.__Regex):
+            # if the paramater is an re.__Regex, just add it
+            self.regexes.append(regex_param)
+        else:
+            assert isinstance(regex_param, list)
+            # if the paramater is a list, add each one
+            for re_to_match in regex_param:
+                if isinstance(re_to_match, str):
+                    re_to_match = re.compile(re_to_match, regex_flags)
+                else:
+                    # make sure that the param is a regex if it isn't a str
+                    assert isinstance(re_to_match, re.__Regex)
+
+                self.regexes.append(re_to_match)
+
+    def add_hook(self, regex_param, regex_flags, kwargs):
+        """
+        :type regex_param: list[str | re.__Regex] | str | re.__Regex
+        :type kwargs: dict[str, V]
+        """
+        # update kwargs, overwriting duplicates
+        self.kwargs.update(kwargs)
+        # add all regex_paramaters to valid regexes
+        if isinstance(regex_param, str):
+            # if the paramater is a string, compile and add
+            self.regexes.append(re.compile(regex_param, regex_flags))
+        elif isinstance(regex_param, re.__Regex):
+            # if the paramater is an re.__Regex, just add it
+            self.regexes.append(regex_param)
+        else:
+            assert isinstance(regex_param, list)
+            # if the paramater is a list, add each one
+            for re_to_match in regex_param:
+                if isinstance(re_to_match, str):
+                    re_to_match = re.compile(re_to_match, regex_flags)
+                else:
+                    assert isinstance(re_to_match, re.__Regex)
+
+                self.regexes.append(re_to_match)
+
+
+class _EventHook(_Hook):
+    """
+    :type events: set[str]
+    """
+
+    def __init__(self, event_param, function, kwargs):
+        """
+        :type event_param: list[str] | str
+        :type function: function
+        :type kwargs: dict[str, V]
+        """
+        _Hook.__init__(self, function, kwargs)
+
+        if isinstance(event_param, str):
+            self.events = {event_param}  # one str set
+        else:
+            assert isinstance(event_param, list)
+            self.events = set(event_param)
+
+    def add_hook(self, event_param, kwargs):
+        """
+        :type event_param: list[str] | str
+        :type kwargs: dict[str, V]
+        """
+        # update kwargs, overwriting duplicates
+        self.kwargs.update(kwargs)
+
+        if isinstance(event_param, str):
+            self.events.add(event_param)
+        else:
+            assert isinstance(event_param, list)
+            self.events.update(event_param)
+
+
+class _SieveHook(_Hook):
+    def __init__(self, function, kwargs):
+        _Hook.__init__(self, function, kwargs)
+        # there isn't that much else to do, as sieves don't have any params
+
+    def add_hook(self, kwargs):
+        # update kwargs, overwriting duplicates
+        self.kwargs.update(kwargs)
+
+
 def _hook_add(func, add, name=''):
     if not hasattr(func, '_hook'):
         func._hook = []
@@ -21,6 +176,7 @@ def sieve(func):
     _hook_add(func, ['sieve', (func,)])
     return func
 
+
 # TODO: Add support for multiple commands in one hook
 # EG: @hook.command(["command1", "command2"], **args)
 def command(name=None, **kwargs):
-- 
1.9.2

