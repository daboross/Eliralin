From 8444692ceed4bba77b26515e483ba4d437bf6297 Mon Sep 17 00:00:00 2001
From: Dabo Ross <daboross@daboross.net>
Date: Sat, 5 Apr 2014 22:55:20 -0700
Subject: [PATCH] Major massive commit - TODO: Split this up


diff --git a/cloudbot.py b/cloudbot.py
index f567315..906ca91 100755
--- a/cloudbot.py
+++ b/cloudbot.py
@@ -1,11 +1,17 @@
-#!/usr/bin/env python
-from core import bot
-
+#!/usr/bin/env python3
 import os
 import sys
 import time
 import signal
 
+from core import bot
+
+
+
+
+
+
+
 # check python version 
 if sys.version_info < (3, 2, 0):
     print("CloudBot3 requires Python 3.2 or newer.")
@@ -16,37 +22,50 @@ os.chdir(sys.path[0] or '.')  # do stuff relative to the install directory
 
 # this is not the code you are looking for
 if os.path.exists(os.path.abspath('lib')):
-    sys.path += ['lib'] 
+    sys.path += ['lib']
 
 print('CloudBot3 <http://git.io/cloudbotirc>')
 
 
-def exit_gracefully(signum, frame):
-    # this doesn't really work at all
-    cloudbot.stop()
-
-    # restore the original handler so if they do it again it triggers
-    signal.signal(signal.SIGINT, original_sigint)
-
-# store the original SIGINT handler
-original_sigint = signal.getsignal(signal.SIGINT)
-signal.signal(signal.SIGINT, exit_gracefully)
-
-# create a bot master and start it
-cloudbot = bot.CloudBot()
-cloudbot.start()
-
-# watch to see if the bot stops running or needs a restart
-while True:
-    if cloudbot.running:
-        time.sleep(.1)
-    else:
-        if cloudbot.do_restart:
-            # create a new bot thread and start it
-            # Todo: Make this work
-            del cloudbot
-            cloudbot = bot.Bot()
-            cloudbot.start()
-            continue
-        else:
-            break
\ No newline at end of file
+class CloudBotWrapper():
+    def __init__(self):
+        # create the master cloudbot
+        self.cloudbot = bot.CloudBot()
+
+        self.original_sigint = None
+
+    def set_signals(self):
+        # store the original SIGINT handler
+        self.original_sigint = signal.getsignal(signal.SIGINT)
+        signal.signal(signal.SIGINT, self.exit_gracefully)
+
+    def exit_gracefully(self, signum, frame):
+        # this doesn't really work at all
+        self.cloudbot.stop()
+
+        # restore the original handler so if they do it again it triggers
+        signal.signal(signal.SIGINT, self.original_sigint)
+
+    def run(self):
+        # start the bot master
+        self.cloudbot.start()
+
+        # watch to see if the bot stops running or needs a restart
+        while True:
+            if self.cloudbot.running:
+                time.sleep(.1)
+            else:
+                if self.cloudbot.do_restart:
+                    # create a new bot thread and start it
+                    del self.cloudbot
+                    self.cloudbot = bot.CloudBot()
+                    self.cloudbot.start()
+                    continue
+                else:
+                    break
+
+
+if __name__ == "__main__":
+    main_wrapper = CloudBotWrapper()
+    main_wrapper.set_signals()
+    main_wrapper.run()
\ No newline at end of file
diff --git a/core/bot.py b/core/bot.py
index 95d0dfe..9364b7d 100644
--- a/core/bot.py
+++ b/core/bot.py
@@ -15,12 +15,17 @@ from core.loader import PluginLoader
 
 
 def clean_name(n):
-    """strip all spaces and capitalization"""
+    """strip all spaces and capitalization
+    :type n: str
+    :rtype : str
+    """
     return re.sub('[^A-Za-z0-9_]+', '', n.replace(" ", "_"))
 
 
 def get_logger():
-    """create and return a new logger object"""
+    """create and return a new logger object
+    :rtype : logging.Logger
+    """
     # create logger
     logger = logging.getLogger("cloudbot")
     logger.setLevel(logging.DEBUG)
@@ -53,17 +58,36 @@ class CloudBot(threading.Thread):
         self.running = True
         self.do_restart = False
 
-        # stores each instance of the
-        self.instances = []
+        # stores each bot server connection
+        self.server_connections = []
 
-        # set up config and logging
-        self.setup()
+        # set up logging
+        self.logger = get_logger()
+        self.logger.debug("Logging system initalised.")
+
+        # declare and create data folder
+        self.data_dir = os.path.abspath('data')
+        if not os.path.exists(self.data_dir):
+            self.logger.debug("Data folder not found, creating.")
+            os.mkdir(self.data_dir)
+
+        # set up config
+        self.config = config.Config(self)
+        self.logger.debug("Config system initalised.")
+
+        # setup db
+        engine = create_engine('sqlite:///cloudbot.db')
+        db_factory = sessionmaker(bind=engine)
+        self.db_session = scoped_session(db_factory)
+        self.logger.debug("Database system initalised.")
+
+        # Bot initialisation complete
         self.logger.debug("Bot setup completed.")
 
         # start bot instances
-        self.create()
+        self.create_connections()
 
-        for instance in self.instances:
+        for instance in self.server_connections:
             instance.permissions = PermissionManager(self, instance)
 
         # run plugin loader
@@ -89,7 +113,7 @@ class CloudBot(threading.Thread):
         """recieves input from the IRC engine and processes it"""
         self.logger.info("Starting main thread.")
         while self.running:
-            for instance in self.instances:
+            for instance in self.server_connections:
                 try:
                     incoming = instance.parsed_queue.get_nowait()
                     if incoming == StopIteration:
@@ -101,35 +125,12 @@ class CloudBot(threading.Thread):
                     pass
 
             # if no messages are in the incoming queue, sleep
-            while self.running and all(i.parsed_queue.empty() for i in self.instances):
+            while self.running and all(connection.parsed_queue.empty() for connection in self.server_connections):
                 time.sleep(.1)
 
-    def setup(self):
-        """create the logger and config objects"""
-        # logging
-        self.logger = get_logger()
-        self.logger.debug("Logging system initalised.")
-
-        # data folder
-        self.data_dir = os.path.abspath('persist')
-        if not os.path.exists(self.data_dir):
-            self.logger.debug("Data folder not found, creating.")
-            os.mkdir(self.data_dir)
-
-        # config
-        self.config = config.Config(self)
-        self.logger.debug("Config system initalised.")
-
-        # db
-        engine = create_engine('sqlite:///cloudbot.db')
-        db_factory = sessionmaker(bind=engine)
-        self.db_session = scoped_session(db_factory)
-        self.logger.debug("Database system initalised.")
-
-    def create(self):
-        """ Create a BotInstance for all the networks defined in the config """
-        for conf in self.config['instances']:
-
+    def create_connections(self):
+        """ Create a BotConnection for all the networks defined in the config """
+        for conf in self.config['connections']:
             # strip all spaces and capitalization from the connection name
             name = clean_name(conf['name'])
             nick = conf['nick']
@@ -138,12 +139,11 @@ class CloudBot(threading.Thread):
 
             self.logger.debug("Creating BotInstance for {}.".format(name))
 
-            self.instances.append(irc.BotInstance(name, server, nick, config=conf,
-                                  port=port, logger=self.logger, channels=conf['channels'],
-                                  ssl=conf['connection'].get('ssl', False)))
+            self.server_connections.append(irc.BotConnection(name, server, nick, config=conf,
+                                                             port=port, logger=self.logger, channels=conf['channels'],
+                                                             ssl=conf['connection'].get('ssl', False)))
             self.logger.debug("({}) Created connection.".format(name))
 
-
     def stop(self, reason=None):
         """quits all networks and shuts the bot down"""
         self.logger.info("Stopping bot.")
@@ -154,7 +154,7 @@ class CloudBot(threading.Thread):
         self.loader.stop()
         self.logger.debug("Stopping plugin loader.")
 
-        for connection in self.connections:
+        for connection in self.server_connections:
             self.logger.debug("({}) Closing connection.".format(connection.name))
 
             if reason:
@@ -172,4 +172,17 @@ class CloudBot(threading.Thread):
     def restart(self, reason=None):
         """shuts the bot down and restarts it"""
         self.do_restart = True
-        self.stop(reason)
\ No newline at end of file
+        self.stop(reason)
+
+    # noinspection PyMethodMayBeStatic
+    def get_command_prefixes(self, inp):
+        return ""
+        # db = self.db_session
+        #
+        # db.execute("CREATE TABLE IF NOT EXISTS prefixes(channel, prefix, UNIQUE(channel, prefix) ON CONFLICT REPLACE)")
+        # db.commit()
+        # row = db.execute("SELECT prefix FROM prefixes WHERE channel = ?", [inp.chan]).fetchall()
+        # prefixes = ""
+        # for prefix in row:
+        #     prefixes += re.escape(prefix[0])
+        # return prefixes
diff --git a/core/config.py b/core/config.py
index 9d8d010..5a6a0ec 100644
--- a/core/config.py
+++ b/core/config.py
@@ -9,6 +9,10 @@ from watchdog.tricks import Trick
 
 class Config(dict):
     def __init__(self, bot, *args, **kwargs):
+        """
+
+        :type bot: core.bot.CloudBot
+        """
         self.filename = "config.json"
         self.path = os.path.abspath(self.filename)
         self.bot = bot
@@ -18,10 +22,12 @@ class Config(dict):
         # populate self with config data
         self.load_config()
 
+        # Declaring here, to be assigned later
+        self.observer = None
+        self.event_handler = None
         # start watcher
         self.watcher()
 
-
     def load_config(self):
         """(re)loads the bot config from the config file"""
         if not os.path.exists(self.path):
@@ -38,8 +44,8 @@ class Config(dict):
             self.logger.info("Config loaded from file.")
 
         # reload permissions
-        if self.bot.instances:
-            for instance in self.bot.instances:
+        if self.bot.server_connections:
+            for instance in self.bot.server_connections:
                 instance.permissions.reload()
 
     def save_config(self):
diff --git a/core/db.py b/core/db.py
deleted file mode 100644
index d4226a2..0000000
--- a/core/db.py
+++ /dev/null
@@ -1,26 +0,0 @@
-import os
-import sqlite3
-import _thread
-
-threaddbs = {}
-
-
-def get_db_connection(conn, name=''):
-    """returns an sqlite3 connection to a persistent database"""
-
-    if not name:
-        name = '{}.db'.format(conn.name)
-
-    threadid = _thread.get_ident()
-    if name in threaddbs and threadid in threaddbs[name]:
-        return threaddbs[name][threadid]
-    filename = os.path.join(bot.data_dir, name)
-
-    db = sqlite3.connect(filename, timeout=10)
-    if name in threaddbs:
-        threaddbs[name][threadid] = db
-    else:
-        threaddbs[name] = {threadid: db}
-    return db
-
-bot.get_db_connection = get_db_connection
diff --git a/core/irc.py b/core/irc.py
index 88357d5..2ae6358 100644
--- a/core/irc.py
+++ b/core/irc.py
@@ -4,8 +4,6 @@ import time
 import threading
 import queue
 
-from core import permissions
-
 from ssl import wrap_socket, CERT_NONE, CERT_REQUIRED, SSLError
 
 irc_prefix_rem = re.compile(r'(.*?) (.*?) (.*)').match
@@ -29,6 +27,7 @@ def censor(text):
 
 class ReceiveThread(threading.Thread):
     """receives messages from IRC and puts them in the input_queue"""
+
     def __init__(self, sock, input_queue, timeout):
         self.input_buffer = b""
         self.input_queue = input_queue
@@ -87,14 +86,15 @@ class SSLReceiveThread(ReceiveThread):
         return SSLError
 
     def handle_receive_exception(self, error, last_timestamp):
-       # this is terrible
+        # this is terrible
         if not "timed out" in error.args[0]:
-            raise
+            raise error
         return ReceiveThread.handle_receive_exception(self, error, last_timestamp)
 
 
 class SendThread(threading.Thread):
     """sends messages from output_queue to IRC"""
+
     def __init__(self, sock, conn_name, output_queue):
         self.output_buffer = b""
         self.output_queue = output_queue
@@ -115,6 +115,7 @@ class SendThread(threading.Thread):
 
 class ParseThread(threading.Thread):
     """parses messages from input_queue and puts them in parsed_queue"""
+
     def __init__(self, input_queue, output_queue, parsed_queue):
         self.input_queue = input_queue  # lines that were received
         self.output_queue = output_queue  # lines to be sent out
@@ -141,7 +142,7 @@ class ParseThread(threading.Thread):
             nick, user, host = irc_netmask_rem(prefix).groups()
             mask = nick + "!" + user + "@" + host
             paramlist = irc_param_ref(params)
-            lastparam = "" 
+            lastparam = ""
             if paramlist:
                 if paramlist[-1].startswith(':'):
                     paramlist[-1] = paramlist[-1][1:]
@@ -157,6 +158,7 @@ class ParseThread(threading.Thread):
 
 class IRCConnection(object):
     """handles an IRC connection"""
+
     def __init__(self, name, host, port, input_queue, output_queue):
         self.output_queue = output_queue  # lines to be sent out
         self.input_queue = input_queue  # lines that were received
@@ -202,13 +204,32 @@ class SSLIRCConnection(IRCConnection):
                            CERT_REQUIRED)
 
 
-class BotInstance(object):
-    """ A BotInstance represents each connection the bot makes to an IRC server """
-
-    def __init__(self, name, server, nick, port=6667, ssl=False, logger=None, channels=[], config={}):
+class BotConnection(object):
+    """ A BotConnection represents each connection the bot makes to an IRC server """
+
+    def __init__(self, name, server, nick, port=6667, ssl=False, logger=None, channels=None, config=None):
+        """
+        :type name: str
+        :type server: str
+        :type nick: str
+        :type port: int
+        :type ssl: bool
+        :type logger: logging.Logger
+        :type channels: list
+        :type config: map
+        """
         self.name = name
-        self.channels = channels
-        self.config = config
+
+        if channels is None:
+            self.channels = []
+        else:
+            self.channels = channels
+
+        if config is None:
+            self.config = {}
+        else:
+            self.config = config
+
         self.ssl = ssl
         self.server = server
         self.port = port
@@ -252,34 +273,56 @@ class BotInstance(object):
         self.connection.stop()
 
     def set_pass(self, password):
+        """
+
+        :type password: str
+        """
         if password:
             self.cmd("PASS", [password])
 
     def set_nick(self, nick):
+        """
+        :type nick: str
+        """
         self.cmd("NICK", [nick])
 
     def join(self, channel):
-        """ makes the bot join a channel """
+        """ makes the bot join a channel
+        :type channel: str
+        """
         self.send("JOIN {}".format(channel))
         if channel not in self.channels:
             self.channels.append(channel)
 
     def part(self, channel):
-        """ makes the bot leave a channel """
+        """ makes the bot leave a channel
+        :type channel: str
+        """
         self.cmd("PART", [channel])
         if channel in self.channels:
             self.channels.remove(channel)
 
     def msg(self, target, text):
-        """ makes the bot send a PRIVMSG to a target  """
+        """ makes the bot send a PRIVMSG to a target
+        :type text: str
+        :type target: str
+        """
         self.cmd("PRIVMSG", [target, text])
 
     def ctcp(self, target, ctcp_type, text):
-        """ makes the bot send a PRIVMSG CTCP to a target """
+        """ makes the bot send a PRIVMSG CTCP to a target
+        :type ctcp_type: str
+        :type text: str
+        :type target: str
+        """
         out = "\x01{} {}\x01".format(ctcp_type, text)
         self.cmd("PRIVMSG", [target, out])
 
     def cmd(self, command, params=None):
+        """
+        :type command: str
+        :type params: list
+        """
         if params:
             params[-1] = ':' + params[-1]
             self.send("{} {}".format(command, ' '.join(params)))
@@ -287,6 +330,9 @@ class BotInstance(object):
             self.send(command)
 
     def send(self, string):
+        """
+        :type string: str
+        """
         try:
             self.logger.info("{} >> {}".format(self.name.upper(), string))
         except:
diff --git a/core/main.py b/core/main.py
index da120ce..6cfe8cb 100644
--- a/core/main.py
+++ b/core/main.py
@@ -1,75 +1,142 @@
 import _thread
-import traceback
+import inspect
 import queue
 import re
 
-from sqlalchemy.orm import scoped_session
-
 _thread.stack_size(1024 * 512)  # reduce vm size
 
 
-#TODO: redesign this messy thing
-class Input(dict):
+class Input:
     def __init__(self, bot, conn, raw, prefix, command, params,
                  nick, user, host, mask, paraml, msg):
-
-        chan = paraml[0].lower()
-        if chan == conn.nick.lower():  # is a PM
-            chan = nick
-
-        def message(message, target=chan):
-            """sends a message to a specific or current channel/user"""
-            conn.msg(target, message)
-
-        def reply(message, target=chan):
-            """sends a message to the current channel/user with a prefix"""
-            if target == nick:
-                conn.msg(target, message)
-            else:
-                conn.msg(target, "({}) {}".format(nick, message))
-
-        def action(message, target=chan):
-            """sends an action to the current channel/user or a specific channel/user"""
-            conn.ctcp(target, "ACTION", message)
-
-        def ctcp(message, ctcp_type, target=chan):
-            """sends an ctcp to the current channel/user or a specific channel/user"""
-            conn.ctcp(target, ctcp_type, message)
-
-        def notice(message, target=nick):
-            """sends a notice to the current channel/user or a specific channel/user"""
-            conn.cmd('NOTICE', [target, message])
-
-        dict.__init__(self, conn=conn, raw=raw, prefix=prefix, command=command,
-                      params=params, nick=nick, user=user, host=host, mask=mask,
-                      paraml=paraml, msg=msg, server=conn.server, chan=chan,
-                      notice=notice, message=message, reply=reply, bot=bot,
-                      action=action, ctcp=ctcp, lastparam=paraml[-1])
-
-    # make dict keys accessible as attributes
-    def __getattr__(self, key):
-        return self[key]
-
-    def __setattr__(self, key, value):
-        self[key] = value
+        """
+        :type bot: core.bot.CloudBot
+        :type conn: core.irc.BotConnection
+        """
+        self.bot = bot
+        self.conn = conn
+        self.raw = raw
+        self.prefix = prefix
+        self.command = command
+        self.params = params
+        self.nick = nick
+        self.user = user
+        self.host = host
+        self.mask = mask
+        self.paraml = paraml
+        self.msg = msg
+        self.input = self
+        self.text = self.paraml  # TODO: Right thing to do?
+        self.server = conn.server
+        self.lastparam = paraml[-1]
+        self.chan = paraml[0].lower()
+
+        if self.chan == conn.nick.lower():  # is a PM
+            self.chan = nick
+
+    def message(self, message, target=None):
+        """sends a message to a specific or current channel/user
+        :type target: str
+        :type message: str
+        """
+        if target is None:
+            target = self.chan
+        self.conn.msg(target, message)
+
+    def reply(self, message, target=None):
+        """sends a message to the current channel/user with a prefix
+        :type target: str
+        :type message: str
+        """
+        if target is None:
+            target = self.chan
+
+        if target == self.nick:
+            self.conn.msg(target, message)
+        else:
+            self.conn.msg(target, "{}, {}".format(self.nick, message))
+
+    def action(self, message, target=None):
+        """sends an action to the current channel/user or a specific channel/user
+        :type target: str
+        :type message: str
+        """
+        if target is None:
+            target = self.chan
+
+        self.conn.ctcp(target, "ACTION", message)
+
+    def ctcp(self, message, ctcp_type, target=None):
+        """sends an ctcp to the current channel/user or a specific channel/user
+        :type target: str
+        :type ctcp_type: str
+        :type message: str
+        """
+        if target is None:
+            target = self.chan
+        self.conn.ctcp(target, ctcp_type, message)
+
+    def notice(self, message, target=None):
+        """sends a notice to the current channel/user or a specific channel/user
+        :type target: str
+        :type message: str
+        """
+        if target is None:
+            target = self.nick
+
+        self.conn.cmd('NOTICE', [target, message])
 
 
 def run(bot, func, input):
+    """
+
+    :type func: func
+    :type bot: core.bot.CloudBot
+    :type input: Input
+    """
     uses_db = True
     # TODO: change to bot.get_db_session()
-    print(input)
-    if 'text' not in input:
-        input.text = input.paraml
 
     if uses_db:
         # create SQLAlchemy session
         bot.logger.debug("Opened DB session for: {}".format(func._filename))
         input.db = input.bot.db_session()
 
+    # parameters is an array of
+    parameters = []
+    named_parameters = {}
+    specifications = inspect.getargspec(func)
+    required_args = specifications[0]
+    default_args = specifications[3]
+    if required_args is None:
+        required_args = []
+    if default_args is None:
+        default_args = []
+
+    if len(required_args) - len(default_args) == 1:
+        # The function is using the old format, with all arguments with defaults except for 'text'
+        # Assume that the funct want the first non-default arg to be 'input'
+        parameters = [input.text]
+        required_args = required_args[1:]  # Trim the first argument, as it's been assigned as a non-named parameter
+
+        for required_arg in required_args:
+            # Assign the rest of the named parameters to values from input
+            value = getattr(input, required_arg)
+
+            named_parameters[required_arg] = value
+    elif len(required_args) - len(default_args) == 3:
+        # We're assuming that this function is using the new format
+        # Treat the first three parameters as input, instance, bot
+        parameters = [input, input.conn, input.bot]
+    else:
+        print("Warning, ignoring function which doesn't fit arg spec. Argument specs: {}".format(specifications))
+        return
+
     try:
-        out = func(input, input.conn)
+        out = func(*parameters, **named_parameters)
     except:
         bot.logger.exception("Error in plugin {}:".format(func._filename))
+        bot.logger.info("Parameters used: {}, named parameters used: {}".format(parameters, named_parameters))
         return
     finally:
         if uses_db:
@@ -81,6 +148,9 @@ def run(bot, func, input):
 
 
 def do_sieve(sieve, bot, input, func, type, args):
+    """
+    :type bot: core.bot.CloudBot
+    """
     try:
         return sieve(bot, input, func, type, args)
     except Exception:
@@ -107,7 +177,6 @@ class Handler(object):
 
             run(self.bot, self.func, input)
 
-
     def stop(self):
         self.input_queue.put(StopIteration)
 
@@ -116,12 +185,18 @@ class Handler(object):
 
 
 def dispatch(bot, input, kind, func, args, autohelp=False):
+    """
+
+
+    :type bot: core.bot.CloudBot
+    :type input: Input
+    """
     for sieve, in bot.plugins['sieve']:
         input = do_sieve(sieve, bot, input, func, kind, args)
         if input is None:
             return
 
-    if not (not autohelp or not args.get('autohelp', True) or input.inp or not (func.__doc__ is not None)):
+    if autohelp and args.get('autohelp', True) and not input.text and func.__doc__ is not None:
         input.notice(input.conn.config["command_prefix"] + func.__doc__)
         return
 
@@ -155,9 +230,10 @@ def main(bot, conn, out):
     if inp.command == 'PRIVMSG':
         # COMMANDS
         if inp.chan == inp.nick:  # private message, no command prefix
-            prefix = '^(?:[{}]?|'.format(command_prefix)
+            prefix = '^(?:[{}{}]?|'.format(command_prefix, bot.get_command_prefixes(inp))
         else:
-            prefix = '^(?:[{}]|'.format(command_prefix)
+            prefix = '^(?:[{}{}]|'.format(command_prefix, bot.get_command_prefixes(inp))
+
         command_re = prefix + inp.conn.nick
         command_re += r'[,;:]+\s+)(\w+)(?:$|\s+)(.*)'
 
@@ -179,6 +255,7 @@ def main(bot, conn, out):
 
                 func, args = bot.commands[command]
                 dispatch(bot, input, "command", func, args, autohelp=True)
+                return
 
         # REGEXES
         for func, args in bot.plugins['regex']:
diff --git a/plugins/admin.py b/plugins/admin.py
index 858d191..beab945 100644
--- a/plugins/admin.py
+++ b/plugins/admin.py
@@ -1,9 +1,4 @@
-import os
-import sys
 import re
-import json
-import time
-import subprocess
 
 from util import hook
 
@@ -103,8 +98,8 @@ def adduser(inp, bot=None, notice=None):
     bot.config.save_config()
 
 
-@hook.command("quit", autohelp=False)
-@hook.command(autohelp=False)
+@hook.command(permissions=["botcontrol"], autohelp=False)
+@hook.command("quit", permissions=["botcontrol"], autohelp=False)
 def stop(inp, bot=None):
     """stop [reason] -- Kills the bot with [reason] as its quit message."""
     if inp:
@@ -113,7 +108,7 @@ def stop(inp, bot=None):
         bot.stop()
 
 
-@hook.command(autohelp=False)
+@hook.command(permissions=["botcontrol"], autohelp=False)
 def restart(inp, bot=None):
     """restart [reason] -- Restarts the bot with [reason] as its quit message."""
     if inp:
@@ -122,13 +117,6 @@ def restart(inp, bot=None):
         bot.restart()
 
 
-
-@hook.command(autohelp=False, permissions=["botcontrol"])
-def clearlogs(inp, input=None):
-    """clearlogs -- Clears the bots log(s)."""
-    subprocess.call(["./cloudbot", "clear"])
-
-
 @hook.command(permissions=["botcontrol"])
 def join(inp, conn=None, notice=None):
     """join <channel> -- Joins <channel>."""
@@ -139,7 +127,7 @@ def join(inp, conn=None, notice=None):
         conn.join(target)
 
 
-@hook.command(autohelp=False, permissions=["botcontrol"])
+@hook.command(permissions=["botcontrol"], autohelp=False)
 def part(inp, conn=None, chan=None, notice=None):
     """part <channel> -- Leaves <channel>.
     If [channel] is blank the bot will leave the
@@ -201,6 +189,16 @@ def say(inp, conn=None, chan=None):
     conn.send(out)
 
 
+@hook.command(permissions=["botcontrol"])
+def message(inp, conn=None, chan=None):
+    """message <name> <message> -- Makes the bot say <message> to <name>.
+    If <name> is a channel, the bot will say the message in that channel."""
+    inp = inp.split(" ")
+    message = " ".join(inp[1:])
+    out = "PRIVMSG {} :{}".format(inp[0], message)
+    conn.send(out)
+
+
 @hook.command("act", permissions=["botcontrol"])
 @hook.command(permissions=["botcontrol"])
 def me(inp, conn=None, chan=None):
diff --git a/plugins/attacks.py b/plugins/attacks.py
index ebc1064..c8a07f5 100644
--- a/plugins/attacks.py
+++ b/plugins/attacks.py
@@ -1,4 +1,5 @@
 import random
+import re
 
 from util import hook
 
@@ -26,7 +27,7 @@ def lart(inp, action=None, nick=None, conn=None, notice=None):
         return
 
     # if the user is trying to make the bot slap itself, slap them
-    if target.lower() == conn.nick.lower() or target.lower() == "itself":
+    if re.search("(itself|herself|himself|{}).*".format(conn.nick.lower()), target.lower()):
         target = nick
 
     values = {"user": target}
@@ -45,7 +46,7 @@ def insult(inp, nick=None, action=None, conn=None, notice=None):
         notice("Invalid username!")
         return
 
-    if target == conn.nick.lower() or target == "itself":
+    if re.search("(itself|herself|himself|{}).*".format(conn.nick.lower()), target.lower()):
         target = nick
     else:
         target = inp
@@ -55,7 +56,7 @@ def insult(inp, nick=None, action=None, conn=None, notice=None):
 
 
 @hook.command
-def flirt(inp, action=None, conn=None, notice=None):
+def flirt(inp, nick=None, message=None, conn=None, notice=None):
     """flirt <user> -- Make the bot flirt with <user>."""
     target = inp.strip()
 
@@ -63,10 +64,9 @@ def flirt(inp, action=None, conn=None, notice=None):
         notice("Invalid username!")
         return
 
-    if target == conn.nick.lower() or target == "itself":
-        target = 'itself'
+    if re.search("(itself|herself|himself|{}).*".format(conn.nick.lower()), target.lower()):
+        target = nick
     else:
         target = inp
 
-    out = 'flirts with {}... "{}"'.format(target, random.choice(flirts))
-    action(out)
+    message('{}, {}'.format(target, random.choice(flirts)))
diff --git a/plugins/core_ctcp.py b/plugins/core_ctcp.py
index 3e7a200..73af9bd 100644
--- a/plugins/core_ctcp.py
+++ b/plugins/core_ctcp.py
@@ -6,7 +6,7 @@ from util import hook
 # CTCP responses
 @hook.regex(r'^\x01VERSION\x01$')
 def ctcp_version(inp, notice=None):
-    notice('\x01VERSION: CloudBot - http://git.io/cloudbotirc')
+    notice('\x01VERSION Eliralin 1.0')
 
 
 @hook.regex(r'^\x01PING\x01$')
diff --git a/plugins/correction.py b/plugins/correction.py
index 9e66371..4beedf7 100644
--- a/plugins/correction.py
+++ b/plugins/correction.py
@@ -1,63 +1,63 @@
-from util import hook
-
-import re
-
-<<<<<<< HEAD
-@hook.regex(r'^(s|S)/.*/.*/\S*$')
-def correction(inp, message=None, input=None, notice=None, db=None):
-    splitinput = input.msg.split("/")
-    if splitinput[3]:
-        nick = splitinput[3]
-    else:
-        nick = input.nick
-    last_message = db.execute("select name, quote from seen_user where name"
-                              " like :nick and chan = :chan", {'nick': nick.lower(),
-                                                               'chan': input.chan.lower()}).fetchone()
-
-    if last_message:
-        splitinput = input.msg.split("/")
-        find = splitinput[1]
-        replace = splitinput[2]
-        if find in last_message[1]:
-            if "\x01ACTION" in last_message[1]:
-                msg = last_message[1].replace("\x01ACTION ", "/me ").replace("\x01", "")
-            else:
-                msg = last_message[1]
-            message(u"Correction, <{}> {}".format(nick, msg.replace(find, "\x02" + replace + "\x02")))
-        else:
-            notice(u"{} can't be found in your last message".format(find))
-=======
-CORRECTION_RE = r'^(s|S)/.*/.*/?\S*$'
-
-
-@hook.regex(CORRECTION_RE)
-def correction(match, input=None, conn=None, message=None):
-    split = input.msg.split("/")
-
-    if len(split) == 4:
-        nick = split[3].lower()
->>>>>>> develop
-    else:
-        nick = None
-
-    find = split[1]
-    replace = split[2]
-
-    for item in conn.history[input.chan].__reversed__():
-        name, timestamp, msg = item
-        if msg.startswith("s/"):
-            # don't correct corrections, it gets really confusing
-            continue
-        if nick:
-            if nick != name.lower():
-                continue
-        if find in msg:
-            if "\x01ACTION" in msg:
-                msg = msg.replace("\x01ACTION ", "/me ").replace("\x01", "")
-            message(u"Correction, <{}> {}".format(name, msg.replace(find, "\x02" + replace + "\x02")))
-            return
-        else:
-            continue
-
-    return u"Did not find {} in any recent messages.".format(find)
-
+# from util import hook
+#
+# import re
+#
+# <<<<<<< HEAD
+# @hook.regex(r'^(s|S)/.*/.*/\S*$')
+# def correction(inp, message=None, input=None, notice=None, db=None):
+#     splitinput = input.msg.split("/")
+#     if splitinput[3]:
+#         nick = splitinput[3]
+#     else:
+#         nick = input.nick
+#     last_message = db.execute("select name, quote from seen_user where name"
+#                               " like :nick and chan = :chan", {'nick': nick.lower(),
+#                                                                'chan': input.chan.lower()}).fetchone()
+#
+#     if last_message:
+#         splitinput = input.msg.split("/")
+#         find = splitinput[1]
+#         replace = splitinput[2]
+#         if find in last_message[1]:
+#             if "\x01ACTION" in last_message[1]:
+#                 msg = last_message[1].replace("\x01ACTION ", "/me ").replace("\x01", "")
+#             else:
+#                 msg = last_message[1]
+#             message(u"Correction, <{}> {}".format(nick, msg.replace(find, "\x02" + replace + "\x02")))
+#         else:
+#             notice(u"{} can't be found in your last message".format(find))
+# =======
+# CORRECTION_RE = r'^(s|S)/.*/.*/?\S*$'
+#
+#
+# @hook.regex(CORRECTION_RE)
+# def correction(match, input=None, conn=None, message=None):
+#     split = input.msg.split("/")
+#
+#     if len(split) == 4:
+#         nick = split[3].lower()
+# >>>>>>> develop
+#     else:
+#         nick = None
+#
+#     find = split[1]
+#     replace = split[2]
+#
+#     for item in conn.history[input.chan].__reversed__():
+#         name, timestamp, msg = item
+#         if msg.startswith("s/"):
+#             # don't correct corrections, it gets really confusing
+#             continue
+#         if nick:
+#             if nick != name.lower():
+#                 continue
+#         if find in msg:
+#             if "\x01ACTION" in msg:
+#                 msg = msg.replace("\x01ACTION ", "/me ").replace("\x01", "")
+#             message(u"Correction, <{}> {}".format(name, msg.replace(find, "\x02" + replace + "\x02")))
+#             return
+#         else:
+#             continue
+#
+#     return u"Did not find {} in any recent messages.".format(find)
+#
diff --git a/plugins/eliralin_teamcity.py b/plugins/eliralin_teamcity.py
new file mode 100644
index 0000000..07c8e8f
--- /dev/null
+++ b/plugins/eliralin_teamcity.py
@@ -0,0 +1,162 @@
+from xml.etree.ElementTree import ParseError
+import traceback
+from xml.etree import ElementTree
+import time
+
+import requests
+from requests.auth import HTTPBasicAuth
+
+from util import hook
+
+
+teamcity_url = "http://ci.daboross.net/ci"
+
+
+class ProjectDatabase:
+    def __init__(self):
+        self.reload_timestamp = 0
+        self.projects = []
+        self.username = "default"
+        self.password = "default"
+        self.teamcity_url = teamcity_url
+        self.loaded_key = False
+
+    def download(self, url):
+        if url.startswith("/httpAuth"):
+            data = requests.get(self.teamcity_url + url, auth=HTTPBasicAuth(self.username, self.password)).text
+        elif url.startswith("/guestAuth"):
+            data = requests.get(self.teamcity_url + url).text
+        elif self.loaded_key:
+            data = requests.get("{}/httpAuth{}".format(self.teamcity_url, url),
+                                auth=HTTPBasicAuth(self.username, self.password)).text
+        else:
+            data = requests.get("{}/guestAuth{}".format(self.teamcity_url, url)).text
+        try:
+            return ElementTree.fromstring(data)
+        except ParseError:
+            print("Error loading {} ({})".format(url, data))
+            raise
+
+    def load_key(self, bot):
+        if not self.loaded_key:
+            api_keys = bot.config.get("api_keys", None)
+            if api_keys:
+                self.username = api_keys.get("teamcity_username")
+                self.password = api_keys.get("teamcity_password")
+                self.loaded_key = True
+            else:
+                print("Warning, couldn't find teamcity api key")
+
+    def reload_database(self):
+        self.reload_timestamp = time.time()
+        self.projects = []
+        root = self.download("/app/rest/projects")
+        for project in root:
+            if project.get("id") != "_Root":
+                self.projects.append(Project(project))
+
+    def ensure_loaded(self, bot=None):
+        if bot and not self.loaded_key:
+            self.load_key(bot)
+        if self.reload_timestamp == 0:
+            self.reload_database()
+
+    def after_check(self):
+        if time.time() > self.reload_timestamp + 300:
+            self.reload_database()
+
+
+class Project:
+    def __init__(self, project):
+        self.name = project.get("name")
+        self.project_id = project.get("id")
+        self.project_url = project.get("href")
+        self.downloads = []
+        project_element = database.download(self.project_url)
+        build_types = project_element.find("buildTypes")
+        if build_types and len(build_types) > 0:
+            for build_type in build_types.findall("buildType"):
+                download = find_download_url(build_type)
+                if download:
+                    self.downloads.append(download)
+
+        self.search_name = self.name.lower()
+        self.search_id = self.project_id.lower()
+
+    def search(self, search):
+        if search == self.search_name or search == self.search_id:
+            return 2
+        elif search in self.search_name or search in self.search_id:
+            return 1
+        return 0
+
+
+def find_download_url(build_type_element):
+    try:
+        build_type_id = build_type_element.get("id")
+        href = build_type_element.get("href")
+        builds_url = database.download(href).find("builds").get("href")
+        build_url = database.download(builds_url).find("build").get("href")
+        artifacts_url = database.download(build_url).find("artifacts").get("href")
+        files = database.download(artifacts_url).findall("file")
+        filenames = [download_file.get("name") for download_file in files]
+        return {"id": build_type_id, "files": filenames}
+    except AttributeError:
+        traceback.print_exc()
+        return None
+    except ParseError:
+        traceback.print_exc()
+        return None
+
+
+database = ProjectDatabase()
+
+
+@hook.command()
+@hook.command("ci")
+def teamcity(inp, bot=None, reply=None, message=None):
+    """teamcity [project] - Searches for project on teamcity, and displays project URL and download"""
+    database.ensure_loaded(bot=bot)
+    search = inp.lower()
+    level_found = 0
+    project_found = None
+    other_matches = []
+    for project in database.projects:
+        level = project.search(search)
+        if level > level_found:
+            if project_found:
+                other_matches.append(project_found.name)
+            project_found = project
+            level_found = level
+        elif level > 0:
+            other_matches.append(project.name)
+
+    if project_found is not None:
+        reply("{} - Project: http://ci.daboross.net/p/{}".format(project_found.name, project_found.project_id))
+        for download in project_found.downloads:
+            for download_file in download["files"]:
+                message("Download: http://ci.daboross.net/d/{}/{}".format(download["id"], download_file))
+        if len(other_matches) > 0:
+            message("(Other matches: {})".format(", ".join(other_matches)))
+    else:
+        reply("No projects found matching '{}'".format(inp))
+    database.after_check()
+
+
+@hook.command(permissions=["botcontrol"], autohelp=False)
+@hook.command("reloadci", permissions=["botcontrol"], autohelp=False)
+def reload_teamcity(inp, bot=None, reply=None):
+    """reloadci - Reloads teamcity database manually"""
+    database.load_key(bot)
+    database.reload_database()
+    reply("Reloaded teamcity, found {} projects.".format(len(database.projects)))
+    database.after_check()
+
+
+@hook.command(permissions=["botcontrol"], autohelp=False)
+@hook.command("listci", permissions=["botcontrol"], autohelp=False)
+def list_teamcity(inp, bot=None, reply=None):
+    """listci - Lists all projects loaded into database from teamcity"""
+    database.ensure_loaded(bot=bot)
+    reply("Projects: {}".format(", ".join([project.name for project in database.projects])))
+    database.after_check()
diff --git a/plugins/eliralin_utility.py b/plugins/eliralin_utility.py
new file mode 100644
index 0000000..0934b98
--- /dev/null
+++ b/plugins/eliralin_utility.py
@@ -0,0 +1,157 @@
+from random import random
+import socket
+import sys
+import traceback
+import time
+
+from util import hook, web
+
+
+@hook.command
+def josephus(inp):
+    """jose [size] [every x] [starting person] - Calculates who dies last """
+    split = inp.split()
+    if len(split) != 3:
+        return "Not enough / too many arguments. {}".format(len(split))
+    size, every_x, current = [int(x) for x in split]
+    alive, till_kill = [True] * size, 0
+    while True:
+        if alive[current]:
+            if sum(alive) == 1:
+                break
+            elif till_kill == 0:
+                alive[current] = False
+                till_kill = every_x - 1
+            else:
+                till_kill -= 1
+        current += 1 if current < size - 1 else 1 - size
+    return "Josephus should be at position {} to survive.".format(current)
+
+
+@hook.regex("(?i)(^ )*pets Eliralin *$")
+def pet(match, action=None, nick=None, chan=None):
+    r = random()
+    if r > 0.7:
+        action("huggles {}".format(nick))
+
+
+@hook.command
+@hook.command("hug")
+def huggle(inp, action=None, nick=None):
+    if inp:
+        action("huggles {}".format(inp))
+    else:
+        action("huggles {}".format(nick))
+
+
+@hook.command
+def colors(inp):
+    if inp:
+        intinp = int(inp)
+        if intinp > 70:
+            return "Please use a number smaller than or equal to 70"
+        forrange = range(intinp)
+    else:
+        forrange = range(30)
+    result = ""
+    for i in forrange if inp else range(30):
+        result += u"\x03{0:02d} {0}".format(i)
+    return result
+
+
+@hook.regex(r'^Eliralin[,;:.](| .*)$')
+def reply(match, message=None, nick=None):
+    time.sleep(0.2)
+    message(match.group(0).replace("Eliralin", nick))
+
+
+@hook.regex("(?i)(Hello|Hi) Eliralin(!| |\\.|\\?)*")
+def hello_regex(match, nick=None, message=None):
+    if match.group(2) == "?":
+        message("Hi {}, What's your question?".format(nick))
+    else:
+        message("Hello {}!".format(nick))
+
+
+@hook.command(permissions=['adminonly'])
+def tree(inp, message=None, notice=None):
+    """tree [type] [text] - Tree text"""
+    type_input = inp.split(None, 1)
+    if len(type_input) < 2:
+        notice("tree [type] [text] - Tree text")
+        return
+    tree_type = type_input[0]
+    if tree_type == "1":
+        func = lambda c: c[1:-1]
+    elif tree_type == "2":
+        func = lambda c: c[2:]
+    elif tree_type == "3":
+        func = lambda c: c[:-2]
+    else:
+        return "Invalid tree type '{}'.".format(tree_type)
+    current = type_input[1]
+    spaces = 7
+    while len(current) > 0:
+        spaces += 1
+        message(spaces * ' ' + current)
+        current = func(current)
+
+    message((spaces - 1) * ' ' + ('----' if len(type_input[1]) % 2 == 0 else '---'))
+
+
+@hook.command
+def threaddump(inp):
+    print("Running thread dump")
+    code = []
+    for threadId, stack in sys._current_frames().items():
+        code.append("\n# ThreadID: %s" % threadId)
+        for filename, lineno, name, line in traceback.extract_stack(stack):
+            code.append('File: "%s", line %d, in %s' % (filename, lineno, name))
+            if line:
+                code.append("  %s" % (line.strip()))
+    return "Thread dump located at {}".format(web.haste("\n".join(code), ext='txt'))
+
+
+@hook.command
+def dns(inp):
+    """dns [domain] - Resolves the IP of a domain"""
+    try:
+        socket.setdefaulttimeout(5)
+        ip = None
+        for info in socket.getaddrinfo(inp, 80, 0, 0, socket.SOL_TCP):
+            print(info)
+            if ip is None:
+                ip = info[-1][0]
+            else:
+                ip = "{}, {}".format(ip, info[-1][0])
+        return "{} resolves to {}".format(inp, ip)
+    except socket.gaierror:
+        return "Resolve Failed!"
+
+
+@hook.command
+def rdns(inp):
+    """rdns [ip] - Resolves the hostname of an IP"""
+    try:
+        socket.setdefaulttimeout(5)
+        domain = socket.gethostbyaddr(inp)[0]
+        return "{} resolves to {}".format(inp, domain)
+    except socket.gaierror:
+        return "Resolve Failed!"
+
+
+@hook.command("unicode")
+def unicodecommand(inp, reply=None):
+    try:
+        return u"'{}'".format(chr(int(inp)))
+    except Exception:
+        reply("Failed")
+        raise
+
+
+@hook.command(permissions=["botcontrol"])
+def addprefix(inp, chan=None, db=None):
+    """addprefix [prefix] - Adds a one-letter prefix to the bot in this channel"""
+    db.execute("CREATE TABLE IF NOT EXISTS prefixes(channel, prefix, UNIQUE(channel, prefix) ON CONFLICT REPLACE)")
+    db.execute("INSERT INTO prefixes(channel, prefix) VALUES(?, ?)", [chan, inp])
+    db.commit()
diff --git a/plugins/encrypt.py b/plugins/encrypt.py
index 119e37d..b1be1f0 100644
--- a/plugins/encrypt.py
+++ b/plugins/encrypt.py
@@ -1,12 +1,10 @@
 import os
 import base64
-import json
 import hashlib
 
 from Crypto import Random
 from Crypto.Cipher import AES
-from Crypto.Protocol.KDF import PBKDF2
-
+import Crypto.Protocol.KDF as crypto_kdf
 from util import hook
 
 
@@ -56,7 +54,7 @@ def encrypt(inp, bot=None, db=None, notice=None):
     # generate the key from the password and salt
     password = split[0]
     salt = get_salt(bot)
-    key = PBKDF2(password, salt)
+    key = crypto_kdf.PBKDF2(password, salt)
 
     # generate the IV and encode it to store in the database
     iv = Random.new().read(AES.block_size)
@@ -92,7 +90,7 @@ def decrypt(inp, bot=None, db=None, notice=None):
     # generate the key from the password and salt
     password = split[0]
     salt = get_salt(bot)
-    key = PBKDF2(password, salt)
+    key = crypto_kdf.PBKDF2(password, salt)
 
     text = " ".join(split[1:])
 
diff --git a/plugins/help.py b/plugins/help.py
index 5aed73b..94ea21f 100644
--- a/plugins/help.py
+++ b/plugins/help.py
@@ -5,14 +5,17 @@ from util import hook
 
 @hook.command("help", autohelp=False)
 def help_command(inp, notice=None, conn=None, bot=None):
-    """help  -- Gives a list of commands/help for a command."""
+    """help  -- Gives a list of commands/help for a command.
+    :type bot: core.bot.CloudBot
+    :type conn: core.irc.BotConnection
+    """
 
     funcs = {}
     disabled = bot.config.get('disabled_plugins', [])
     disabled_comm = bot.config.get('disabled_commands', [])
     for command, (func, args) in bot.commands.items():
         fn = re.match(r'^plugins.(.+).py$', func._filename)
-        if fn.group(1).lower() not in disabled:
+        if fn is None and (func._filename not in disabled) or (fn.group(1).lower() not in disabled):
             if command not in disabled_comm:
                 if func.__doc__ is not None:
                     if func in funcs:
@@ -42,10 +45,10 @@ def help_command(inp, notice=None, conn=None, bot=None):
             for x in out[1:]:
                 notice(x)
         notice("For detailed help, do '{}help <example>' where <example> "
-               "is the name of the command you want help for.".format(conn.conf["command_prefix"]))
+               "is the name of the command you want help for.".format(conn.config["command_prefix"]))
 
     else:
         if inp in commands:
-            notice(conn.conf["command_prefix"] + commands[inp].__doc__)
+            notice(conn.config["command_prefix"] + commands[inp].__doc__)
         else:
-            notice("Command {}{} not found".format(conn.conf["command_prefix"], inp))
+            notice("Command {}{} not found".format(conn.config["command_prefix"], inp))
diff --git a/plugins/log.py b/plugins/log.py
index a08832f..553d766 100644
--- a/plugins/log.py
+++ b/plugins/log.py
@@ -49,7 +49,7 @@ def gmtime(format):
 
 def beautify(input):
     format = formats.get(input.command, '%(raw)s')
-    args = dict(input)
+    args = input.__dict__
 
     leng = len(args['paraml'])
     for n, p in enumerate(args['paraml']):
@@ -92,6 +92,10 @@ def get_log_fd(dir, server, chan):
 #@hook.singlethread
 @hook.event('*')
 def log(paraml, input=None, bot=None):
+    """
+
+    :type bot: core.bot.CloudBot
+    """
     timestamp = gmtime(timestamp_format)
 
     fd = get_log_fd(bot.data_dir, input.server, 'raw')
diff --git a/plugins/meme.py b/plugins/meme.py
new file mode 100644
index 0000000..71ca4c1
--- /dev/null
+++ b/plugins/meme.py
@@ -0,0 +1,120 @@
+from util import hook, http, web
+import shlex
+import requests
+import json
+
+GENURL = 'http://version1.api.memegenerator.co'
+
+POPULAR_URL = '{0}/Generators_Select_ByPopular'.format(GENURL)
+POPULAR_DAT = {
+    'pageIndex': '0',
+    'pageSize': '24',
+    'days': '',
+}
+
+SEARCH_URL = '{0}/Generators_Search'.format(GENURL)
+SEARCH_DAT = {
+    'q': None,
+    'pageIndex': '0',
+    'pageSize': '24',
+}
+
+INFO_URL = "{0}/Generator_Select_ByUrlNameOrGeneratorID".format(GENURL)
+INFO_DAT = {'urlName': None}
+
+ACTION_URL = "{0}/Instance_Create".format(GENURL)
+ACTION_DAT = {
+    'username': None,
+    'password': None,
+    'languageCode': 'en',
+    'generatorID': None,
+    'imageID': None,
+    'text0': None,
+    'text1': None,
+}
+
+
+def get_image_id_from_url(url):
+    return url.split("/")[-1].split(".")[0]
+
+
+@hook.command(autohelp=False)
+def listmemes(pattern):
+    memeinfo = []
+    if pattern:
+        url = SEARCH_URL
+        SEARCH_DAT.update({'q': pattern})
+        params = SEARCH_DAT
+    else:
+        url = POPULAR_URL
+        params = POPULAR_DAT
+
+    result = requests.get(url, params=params).json
+    if not result.get('success', False):
+        if result.get('errorMessage', None):
+            return result['errorMessage']
+        else:
+            return FIX_MEME
+
+    out = ""
+    for m in result['result']:
+        if out == "":
+            out = m['urlName'] + ": " + m['imageUrl']
+        else:
+            out = out + "\n" + m['urlName'] + ": " + m['imageUrl']
+    return "List of memes: %s" % web.haste(out)
+
+
+def get_api_result(*args, **kwargs):
+    response = requests.get(*args, **kwargs)
+    result = None
+    message = "API is broken. Please tell blha303 about this."
+    try:
+        jsondata = response.json()
+    except ValueError:
+        pass  # out is already set for this state
+    else:
+        if jsondata.get('success', False):
+            result = jsondata['result']
+            message = None
+        elif jsondata.get('errorMessage', False):
+            message = jsondata['errorMessage']
+    return result, message
+
+
+@hook.command
+def meme(inp, bot=None):
+    """meme <meme> "<topline>" "<bottomline>" - Generate meme. Get meme ID using .listmemes. You can make a section blank with .meme Meme "" "Bottom text only" """
+    keys = bot.config['api_keys']
+    if not 'meme_user' in keys or keys['meme_user'] == "MEMEGENERATOR USERNAME":
+        return "Please set username and password in config"
+    try:
+        user = keys['meme_user']
+        passw = keys['meme_pass']
+    except:
+        keys['meme_user'] = "MEMEGENERATOR USERNAME"
+        keys['meme_pass'] = "MEMEGENERATOR PASSWORD"
+        json.dump(bot.config, open('config', 'w'), sort_keys=True, indent=2)
+        return "Please set username and password in config"
+    inpsplit = shlex.split(inp)
+    INFO_DAT.update({'urlName': inpsplit[0]})
+    result, message = get_api_result(INFO_URL, params=INFO_DAT)
+    if result:
+        ACTION_DAT.update({
+            'username': user,
+            'password': passw,
+            'generatorID': result['generatorID'],
+            'imageID': get_image_id_from_url(result['imageUrl']),
+            'text0': inpsplit[1],
+            'text1': inpsplit[2],
+        })
+    else:
+        return message
+    result, message = get_api_result(ACTION_URL, params=ACTION_DAT)
+    if result:
+        try:
+            return web.isgd(result['instanceImageUrl'])
+        except (web.ShortenError, http.HTTPError) as error:
+            return result['instanceImageUrl']
+    else:
+        return message
diff --git a/plugins/minecraft_status.py b/plugins/minecraft_status.py
index 0a57ab0..7e884fe 100644
--- a/plugins/minecraft_status.py
+++ b/plugins/minecraft_status.py
@@ -2,8 +2,16 @@ import json
 
 from util import hook, http
 
+green_prefix = "\x02\x0f"
+green_suffix = ": \x033\x02\u2714"
+yellow_prefix = "\x02\x0f"
+yellow_suffix = ": \x037\x02\u26A0"
+red_prefix = "\x02\x0f"
+red_suffix = ": \x034\x02\u2716"
+
 
 @hook.command(autohelp=False)
+@hook.command("mcs", autohelp=False)
 def mcstatus(inp):
     """mcstatus -- Checks the status of various Mojang (the creators of Minecraft) servers."""
 
@@ -15,30 +23,20 @@ def mcstatus(inp):
     # lets just reformat this data to get in a nice format
     data = json.loads(request.replace("}", "").replace("{", "").replace("]", "}").replace("[", "{"))
 
-    out = []
-
     # use a loop so we don't have to update it if they add more servers
-    green = []
-    yellow = []
-    red = []
-    for server, status in list(data.items()):
+    servers = []
+    for server, status in data.items():
+        if server == "minecraft.net":
+            server = "MC|Website"
+        elif server.endswith(".mojang.com"):
+            server = "MJ|{}".format(server[:-11].capitalize())
+        elif server.endswith(".minecraft.net"):
+            server = "MC|{}".format(server[:-14].capitalize())
+
         if status == "green":
-            green.append(server)
+            servers.append("{}{}{}".format(green_prefix, server, green_suffix))
         elif status == "yellow":
-            yellow.append(server)
+            servers.append("{}{}{}".format(yellow_prefix, server, yellow_suffix))
         else:
-            red.append(server)
-
-    if green:
-        out = "\x033\x02Online\x02\x0f: " + ", ".join(green)
-        if yellow:
-            out += " "
-    if yellow:
-        out += "\x02Issues\x02: " + ", ".join(yellow)
-        if red:
-            out += " "
-    if red:
-        out += "\x034\x02Offline\x02\x0f: " + ", ".join(red)
-
-    return "\x0f" + out.replace(".mojang.com", ".mj") \
-                       .replace(".minecraft.net", ".mc")
+            servers.append("{}{}{}".format(red_prefix, server, red_suffix))
+    return "  ".join(servers)
diff --git a/plugins/namegen.py b/plugins/namegen.py
index 5f5a169..18670ed 100644
--- a/plugins/namegen.py
+++ b/plugins/namegen.py
@@ -4,9 +4,6 @@ import os
 from util import hook, text, textgen
 
 
-GEN_DIR = "./plugins/data/name_files/"
-
-
 def get_generator(_json):
     data = json.loads(_json)
     return textgen.TextGenerator(data["templates"],
@@ -16,13 +13,14 @@ def get_generator(_json):
 @hook.command(autohelp=False)
 def namegen(input, instance, bot):
     """namegen [generator] -- Generates some names using the chosen generator.
+    :type bot: core.bot.CloudBot
     'namegen list' will display a list of all generators."""
 
     # clean up the input
     inp = input.text.strip().lower()
 
     # get a list of available name generators
-    files = os.listdir(GEN_DIR)
+    files = os.listdir(os.path.join(bot.data_dir, "name_files"))
     all_modules = []
     for i in files:
         if os.path.splitext(i)[1] == ".json":
@@ -47,7 +45,7 @@ def namegen(input, instance, bot):
         return "Invalid name generator :("
 
     # load the name generator
-    with open(os.path.join(GEN_DIR, "{}.json".format(selected_module))) as f:
+    with open(os.path.join(bot.data_dir, "name_files", "{}.json".format(selected_module))) as f:
         try:
             generator = get_generator(f.read())
         except ValueError as error:
diff --git a/plugins/plpaste.py b/plugins/plpaste.py
index 238037d..d46e672 100644
--- a/plugins/plpaste.py
+++ b/plugins/plpaste.py
@@ -1,12 +1,14 @@
 from util import hook, web
+from os import listdir
 
 
-@hook.command(adminonly=True)
-def plpaste(inp):
-    if "/" in inp and inp.split("/")[0] != "util":
-        return "Invalid input"
-    try:
-        with open("plugins/%s.py" % inp) as f:
+@hook.command(permissions=["adminonly"])
+def plpaste(inp, bot=None):
+    if inp in bot.commands:
+        with open(bot.commands[inp][0].func_code.co_filename.strip()) as f:
             return web.haste(f.read(), ext='py')
-    except IOError:
-        return "Plugin not found (must be in plugins folder)"
+    elif inp + ".py" in listdir('plugins/'):
+        with open('plugins/{}.py'.format(inp)) as f:
+            return web.haste(f.read(), ext='py')
+    else:
+        return "Could not find specified plugin."
diff --git a/plugins/recipe.py b/plugins/recipe.py
new file mode 100644
index 0000000..bec27da
--- /dev/null
+++ b/plugins/recipe.py
@@ -0,0 +1,111 @@
+import random
+
+from util import hook, http, web
+
+METADATA_URL = "http://omnidator.appspot.com/microdata/json/?url={}"
+
+BASE_URL = "http://www.cookstr.com"
+SEARCH_URL = BASE_URL + "/searches"
+RANDOM_URL = SEARCH_URL + "/surprise"
+
+# set this to true to censor this plugin!
+censor = True
+phrases = [
+    "EAT SOME FUCKING \x02{}\x02",
+    "YOU WON'T NOT MAKE SOME FUCKING \x02{}\x02",
+    "HOW ABOUT SOME FUCKING \x02{}?\x02",
+    "WHY DON'T YOU EAT SOME FUCKING \x02{}?\x02",
+    "MAKE SOME FUCKING \x02{}\x02",
+    "INDUCE FOOD COMA WITH SOME FUCKING \x02{}\x02"
+    "CLASSILY PARTAKE IN SOME FUCKING \x02{}\x02",
+    "COOK UP SOME FUCKING \x02{}\x02",
+    "CURE YOUR MOUTH'S POST TRAUMATIC STRESS DISORDER WITH SOME FUCKING \x02{}\x02",
+    "PROCURE SOME CHILD LABOR TO COOK UP SOME FUCKING \x02{}\x02",
+    "YOUR INDECISION IS FAR LESS APPETIZING THAN SOME FUCKING \x02{}\x02"
+]
+
+clean_key = lambda i: i.split("#")[1]
+
+
+class ParseError(Exception):
+    pass
+
+
+def get_data(url):
+    """ Uses the omnidator API to parse the metadata from the provided URL """
+    try:
+        omni = http.get_json(METADATA_URL.format(url))
+    except (http.HTTPError, http.URLError) as e:
+        raise ParseError(e)
+    schemas = omni["@"]
+    for d in schemas:
+        if d["a"] == "<http://schema.org/Recipe>":
+            data = {clean_key(key): value for (key, value) in d.iteritems()
+                    if key.startswith("http://schema.org/Recipe")}
+            return data
+    raise ParseError("No recipe data found")
+
+
+@hook.command(autohelp=False)
+def recipe(inp):
+    """recipe [term] - Gets a recipe for [term], or ets a random recipe if [term] is not provided"""
+    if inp:
+        # get the recipe URL by searching
+        try:
+            search = http.get_soup(SEARCH_URL, query=inp.strip())
+        except (http.HTTPError, http.URLError) as e:
+            return "Could not get recipe: {}".format(e)
+
+        # find the list of results
+        result_list = search.find('div', {'class': 'found_results'})
+
+        if result_list:
+            results = result_list.find_all('div', {'class': 'recipe_result'})
+        else:
+            return "No results"
+
+        # pick a random front page result
+        result = random.choice(results)
+
+        # extract the URL from the result
+        url = BASE_URL + result.find('div', {'class': 'image-wrapper'}).find('a')['href']
+
+    else:
+        # get a random recipe URL
+        try:
+            page = http.open(RANDOM_URL)
+        except (http.HTTPError, http.URLError) as e:
+            return "Could not get recipe: {}".format(e)
+        url = page.geturl()
+
+    # use get_data() to get the recipe info from the URL
+    try:
+        data = get_data(url)
+    except ParseError as e:
+        return "Could not parse recipe: {}".format(e)
+
+    name = data["name"].strip()
+    return "Try eating \x02{}!\x02 - {}".format(name, web.try_isgd(url))
+
+
+@hook.command(autohelp=False)
+def dinner(inp):
+    """dinner - WTF IS FOR DINNER"""
+    try:
+        page = http.open(RANDOM_URL)
+    except (http.HTTPError, http.URLError) as e:
+        return "Could not get recipe: {}".format(e)
+    url = page.geturl()
+
+    try:
+        data = get_data(url)
+    except ParseError as e:
+        return "Could not parse recipe: {}".format(e)
+
+    name = data["name"].strip().upper()
+    text = random.choice(phrases).format(name)
+
+    if censor:
+        text = text.replace("FUCK", "F**K")
+
+    return "{} - {}".format(text, web.try_isgd(url))
\ No newline at end of file
diff --git a/plugins/regex_chans.py b/plugins/regex_chans.py
new file mode 100644
index 0000000..d9c902b
--- /dev/null
+++ b/plugins/regex_chans.py
@@ -0,0 +1,128 @@
+from util import hook
+
+
+# Default value.
+# If True, all channels without a setting will have regex enabled
+# If False, all channels without a setting will have regex disabled
+default_enabled = False
+
+db_ready = False
+
+
+def db_init(db):
+    global db_ready
+    if not db_ready:
+        db.execute("CREATE TABLE IF NOT EXISTS regexchans(channel PRIMARY KEY, status)")
+        db.commit()
+        db_ready = True
+
+
+def get_status(db, channel):
+    row = db.execute("SELECT status FROM regexchans WHERE channel = ?", [channel]).fetchone()
+    if row:
+        return row[0]
+    else:
+        return None
+
+
+def set_status(db, channel, status):
+    db.execute("REPLACE INTO regexchans (channel, status) VALUES(?, ?)", [channel, status])
+    db.commit()
+
+
+def delete_status(db, channel):
+    db.execute("DELETE FROM regexchans WHERE channel = ?", [channel])
+    db.commit()
+
+
+def list_status(db):
+    row = db.execute("SELECT * FROM regexchans").fetchall()
+    result = None
+    for values in row:
+        if result:
+            result += u", {}: {}".format(values[0], values[1])
+        else:
+            result = u"{}: {}".format(values[0], values[1])
+    return result
+
+
+@hook.sieve
+def sieve_regex(bot, inp, func, kind, args):
+    db = bot.get_db_connection(inp.conn)
+    db_init(db)
+    if kind == 'regex' and inp.chan.startswith("#") and func.__name__ != 'factoid':
+        chanstatus = get_status(db, inp.chan)
+        if chanstatus != "ENABLED" and (chanstatus == "DISABLED" or not default_enabled):
+            print("Denying input.raw={}, kind={}, args={} from {}".format(inp.raw, kind, args, inp.chan))
+            return None
+        print("Allowing input.raw={}, kind={}, args={} from {}".format(inp.raw, kind, args, inp.chan))
+
+    return inp
+
+
+@hook.command(permissions=["botcontrol"])
+def enableregex(inp, db=None, message=None, notice=None, chan=None, nick=None):
+    db_init(db)
+    inp = inp.strip().lower()
+    if not inp:
+        channel = chan
+    elif inp.startswith("#"):
+        channel = inp
+    else:
+        channel = u"#{}".format(inp)
+
+    message(u"Enabling regex matching (youtube, etc) (issued by {})".format(nick), target=channel)
+    notice(u"Enabling regex matching (youtube, etc) in channel {}".format(channel))
+    set_status(db, channel, "ENABLED")
+
+
+@hook.command(permissions=["botcontrol"])
+def disableregex(inp, db=None, message=None, notice=None, chan=None, nick=None):
+    db_init(db)
+    inp = inp.strip().lower()
+    if not inp:
+        channel = chan
+    elif inp.startswith("#"):
+        channel = inp
+    else:
+        channel = u"#{}".format(inp)
+
+    message(u"Disabling regex matching (youtube, etc) (issued by {})".format(nick), target=channel)
+    notice(u"Disabling regex matching (youtube, etc) in channel {}".format(channel))
+    set_status(db, channel, "DISABLED")
+
+
+@hook.command(permissions=["botcontrol"])
+def resetregex(inp, db=None, message=None, notice=None, chan=None, nick=None):
+    db_init(db)
+    inp = inp.strip().lower()
+    if not inp:
+        channel = chan
+    elif inp.startswith("#"):
+        channel = inp
+    else:
+        channel = u"#{}".format(inp)
+
+    message(u"Resetting regex matching setting (youtube, etc) (issued by {})".format(nick), target=channel)
+    notice(u"Resetting regex matching setting (youtube, etc) in channel {}".format(channel))
+    delete_status(db, channel)
+
+
+@hook.command(permissions=["botcontrol"])
+def regexstatus(inp, db=None, chan=None):
+    db_init(db)
+    inp = inp.strip().lower()
+    if not inp:
+        channel = chan
+    elif inp.startswith("#"):
+        channel = inp
+    else:
+        channel = u"#{}".format(inp)
+
+    return u"Regex status for {}: {}".format(channel, get_status(db, channel))
+
+
+@hook.command(permissions=["botcontrol"])
+def listregex(inp, db=None):
+    db_init(db)
+    return list_status(db)
diff --git a/plugins/steal.py b/plugins/steal.py
new file mode 100644
index 0000000..78ccddb
--- /dev/null
+++ b/plugins/steal.py
@@ -0,0 +1,62 @@
+from util import hook
+from random import randint
+
+
+def db_init(db):
+    db.execute("CREATE TABLE IF NOT EXISTS stolen(word, PRIMARY KEY (word))")
+    db.commit()
+
+
+def get_random(db):
+    count = db.execute("SELECT COUNT(word) FROM stolen").fetchone()[0]
+    row = db.execute("SELECT word FROM stolen LIMIT 1 OFFSET ?", [randint(0, int(count-1))]).fetchone()
+    if row:
+        return row[0]
+    else:
+        return None
+
+
+def list_steals(db):
+    row = db.execute("SELECT word FROM stolen").fetchall()
+    return row
+
+
+def add_word(db, stolen):
+    db.execute("REPLACE INTO stolen (word) VALUES(?)", [stolen])
+    db.commit()
+
+
+@hook.command(autoHelp=False)
+@hook.command("steal", autoHelp=False)
+def stealit(inp, idb=None, nick=None, action=None):
+    """steal [[object] username]- Steals an object from a user or randomly chooses a previously stolen object if none is given"""
+    db_init(idb)
+    args = inp.strip().split()
+    if not args:
+        steal_from = nick
+        to_steal = get_random(idb)
+        action("steals {}'s {}".format(steal_from, to_steal))
+    elif len(args) < 2:
+        steal_from = args[0]
+        to_steal = get_random(idb)
+        action("steals {}'s {}".format(steal_from, to_steal))
+    else:
+        steal_from = args[len(args) - 1]
+        to_steal = " ".join(args[0:-1])
+        action("steals {}'s {}".format(steal_from, to_steal))
+        add_word(idb, to_steal)
+
+
+@hook.command(autoHelp=False, permissions=["adminonly"])
+def liststolen(inp, idb=None, reply=None):
+    db_init(idb)
+    text = False
+    for word in list_steals(idb):
+        if not text:
+            text = word[0]
+        else:
+            text += ", {}".format(word[0])
+        if len(text) > 400:
+            reply(text.rsplit(', ', 1)[0])
+            text = word[0]
+    return text
diff --git a/requirements.txt b/requirements.txt
index 3aa3736..0884a93 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -1,3 +1,4 @@
+Crypto
 sqlalchemy
 oauth2
 pygeoip
@@ -11,3 +12,7 @@ tweepy
 pygeoip
 BeautifulSoup4
 pycrypto
+requests
+kdf
+pygeoip
+requests
\ No newline at end of file
-- 
1.9.1

