From 1400ee220648a47ec6b769718a894387055ae7f2 Mon Sep 17 00:00:00 2001
From: Dabo Ross <daboross@daboross.net>
Date: Sat, 5 Apr 2014 22:54:28 -0700
Subject: [PATCH] MORE STUFF


diff --git a/core/main.py b/core/main.py
index 8c2b675..6cfe8cb 100644
--- a/core/main.py
+++ b/core/main.py
@@ -6,50 +6,85 @@ import re
 _thread.stack_size(1024 * 512)  # reduce vm size
 
 
-#TODO: redesign this messy thing
-class Input(dict):
+class Input:
     def __init__(self, bot, conn, raw, prefix, command, params,
                  nick, user, host, mask, paraml, msg):
-
-        chan = paraml[0].lower()
-        if chan == conn.nick.lower():  # is a PM
-            chan = nick
-
-        def message(message, target=chan):
-            """sends a message to a specific or current channel/user"""
-            conn.msg(target, message)
-
-        def reply(message, target=chan):
-            """sends a message to the current channel/user with a prefix"""
-            if target == nick:
-                conn.msg(target, message)
-            else:
-                conn.msg(target, "{}, {}".format(nick, message))
-
-        def action(message, target=chan):
-            """sends an action to the current channel/user or a specific channel/user"""
-            conn.ctcp(target, "ACTION", message)
-
-        def ctcp(message, ctcp_type, target=chan):
-            """sends an ctcp to the current channel/user or a specific channel/user"""
-            conn.ctcp(target, ctcp_type, message)
-
-        def notice(message, target=nick):
-            """sends a notice to the current channel/user or a specific channel/user"""
-            conn.cmd('NOTICE', [target, message])
-
-        dict.__init__(self, conn=conn, raw=raw, prefix=prefix, command=command,
-                      params=params, nick=nick, user=user, host=host, mask=mask,
-                      paraml=paraml, msg=msg, server=conn.server, chan=chan,
-                      notice=notice, message=message, reply=reply, bot=bot,
-                      action=action, ctcp=ctcp, lastparam=paraml[-1])
-
-    # make dict keys accessible as attributes
-    def __getattr__(self, key):
-        return self.get(key)
-
-    def __setattr__(self, key, value):
-        self[key] = value
+        """
+        :type bot: core.bot.CloudBot
+        :type conn: core.irc.BotConnection
+        """
+        self.bot = bot
+        self.conn = conn
+        self.raw = raw
+        self.prefix = prefix
+        self.command = command
+        self.params = params
+        self.nick = nick
+        self.user = user
+        self.host = host
+        self.mask = mask
+        self.paraml = paraml
+        self.msg = msg
+        self.input = self
+        self.text = self.paraml  # TODO: Right thing to do?
+        self.server = conn.server
+        self.lastparam = paraml[-1]
+        self.chan = paraml[0].lower()
+
+        if self.chan == conn.nick.lower():  # is a PM
+            self.chan = nick
+
+    def message(self, message, target=None):
+        """sends a message to a specific or current channel/user
+        :type target: str
+        :type message: str
+        """
+        if target is None:
+            target = self.chan
+        self.conn.msg(target, message)
+
+    def reply(self, message, target=None):
+        """sends a message to the current channel/user with a prefix
+        :type target: str
+        :type message: str
+        """
+        if target is None:
+            target = self.chan
+
+        if target == self.nick:
+            self.conn.msg(target, message)
+        else:
+            self.conn.msg(target, "{}, {}".format(self.nick, message))
+
+    def action(self, message, target=None):
+        """sends an action to the current channel/user or a specific channel/user
+        :type target: str
+        :type message: str
+        """
+        if target is None:
+            target = self.chan
+
+        self.conn.ctcp(target, "ACTION", message)
+
+    def ctcp(self, message, ctcp_type, target=None):
+        """sends an ctcp to the current channel/user or a specific channel/user
+        :type target: str
+        :type ctcp_type: str
+        :type message: str
+        """
+        if target is None:
+            target = self.chan
+        self.conn.ctcp(target, ctcp_type, message)
+
+    def notice(self, message, target=None):
+        """sends a notice to the current channel/user or a specific channel/user
+        :type target: str
+        :type message: str
+        """
+        if target is None:
+            target = self.nick
+
+        self.conn.cmd('NOTICE', [target, message])
 
 
 def run(bot, func, input):
@@ -62,12 +97,6 @@ def run(bot, func, input):
     uses_db = True
     # TODO: change to bot.get_db_session()
 
-    if not 'text' in input:
-        input.text = input.paraml
-
-    if not 'input' in input:
-        input.input = input
-
     if uses_db:
         # create SQLAlchemy session
         bot.logger.debug("Opened DB session for: {}".format(func._filename))
@@ -79,10 +108,15 @@ def run(bot, func, input):
     specifications = inspect.getargspec(func)
     required_args = specifications[0]
     default_args = specifications[3]
+    if required_args is None:
+        required_args = []
+    if default_args is None:
+        default_args = []
+
     if len(required_args) - len(default_args) == 1:
         # The function is using the old format, with all arguments with defaults except for 'text'
         # Assume that the funct want the first non-default arg to be 'input'
-        parameters.append(input.param1)
+        parameters = [input.text]
         required_args = required_args[1:]  # Trim the first argument, as it's been assigned as a non-named parameter
 
         for required_arg in required_args:
@@ -90,13 +124,14 @@ def run(bot, func, input):
             value = getattr(input, required_arg)
 
             named_parameters[required_arg] = value
-    else:
+    elif len(required_args) - len(default_args) == 3:
         # We're assuming that this function is using the new format
-        # We're ignoring all parameters with default values, and treating all other parameters as named
-        # TODO: Implement this
+        # Treat the first three parameters as input, instance, bot
+        parameters = [input, input.conn, input.bot]
+    else:
         print("Warning, ignoring function which doesn't fit arg spec. Argument specs: {}".format(specifications))
-        pass
-    out = None
+        return
+
     try:
         out = func(*parameters, **named_parameters)
     except:
@@ -114,7 +149,6 @@ def run(bot, func, input):
 
 def do_sieve(sieve, bot, input, func, type, args):
     """
-
     :type bot: core.bot.CloudBot
     """
     try:
@@ -162,7 +196,7 @@ def dispatch(bot, input, kind, func, args, autohelp=False):
         if input is None:
             return
 
-    if autohelp and args.get('autohelp', True) and not input.inp and func.__doc__ is not None:
+    if autohelp and args.get('autohelp', True) and not input.text and func.__doc__ is not None:
         input.notice(input.conn.config["command_prefix"] + func.__doc__)
         return
 
diff --git a/plugins/admin.py b/plugins/admin.py
index 5b285c4..beab945 100644
--- a/plugins/admin.py
+++ b/plugins/admin.py
@@ -1,9 +1,4 @@
-import os
-import sys
 import re
-import json
-import time
-import subprocess
 
 from util import hook
 
@@ -103,8 +98,8 @@ def adduser(inp, bot=None, notice=None):
     bot.config.save_config()
 
 
-@hook.command("quit", autohelp=False)
-@hook.command(autohelp=False)
+@hook.command(permissions=["botcontrol"], autohelp=False)
+@hook.command("quit", permissions=["botcontrol"], autohelp=False)
 def stop(inp, bot=None):
     """stop [reason] -- Kills the bot with [reason] as its quit message."""
     if inp:
@@ -113,7 +108,7 @@ def stop(inp, bot=None):
         bot.stop()
 
 
-@hook.command(autohelp=False)
+@hook.command(permissions=["botcontrol"], autohelp=False)
 def restart(inp, bot=None):
     """restart [reason] -- Restarts the bot with [reason] as its quit message."""
     if inp:
@@ -122,13 +117,6 @@ def restart(inp, bot=None):
         bot.restart()
 
 
-
-@hook.command(autohelp=False, permissions=["botcontrol"])
-def clearlogs(inp, input=None):
-    """clearlogs -- Clears the bots log(s)."""
-    subprocess.call(["./cloudbot", "clear"])
-
-
 @hook.command(permissions=["botcontrol"])
 def join(inp, conn=None, notice=None):
     """join <channel> -- Joins <channel>."""
@@ -139,7 +127,7 @@ def join(inp, conn=None, notice=None):
         conn.join(target)
 
 
-@hook.command(autohelp=False, permissions=["botcontrol"])
+@hook.command(permissions=["botcontrol"], autohelp=False)
 def part(inp, conn=None, chan=None, notice=None):
     """part <channel> -- Leaves <channel>.
     If [channel] is blank the bot will leave the
diff --git a/plugins/help.py b/plugins/help.py
index 5aed73b..94ea21f 100644
--- a/plugins/help.py
+++ b/plugins/help.py
@@ -5,14 +5,17 @@ from util import hook
 
 @hook.command("help", autohelp=False)
 def help_command(inp, notice=None, conn=None, bot=None):
-    """help  -- Gives a list of commands/help for a command."""
+    """help  -- Gives a list of commands/help for a command.
+    :type bot: core.bot.CloudBot
+    :type conn: core.irc.BotConnection
+    """
 
     funcs = {}
     disabled = bot.config.get('disabled_plugins', [])
     disabled_comm = bot.config.get('disabled_commands', [])
     for command, (func, args) in bot.commands.items():
         fn = re.match(r'^plugins.(.+).py$', func._filename)
-        if fn.group(1).lower() not in disabled:
+        if fn is None and (func._filename not in disabled) or (fn.group(1).lower() not in disabled):
             if command not in disabled_comm:
                 if func.__doc__ is not None:
                     if func in funcs:
@@ -42,10 +45,10 @@ def help_command(inp, notice=None, conn=None, bot=None):
             for x in out[1:]:
                 notice(x)
         notice("For detailed help, do '{}help <example>' where <example> "
-               "is the name of the command you want help for.".format(conn.conf["command_prefix"]))
+               "is the name of the command you want help for.".format(conn.config["command_prefix"]))
 
     else:
         if inp in commands:
-            notice(conn.conf["command_prefix"] + commands[inp].__doc__)
+            notice(conn.config["command_prefix"] + commands[inp].__doc__)
         else:
-            notice("Command {}{} not found".format(conn.conf["command_prefix"], inp))
+            notice("Command {}{} not found".format(conn.config["command_prefix"], inp))
diff --git a/plugins/log.py b/plugins/log.py
index 9b1c694..553d766 100644
--- a/plugins/log.py
+++ b/plugins/log.py
@@ -49,7 +49,7 @@ def gmtime(format):
 
 def beautify(input):
     format = formats.get(input.command, '%(raw)s')
-    args = dict(input)
+    args = input.__dict__
 
     leng = len(args['paraml'])
     for n, p in enumerate(args['paraml']):
diff --git a/plugins/namegen.py b/plugins/namegen.py
index 5f5a169..18670ed 100644
--- a/plugins/namegen.py
+++ b/plugins/namegen.py
@@ -4,9 +4,6 @@ import os
 from util import hook, text, textgen
 
 
-GEN_DIR = "./plugins/data/name_files/"
-
-
 def get_generator(_json):
     data = json.loads(_json)
     return textgen.TextGenerator(data["templates"],
@@ -16,13 +13,14 @@ def get_generator(_json):
 @hook.command(autohelp=False)
 def namegen(input, instance, bot):
     """namegen [generator] -- Generates some names using the chosen generator.
+    :type bot: core.bot.CloudBot
     'namegen list' will display a list of all generators."""
 
     # clean up the input
     inp = input.text.strip().lower()
 
     # get a list of available name generators
-    files = os.listdir(GEN_DIR)
+    files = os.listdir(os.path.join(bot.data_dir, "name_files"))
     all_modules = []
     for i in files:
         if os.path.splitext(i)[1] == ".json":
@@ -47,7 +45,7 @@ def namegen(input, instance, bot):
         return "Invalid name generator :("
 
     # load the name generator
-    with open(os.path.join(GEN_DIR, "{}.json".format(selected_module))) as f:
+    with open(os.path.join(bot.data_dir, "name_files", "{}.json".format(selected_module))) as f:
         try:
             generator = get_generator(f.read())
         except ValueError as error:
-- 
1.9.1

