From c053a8d99428b214d524cc2adb377be8976464ba Mon Sep 17 00:00:00 2001
From: Dabo Ross <daboross@daboross.net>
Date: Tue, 22 Apr 2014 21:34:42 -0700
Subject: [PATCH] Add a "quick" plugin testing system, for automated plugin
 testing using a real bot object.

The quick plugin testing, or "qpt", can be enabled with the "--qpt" command line argument.

diff --git a/core/irc.py b/core/irc.py
index 30f541b..460144d 100644
--- a/core/irc.py
+++ b/core/irc.py
@@ -5,6 +5,7 @@ import threading
 import queue
 from ssl import wrap_socket, CERT_NONE, CERT_REQUIRED, SSLError
 
+from util import qpt
 from core.permissions import PermissionManager
 
 irc_prefix_rem = re.compile(r'(.*?) (.*?) (.*)').match
@@ -227,6 +228,49 @@ class IRCConnection(object):
         self.connect()
 
 
+class QptReceiveThread(threading.Thread):
+    """receives messages from IRC and puts them in the input_queue
+    :type input_queue: queue.Queue
+    """
+
+    def __init__(self, conn):
+        """
+        :type conn: BotConnection
+        """
+        self.conn = conn
+        self.bot = conn.bot
+        self.logger = conn.logger
+        self.input_queue = conn.input_queue
+        self.output_queue = conn.output_queue
+        self.shutdown = False
+        threading.Thread.__init__(self)
+
+    def run(self):
+        time.sleep(1.0)
+        qpt.run_tests(self, self.logger, self.bot, self.conn, self.input_queue, self.output_queue)
+        self.bot.stop()
+
+
+class QptIRCConnection(object):
+    """fake IRC connection which just feeds back fake input"""
+
+    def __init__(self, conn):
+        self.conn = conn
+        self.receive_thread = None
+
+    def connect(self):
+        self.receive_thread = QptReceiveThread(self.conn)
+        self.receive_thread.start()
+
+    def stop(self):
+        self.receive_thread.shutdown = True
+        time.sleep(0.1)
+
+    def reconnect(self):
+        self.stop()
+        self.connect()
+
+
 class BotConnection(object):
     """ A BotConnection represents each connection the bot makes to an IRC server
     :type bot: core.bot.CloudBot
@@ -296,8 +340,11 @@ class BotConnection(object):
         self.permissions = PermissionManager(self)
 
         # create the IRC connection and connect
-        self.connection = IRCConnection(self.bot.logger, self.name, self.server, self.port, self.input_queue,
-                                        self.output_queue, self.ssl)
+        if qpt.is_enabled():
+            self.connection = QptIRCConnection(self)
+        else:
+            self.connection = IRCConnection(self.bot.logger, self.name, self.server, self.port, self.input_queue,
+                                            self.output_queue, self.ssl)
         self.connection.connect()
 
         self.set_pass(self.config["connection"].get("password"))
diff --git a/util/qpt.py b/util/qpt.py
new file mode 100644
index 0000000..2fa3f10
--- /dev/null
+++ b/util/qpt.py
@@ -0,0 +1,133 @@
+import glob
+import importlib
+import inspect
+import os
+import queue
+import traceback
+import sys
+import time
+
+
+def _test_hook(func, times):
+    specifications = inspect.getargspec(func)
+    args = specifications[0]
+    if args is None:
+        args = []
+    func._qpt_test = True
+    func._qpt_args = args
+    func._qpt_name = func.__module__ + "." + func.__name__
+    func._qpt_times = times
+    return func
+
+
+def print_both(text):
+    pass
+    print()
+    print("# " + text)
+    print()
+
+
+def print_before(text):
+    pass
+    print()
+    print("# " + text)
+
+
+def print_after(text):
+    pass
+    print("# " + text)
+    print()
+
+
+def print_none(text):
+    pass
+    print("# " + text)
+
+
+def test(times=1):
+    return lambda func: _test_hook(func, times)
+
+
+def run_test(func, bot, conn, input_queue, output_queue):
+    """
+    :type bot: core.bot.CloudBot
+    :type conn: core.irc.BotConnection
+    :type input_queue: queue.Queue
+    :type output_queue: queue.Queue
+    """
+    if not hasattr(func, "_qpt_test") or not func._qpt_test:
+        return
+
+    for test_number in range(func._qpt_times):
+        # each test might want to run multiple times, with the test number as an argument.
+        # We'll treat each of these times as a different test
+
+        print_both("Running test {} #{}".format(func._qpt_name, test_number))
+        params = []
+        for arg in func._qpt_args:
+            if arg == "bot":
+                params.append(bot)
+            elif arg == "conn":
+                params.append(conn)
+            elif arg == "get":
+                params.append(lambda: output_queue.get(timeout=5))
+            elif arg == "send":
+                params.append(lambda line: input_queue.put(line))
+            elif arg == "test_number":
+                params.append(test_number)
+            else:
+                print_before("Test {} #{} Failure: required invalid arg {}".format(func._qpt_name, test_number, arg))
+                continue
+        try:
+            func(*params)
+        except queue.Empty:
+            print_before("Test {} #{} Failure: queue get failed".format(func._qpt_name, test_number))
+            continue
+        except Exception:
+            print_before("Test {} #{} Failure:".format(func._qpt_name, test_number))
+            sys.stdout.flush()
+            traceback.print_exc()
+            continue
+        else:
+            print_before("Test {} #{} success".format(func._qpt_name, test_number))
+            continue
+
+    # wait 0.5 second between tests
+    time.sleep(0.5)
+
+
+def run_tests(obj_with_shutdown, logger, bot, conn, input_queue, output_queue):
+    files = set(glob.glob(os.path.join("qpt_tests", '*.py')))
+
+    for file in files:
+
+        if obj_with_shutdown.shutdown:
+            return
+        title = os.path.splitext(os.path.basename(file))[0]
+
+        if title == "__init__":
+            return  # ignore __init__
+
+        try:
+            module = importlib.import_module("qpt_tests." + title)
+        except Exception:
+            print_both("Failed to start tests in {}:".format(title))
+            traceback.print_exc()
+            continue
+
+        for func in module.__dict__.values():
+
+            if obj_with_shutdown.shutdown:
+                return
+
+            while not output_queue.empty():
+                print_none("Removed '{}' from queue.".format(output_queue.get()))
+
+            run_test(func, bot, conn, input_queue, output_queue)
+
+            # wait 1 second between tests
+            time.sleep(0.5)
+
+
+def is_enabled():
+    return "--qpt" in sys.argv
-- 
1.9.2

