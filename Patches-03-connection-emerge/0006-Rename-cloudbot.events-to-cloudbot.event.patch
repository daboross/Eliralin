From 1e96486597f5dbdf48096ee757d68bdd1c7dae98 Mon Sep 17 00:00:00 2001
From: Dabo Ross <daboross@daboross.net>
Date: Fri, 20 Jun 2014 13:38:49 -0500
Subject: [PATCH] Rename cloudbot.events to cloudbot.event


diff --git a/cloudbot/__init__.py b/cloudbot/__init__.py
index 5d91238..9d779be 100644
--- a/cloudbot/__init__.py
+++ b/cloudbot/__init__.py
@@ -12,7 +12,7 @@ import os
 
 __version__ = "0.1.1.dev0"
 
-__all__ = ["util", "bot", "connection", "config", "permissions", "pluginmanager", "events", "hook", "dev_mode",
+__all__ = ["util", "bot", "connection", "config", "permissions", "pluginmanager", "event", "hook", "dev_mode",
            "log_dir"]
 
 
diff --git a/cloudbot/bot.py b/cloudbot/bot.py
index 6b8c83f..67b95ba 100644
--- a/cloudbot/bot.py
+++ b/cloudbot/bot.py
@@ -14,7 +14,7 @@ from cloudbot.client import Client
 from cloudbot.config import Config
 from cloudbot.reloader import PluginReloader
 from cloudbot.pluginmanager import PluginManager
-from cloudbot.events import BaseEvent, CommandEvent, RegexEvent, EventType
+from cloudbot.event import BaseEvent, CommandEvent, RegexEvent, EventType
 from cloudbot.util import botvars, formatting
 from cloudbot.clients.irc import IrcClient
 
diff --git a/cloudbot/clients/irc.py b/cloudbot/clients/irc.py
index ef06266..3c8b1a4 100644
--- a/cloudbot/clients/irc.py
+++ b/cloudbot/clients/irc.py
@@ -6,7 +6,7 @@ import logging
 from ssl import SSLContext
 
 from cloudbot.client import Client
-from cloudbot.events import BaseEvent, EventType
+from cloudbot.event import BaseEvent, EventType
 
 logger = logging.getLogger("cloudbot")
 
diff --git a/cloudbot/event.py b/cloudbot/event.py
new file mode 100644
index 0000000..a0c895f
--- /dev/null
+++ b/cloudbot/event.py
@@ -0,0 +1,373 @@
+import asyncio
+import enum
+import logging
+import concurrent.futures
+
+logger = logging.getLogger("cloudbot")
+
+
+@enum.unique
+class EventType(enum.Enum):
+    message = 0
+    action = 1
+    # TODO: Do we actually want to have a 'notice' event type? Should the NOTICE command be a 'message' type?
+    notice = 2
+    join = 3
+    part = 4
+    kick = 5
+    other = 6
+
+
+class BaseEvent:
+    """
+    :type bot: cloudbot.bot.CloudBot
+    :type conn: cloudbot.client.Client
+    :type hook: cloudbot.pluginmanager.Hook
+    :type type: EventType
+    :type content: str
+    :type target: str
+    :type chan: str
+    :type nick: str
+    :type user: str
+    :type host: str
+    :type mask: str
+    :type db: sqlalchemy.orm.Session
+    :type db_executor: concurrent.futures.ThreadPoolExecutor
+    :type irc_raw: str
+    :type irc_prefix: str
+    :type irc_command: str
+    :type irc_paramlist: str
+    :type irc_ctcp_text: str
+    """
+
+    def __init__(self, *, bot=None, hook=None, conn=None, base_event=None, event_type=EventType.other, content=None,
+                 target=None, channel=None, nick=None, user=None, host=None, mask=None, irc_raw=None, irc_prefix=None,
+                 irc_command=None, irc_paramlist=None, irc_ctcp_text=None):
+        """
+        All of these parameters except for `bot` and `hook` are optional.
+        The irc_* parameters should only be specified for IRC events.
+
+        Note that the `bot` argument may be left out if you specify a `base_event`.
+
+        :param bot: The CloudBot instance this event was triggered from
+        :param conn: The Client instance this event was triggered from
+        :param hook: The hook this event will be passed to
+        :param base_event: The base event that this event is based on. If this parameter is not None, then nick, user,
+                            host, mask, and irc_* arguments are ignored
+        :param event_type: The type of the event
+        :param content: The content of the message, or the reason for an join or part
+        :param target: The target of the action, for example the user being kicked, or invited
+        :param channel: The channel that this action took place in
+        :param nick: The nickname of the sender that triggered this event
+        :param user: The user of the sender that triggered this event
+        :param host: The host of the sender that triggered this event
+        :param mask: The mask of the sender that triggered this event (nick!user@host)
+        :param irc_raw: The raw IRC line
+        :param irc_prefix: The raw IRC prefix
+        :param irc_command: The IRC command
+        :param irc_paramlist: The list of params for the IRC command. If the last param is a content param, the ':'
+                                should be removed from the front.
+        :param irc_ctcp_text: CTCP text if this message is a CTCP command
+        :type bot: cloudbot.bot.CloudBot
+        :type conn: cloudbot.client.Client
+        :type hook: cloudbot.pluginmanager.Hook
+        :type base_event: cloudbot.event.BaseEvent
+        :type content: str
+        :type target: str
+        :type event_type: EventType
+        :type nick: str
+        :type user: str
+        :type host: str
+        :type mask: str
+        :type irc_raw: str
+        :type irc_prefix: str
+        :type irc_command: str
+        :type irc_paramlist: list[str]
+        :type irc_ctcp_text: str
+        """
+        self.db = None
+        self.db_executor = None
+        self.bot = bot
+        self.conn = conn
+        self.hook = hook
+        if base_event is not None:
+            # We're copying an event, so inherit values
+            if self.bot is None and base_event.bot is not None:
+                self.bot = base_event.bot
+            if self.conn is None and base_event.conn is not None:
+                self.conn = base_event.conn
+            if self.hook is None and base_event.hook is not None:
+                self.hook = base_event.hook
+
+            # If base_event is provided, don't check these parameters, just inherit
+            self.type = base_event.type
+            self.content = base_event.content
+            self.target = base_event.target
+            self.chan = base_event.chan
+            self.nick = base_event.nick
+            self.user = base_event.user
+            self.host = base_event.host
+            self.mask = base_event.mask
+            # irc-specific parameters
+            self.irc_raw = base_event.irc_raw
+            self.irc_prefix = base_event.irc_prefix
+            self.irc_command = base_event.irc_command
+            self.irc_paramlist = base_event.irc_paramlist
+            self.irc_ctcp_text = base_event.irc_ctcp_text
+        else:
+            # Since base_event wasn't provided, we can take these parameters
+            self.type = event_type
+            self.content = content
+            self.target = target
+            self.chan = channel
+            self.nick = nick
+            self.user = user
+            self.host = host
+            self.mask = mask
+            # irc-specific parameters
+            self.irc_raw = irc_raw
+            self.irc_prefix = irc_prefix
+            self.irc_command = irc_command
+            self.irc_paramlist = irc_paramlist
+            self.irc_ctcp_text = irc_ctcp_text
+
+    @asyncio.coroutine
+    def prepare(self):
+        """
+        Initializes this event to be run through it's hook
+
+        Mainly, initializes a database object on this event, if the hook requires it.
+
+        This method is for when the hook is *not* threaded (event.hook.threaded is False).
+        If you need to add a db to a threaded hook, use prepare_threaded.
+        """
+
+        if self.hook is None:
+            raise ValueError("event.hook is required to prepare an event")
+
+        if "db" in self.hook.required_args:
+            logger.debug("Opening database session for {}:threaded=False".format(self.hook.description))
+
+            # we're running a coroutine hook with a db, so initialise an executor pool
+            self.db_executor = concurrent.futures.ThreadPoolExecutor(1)
+            # be sure to initialize the db in the database executor, so it will be accessible in that thread.
+            self.db = yield from self.async(self.bot.db_session)
+
+    def prepare_threaded(self):
+        """
+        Initializes this event to be run through it's hook
+
+        Mainly, initializes the database object on this event, if the hook requires it.
+
+        This method is for when the hook is threaded (event.hook.threaded is True).
+        If you need to add a db to a coroutine hook, use prepare.
+        """
+
+        if self.hook is None:
+            raise ValueError("event.hook is required to prepare an event")
+
+        if "db" in self.hook.required_args:
+            logger.debug("Opening database session for {}:threaded=True".format(self.hook.description))
+
+            self.db = self.bot.db_session()
+
+    @asyncio.coroutine
+    def close(self):
+        """
+        Closes this event after running it through it's hook.
+
+        Mainly, closes the database connection attached to this event (if any).
+
+        This method is for when the hook is *not* threaded (event.hook.threaded is False).
+        If you need to add a db to a threaded hook, use close_threaded.
+        """
+        if self.hook is None:
+            raise ValueError("event.hook is required to close an event")
+
+        if self.db is not None:
+            logger.debug("Closing database session for {}:threaded=False".format(self.hook.description))
+            # be sure the close the database in the database executor, as it is only accessable in that one thread
+            yield from self.async(self.db.close)
+            self.db = None
+
+    def close_threaded(self):
+        """
+        Closes this event after running it through it's hook.
+
+        Mainly, closes the database connection attached to this event (if any).
+
+        This method is for when the hook is threaded (event.hook.threaded is True).
+        If you need to add a db to a coroutine hook, use close.
+        """
+        if self.hook is None:
+            raise ValueError("event.hook is required to close an event")
+        if self.db is not None:
+            logger.debug("Closing database session for {}:threaded=True".format(self.hook.description))
+            self.db.close()
+            self.db = None
+
+    @property
+    def event(self):
+        """
+        :rtype: BaseEvent
+        """
+        return self
+
+    @property
+    def loop(self):
+        """
+        :rtype: asyncio.events.AbstractEventLoop
+        """
+        return self.bot.loop
+
+    @property
+    def logger(self):
+        return logger
+
+    def message(self, message, target=None):
+        """sends a message to a specific or current channel/user
+        :type message: str
+        :type target: str
+        """
+        if target is None:
+            if self.chan is None:
+                raise ValueError("Target must be specified when chan is not assigned")
+            target = self.chan
+        self.conn.message(target, message)
+
+    def reply(self, message, target=None):
+        """sends a message to the current channel/user with a prefix
+        :type message: str
+        :type target: str
+        """
+        if target is None:
+            if self.chan is None:
+                raise ValueError("Target must be specified when chan is not assigned")
+            target = self.chan
+
+        if target == self.nick:
+            self.conn.message(target, message)
+        else:
+            self.conn.message(target, "({}) {}".format(self.nick, message))
+
+    def action(self, message, target=None):
+        """sends an action to the current channel/user or a specific channel/user
+        :type message: str
+        :type target: str
+        """
+        if target is None:
+            if self.chan is None:
+                raise ValueError("Target must be specified when chan is not assigned")
+            target = self.chan
+
+        self.conn.action(target, message)
+
+    def ctcp(self, message, ctcp_type, target=None):
+        """sends an ctcp to the current channel/user or a specific channel/user
+        :type message: str
+        :type ctcp_type: str
+        :type target: str
+        """
+        if target is None:
+            if self.chan is None:
+                raise ValueError("Target must be specified when chan is not assigned")
+            target = self.chan
+        if not hasattr(self.conn, "ctcp"):
+            raise ValueError("CTCP can only be used on IRC connections")
+        # noinspection PyUnresolvedReferences
+        self.conn.ctcp(target, ctcp_type, message)
+
+    def notice(self, message, target=None):
+        """sends a notice to the current channel/user or a specific channel/user
+        :type message: str
+        :type target: str
+        """
+        if target is None:
+            if self.nick is None:
+                raise ValueError("Target must be specified when nick is not assigned")
+            target = self.nick
+
+        self.conn.notice(target, message)
+
+    def has_permission(self, permission, notice=True):
+        """ returns whether or not the current user has a given permission
+        :type permission: str
+        :rtype: bool
+        """
+        if not self.mask:
+            raise ValueError("has_permission requires mask is not assigned")
+        return self.conn.permissions.has_perm_mask(self.mask, permission, notice=notice)
+
+    @asyncio.coroutine
+    def async(self, function, *args, **kwargs):
+        if self.db_executor is not None:
+            executor = self.db_executor
+        else:
+            executor = None
+        if kwargs:
+            result = yield from self.loop.run_in_executor(executor, function, *args)
+        else:
+            result = yield from self.loop.run_in_executor(executor, lambda: function(*args, **kwargs))
+        return result
+
+
+class CommandEvent(BaseEvent):
+    """
+    :type hook: cloudbot.pluginmanager.CommandHook
+    :type text: str
+    :type triggered_command: str
+    """
+
+    def __init__(self, *, bot=None, hook, text, triggered_command, conn=None, base_event=None, event_type=None,
+                 content=None, target=None, channel=None, nick=None, user=None, host=None, mask=None, irc_raw=None,
+                 irc_prefix=None, irc_command=None, irc_paramlist=None):
+        """
+        :param text: The arguments for the command
+        :param triggered_command: The command that was triggered
+        :type text: str
+        :type triggered_command: str
+        """
+        super().__init__(bot=bot, hook=hook, conn=conn, base_event=base_event, event_type=event_type, content=content,
+                         target=target, channel=channel, nick=nick, user=user, host=host, mask=mask, irc_raw=irc_raw,
+                         irc_prefix=irc_prefix, irc_command=irc_command, irc_paramlist=irc_paramlist)
+        self.hook = hook
+        self.text = text
+        self.triggered_command = triggered_command
+
+    def notice_doc(self, target=None):
+        """sends a notice containing this command's docstring to the current channel/user or a specific channel/user
+        :type target: str
+        """
+        if self.triggered_command is None:
+            raise ValueError("Triggered command not set on this event")
+        if self.hook.doc is None:
+            message = "{}{} requires additional arguments.".format(self.conn.config["command_prefix"],
+                                                                   self.triggered_command)
+        else:
+            if self.hook.doc.split()[0].isalpha():
+                # this is using the old format of `name <args> - doc`
+                message = "{}{}".format(self.conn.config["command_prefix"], self.hook.doc)
+            else:
+                # this is using the new format of `<args> - doc`
+                message = "{}{} {}".format(self.conn.config["command_prefix"], self.triggered_command, self.hook.doc)
+
+        self.notice(message, target=target)
+
+
+class RegexEvent(BaseEvent):
+    """
+    :type hook: cloudbot.pluginmanager.RegexHook
+    :type match: re.__Match
+    """
+
+    def __init__(self, *, bot=None, hook, match, conn=None, base_event=None, event_type=None, content=None, target=None,
+                 channel=None, nick=None, user=None, host=None, mask=None, irc_raw=None, irc_prefix=None,
+                 irc_command=None, irc_paramlist=None):
+        """
+        :param: match: The match objected returned by the regex search method
+        :type match: re.__Match
+        """
+        super().__init__(bot=bot, conn=conn, hook=hook, base_event=base_event, event_type=event_type, content=content,
+                         target=target, channel=channel, nick=nick, user=user, host=host, mask=mask, irc_raw=irc_raw,
+                         irc_prefix=irc_prefix, irc_command=irc_command, irc_paramlist=irc_paramlist)
+        self.match = match
diff --git a/cloudbot/events.py b/cloudbot/events.py
deleted file mode 100644
index 8681317..0000000
--- a/cloudbot/events.py
+++ /dev/null
@@ -1,373 +0,0 @@
-import asyncio
-import enum
-import logging
-import concurrent.futures
-
-logger = logging.getLogger("cloudbot")
-
-
-@enum.unique
-class EventType(enum.Enum):
-    message = 0
-    action = 1
-    # TODO: Do we actually want to have a 'notice' event type? Should the NOTICE command be a 'message' type?
-    notice = 2
-    join = 3
-    part = 4
-    kick = 5
-    other = 6
-
-
-class BaseEvent:
-    """
-    :type bot: cloudbot.bot.CloudBot
-    :type conn: cloudbot.client.Client
-    :type hook: cloudbot.pluginmanager.Hook
-    :type type: EventType
-    :type content: str
-    :type target: str
-    :type chan: str
-    :type nick: str
-    :type user: str
-    :type host: str
-    :type mask: str
-    :type db: sqlalchemy.orm.Session
-    :type db_executor: concurrent.futures.ThreadPoolExecutor
-    :type irc_raw: str
-    :type irc_prefix: str
-    :type irc_command: str
-    :type irc_paramlist: str
-    :type irc_ctcp_text: str
-    """
-
-    def __init__(self, *, bot=None, hook=None, conn=None, base_event=None, event_type=EventType.other, content=None,
-                 target=None, channel=None, nick=None, user=None, host=None, mask=None, irc_raw=None, irc_prefix=None,
-                 irc_command=None, irc_paramlist=None, irc_ctcp_text=None):
-        """
-        All of these parameters except for `bot` and `hook` are optional.
-        The irc_* parameters should only be specified for IRC events.
-
-        Note that the `bot` argument may be left out if you specify a `base_event`.
-
-        :param bot: The CloudBot instance this event was triggered from
-        :param conn: The Client instance this event was triggered from
-        :param hook: The hook this event will be passed to
-        :param base_event: The base event that this event is based on. If this parameter is not None, then nick, user,
-                            host, mask, and irc_* arguments are ignored
-        :param event_type: The type of the event
-        :param content: The content of the message, or the reason for an join or part
-        :param target: The target of the action, for example the user being kicked, or invited
-        :param channel: The channel that this action took place in
-        :param nick: The nickname of the sender that triggered this event
-        :param user: The user of the sender that triggered this event
-        :param host: The host of the sender that triggered this event
-        :param mask: The mask of the sender that triggered this event (nick!user@host)
-        :param irc_raw: The raw IRC line
-        :param irc_prefix: The raw IRC prefix
-        :param irc_command: The IRC command
-        :param irc_paramlist: The list of params for the IRC command. If the last param is a content param, the ':'
-                                should be removed from the front.
-        :param irc_ctcp_text: CTCP text if this message is a CTCP command
-        :type bot: cloudbot.bot.CloudBot
-        :type conn: cloudbot.client.Client
-        :type hook: cloudbot.pluginmanager.Hook
-        :type base_event: cloudbot.events.BaseEvent
-        :type content: str
-        :type target: str
-        :type event_type: EventType
-        :type nick: str
-        :type user: str
-        :type host: str
-        :type mask: str
-        :type irc_raw: str
-        :type irc_prefix: str
-        :type irc_command: str
-        :type irc_paramlist: list[str]
-        :type irc_ctcp_text: str
-        """
-        self.db = None
-        self.db_executor = None
-        self.bot = bot
-        self.conn = conn
-        self.hook = hook
-        if base_event is not None:
-            # We're copying an event, so inherit values
-            if self.bot is None and base_event.bot is not None:
-                self.bot = base_event.bot
-            if self.conn is None and base_event.conn is not None:
-                self.conn = base_event.conn
-            if self.hook is None and base_event.hook is not None:
-                self.hook = base_event.hook
-
-            # If base_event is provided, don't check these parameters, just inherit
-            self.type = base_event.type
-            self.content = base_event.content
-            self.target = base_event.target
-            self.chan = base_event.chan
-            self.nick = base_event.nick
-            self.user = base_event.user
-            self.host = base_event.host
-            self.mask = base_event.mask
-            # irc-specific parameters
-            self.irc_raw = base_event.irc_raw
-            self.irc_prefix = base_event.irc_prefix
-            self.irc_command = base_event.irc_command
-            self.irc_paramlist = base_event.irc_paramlist
-            self.irc_ctcp_text = base_event.irc_ctcp_text
-        else:
-            # Since base_event wasn't provided, we can take these parameters
-            self.type = event_type
-            self.content = content
-            self.target = target
-            self.chan = channel
-            self.nick = nick
-            self.user = user
-            self.host = host
-            self.mask = mask
-            # irc-specific parameters
-            self.irc_raw = irc_raw
-            self.irc_prefix = irc_prefix
-            self.irc_command = irc_command
-            self.irc_paramlist = irc_paramlist
-            self.irc_ctcp_text = irc_ctcp_text
-
-    @asyncio.coroutine
-    def prepare(self):
-        """
-        Initializes this event to be run through it's hook
-
-        Mainly, initializes a database object on this event, if the hook requires it.
-
-        This method is for when the hook is *not* threaded (event.hook.threaded is False).
-        If you need to add a db to a threaded hook, use prepare_threaded.
-        """
-
-        if self.hook is None:
-            raise ValueError("event.hook is required to prepare an event")
-
-        if "db" in self.hook.required_args:
-            logger.debug("Opening database session for {}:threaded=False".format(self.hook.description))
-
-            # we're running a coroutine hook with a db, so initialise an executor pool
-            self.db_executor = concurrent.futures.ThreadPoolExecutor(1)
-            # be sure to initialize the db in the database executor, so it will be accessible in that thread.
-            self.db = yield from self.async(self.bot.db_session)
-
-    def prepare_threaded(self):
-        """
-        Initializes this event to be run through it's hook
-
-        Mainly, initializes the database object on this event, if the hook requires it.
-
-        This method is for when the hook is threaded (event.hook.threaded is True).
-        If you need to add a db to a coroutine hook, use prepare.
-        """
-
-        if self.hook is None:
-            raise ValueError("event.hook is required to prepare an event")
-
-        if "db" in self.hook.required_args:
-            logger.debug("Opening database session for {}:threaded=True".format(self.hook.description))
-
-            self.db = self.bot.db_session()
-
-    @asyncio.coroutine
-    def close(self):
-        """
-        Closes this event after running it through it's hook.
-
-        Mainly, closes the database connection attached to this event (if any).
-
-        This method is for when the hook is *not* threaded (event.hook.threaded is False).
-        If you need to add a db to a threaded hook, use close_threaded.
-        """
-        if self.hook is None:
-            raise ValueError("event.hook is required to close an event")
-
-        if self.db is not None:
-            logger.debug("Closing database session for {}:threaded=False".format(self.hook.description))
-            # be sure the close the database in the database executor, as it is only accessable in that one thread
-            yield from self.async(self.db.close)
-            self.db = None
-
-    def close_threaded(self):
-        """
-        Closes this event after running it through it's hook.
-
-        Mainly, closes the database connection attached to this event (if any).
-
-        This method is for when the hook is threaded (event.hook.threaded is True).
-        If you need to add a db to a coroutine hook, use close.
-        """
-        if self.hook is None:
-            raise ValueError("event.hook is required to close an event")
-        if self.db is not None:
-            logger.debug("Closing database session for {}:threaded=True".format(self.hook.description))
-            self.db.close()
-            self.db = None
-
-    @property
-    def event(self):
-        """
-        :rtype; cloudbot.events.BaseEvent
-        """
-        return self
-
-    @property
-    def loop(self):
-        """
-        :rtype: asyncio.events.AbstractEventLoop
-        """
-        return self.bot.loop
-
-    @property
-    def logger(self):
-        return logger
-
-    def message(self, message, target=None):
-        """sends a message to a specific or current channel/user
-        :type message: str
-        :type target: str
-        """
-        if target is None:
-            if self.chan is None:
-                raise ValueError("Target must be specified when chan is not assigned")
-            target = self.chan
-        self.conn.message(target, message)
-
-    def reply(self, message, target=None):
-        """sends a message to the current channel/user with a prefix
-        :type message: str
-        :type target: str
-        """
-        if target is None:
-            if self.chan is None:
-                raise ValueError("Target must be specified when chan is not assigned")
-            target = self.chan
-
-        if target == self.nick:
-            self.conn.message(target, message)
-        else:
-            self.conn.message(target, "({}) {}".format(self.nick, message))
-
-    def action(self, message, target=None):
-        """sends an action to the current channel/user or a specific channel/user
-        :type message: str
-        :type target: str
-        """
-        if target is None:
-            if self.chan is None:
-                raise ValueError("Target must be specified when chan is not assigned")
-            target = self.chan
-
-        self.conn.action(target, message)
-
-    def ctcp(self, message, ctcp_type, target=None):
-        """sends an ctcp to the current channel/user or a specific channel/user
-        :type message: str
-        :type ctcp_type: str
-        :type target: str
-        """
-        if target is None:
-            if self.chan is None:
-                raise ValueError("Target must be specified when chan is not assigned")
-            target = self.chan
-        if not hasattr(self.conn, "ctcp"):
-            raise ValueError("CTCP can only be used on IRC connections")
-        # noinspection PyUnresolvedReferences
-        self.conn.ctcp(target, ctcp_type, message)
-
-    def notice(self, message, target=None):
-        """sends a notice to the current channel/user or a specific channel/user
-        :type message: str
-        :type target: str
-        """
-        if target is None:
-            if self.nick is None:
-                raise ValueError("Target must be specified when nick is not assigned")
-            target = self.nick
-
-        self.conn.notice(target, message)
-
-    def has_permission(self, permission, notice=True):
-        """ returns whether or not the current user has a given permission
-        :type permission: str
-        :rtype: bool
-        """
-        if not self.mask:
-            raise ValueError("has_permission requires mask is not assigned")
-        return self.conn.permissions.has_perm_mask(self.mask, permission, notice=notice)
-
-    @asyncio.coroutine
-    def async(self, function, *args, **kwargs):
-        if self.db_executor is not None:
-            executor = self.db_executor
-        else:
-            executor = None
-        if kwargs:
-            result = yield from self.loop.run_in_executor(executor, function, *args)
-        else:
-            result = yield from self.loop.run_in_executor(executor, lambda: function(*args, **kwargs))
-        return result
-
-
-class CommandEvent(BaseEvent):
-    """
-    :type hook: cloudbot.pluginmanager.CommandHook
-    :type text: str
-    :type triggered_command: str
-    """
-
-    def __init__(self, *, bot=None, hook, text, triggered_command, conn=None, base_event=None, event_type=None,
-                 content=None, target=None, channel=None, nick=None, user=None, host=None, mask=None, irc_raw=None,
-                 irc_prefix=None, irc_command=None, irc_paramlist=None):
-        """
-        :param text: The arguments for the command
-        :param triggered_command: The command that was triggered
-        :type text: str
-        :type triggered_command: str
-        """
-        super().__init__(bot=bot, hook=hook, conn=conn, base_event=base_event, event_type=event_type, content=content,
-                         target=target, channel=channel, nick=nick, user=user, host=host, mask=mask, irc_raw=irc_raw,
-                         irc_prefix=irc_prefix, irc_command=irc_command, irc_paramlist=irc_paramlist)
-        self.hook = hook
-        self.text = text
-        self.triggered_command = triggered_command
-
-    def notice_doc(self, target=None):
-        """sends a notice containing this command's docstring to the current channel/user or a specific channel/user
-        :type target: str
-        """
-        if self.triggered_command is None:
-            raise ValueError("Triggered command not set on this event")
-        if self.hook.doc is None:
-            message = "{}{} requires additional arguments.".format(self.conn.config["command_prefix"],
-                                                                   self.triggered_command)
-        else:
-            if self.hook.doc.split()[0].isalpha():
-                # this is using the old format of `name <args> - doc`
-                message = "{}{}".format(self.conn.config["command_prefix"], self.hook.doc)
-            else:
-                # this is using the new format of `<args> - doc`
-                message = "{}{} {}".format(self.conn.config["command_prefix"], self.triggered_command, self.hook.doc)
-
-        self.notice(message, target=target)
-
-
-class RegexEvent(BaseEvent):
-    """
-    :type hook: cloudbot.pluginmanager.RegexHook
-    :type match: re.__Match
-    """
-
-    def __init__(self, *, bot=None, hook, match, conn=None, base_event=None, event_type=None, content=None, target=None,
-                 channel=None, nick=None, user=None, host=None, mask=None, irc_raw=None, irc_prefix=None,
-                 irc_command=None, irc_paramlist=None):
-        """
-        :param: match: The match objected returned by the regex search method
-        :type match: re.__Match
-        """
-        super().__init__(bot=bot, conn=conn, hook=hook, base_event=base_event, event_type=event_type, content=content,
-                         target=target, channel=channel, nick=nick, user=user, host=host, mask=mask, irc_raw=irc_raw,
-                         irc_prefix=irc_prefix, irc_command=irc_command, irc_paramlist=irc_paramlist)
-        self.match = match
diff --git a/cloudbot/hook.py b/cloudbot/hook.py
index c03aeb2..1c67d13 100644
--- a/cloudbot/hook.py
+++ b/cloudbot/hook.py
@@ -2,7 +2,7 @@ import inspect
 import re
 import collections
 
-from cloudbot.events import EventType
+from cloudbot.event import EventType
 
 valid_command_re = re.compile(r"^\w+$")
 
@@ -134,7 +134,7 @@ class _RawHook(_Hook):
 
 class _EventHook(_Hook):
     """
-    :type types: set[cloudbot.events.EventType]
+    :type types: set[cloudbot.event.EventType]
     """
 
     def __init__(self, function):
@@ -146,7 +146,7 @@ class _EventHook(_Hook):
 
     def add_hook(self, trigger_param, kwargs):
         """
-        :type trigger_param: cloudbot.events.EventType | list[cloudbot.events.EventType]
+        :type trigger_param: cloudbot.event.EventType | list[cloudbot.event.EventType]
         :type kwargs: dict[str, unknown]
         """
         self._add_hook(kwargs)
@@ -215,7 +215,7 @@ def irc_raw(triggers_param, **kwargs):
 
 def event(types_param, **kwargs):
     """External event decorator. Must be used as a function to return a decorator
-    :type types_param: cloudbot.events.EventType | list[cloudbot.events.EventType]
+    :type types_param: cloudbot.event.EventType | list[cloudbot.event.EventType]
     """
 
     def _event_hook(func):
diff --git a/cloudbot/pluginmanager.py b/cloudbot/pluginmanager.py
index 5fec67b..b69e079 100644
--- a/cloudbot/pluginmanager.py
+++ b/cloudbot/pluginmanager.py
@@ -8,7 +8,7 @@ import re
 
 import sqlalchemy
 
-from cloudbot import events
+from cloudbot import event
 from cloudbot.util import botvars
 
 logger = logging.getLogger("cloudbot")
@@ -76,7 +76,7 @@ class PluginManager:
     :type commands: dict[str, CommandHook]
     :type raw_triggers: dict[str, list[RawHook]]
     :type catch_all_triggers: list[RawHook]
-    :type event_type_hooks: dict[cloudbot.events.EventType, list[EventHook]]
+    :type event_type_hooks: dict[cloudbot.event.EventType, list[EventHook]]
     :type regex_hooks: list[(re.__Regex, RegexHook)]
     :type sieves: list[SieveHook]
     """
@@ -159,7 +159,7 @@ class PluginManager:
 
         # run onload hooks
         for onload_hook in plugin.run_on_load:
-            success = yield from self.launch(onload_hook, events.BaseEvent(bot=self.bot, hook=onload_hook))
+            success = yield from self.launch(onload_hook, event.BaseEvent(bot=self.bot, hook=onload_hook))
             if not success:
                 logger.warning("Not registering hooks from plugin {}: onload hook errored".format(plugin.title))
 
@@ -299,7 +299,7 @@ class PluginManager:
         Prepares arguments for the given hook
 
         :type hook: cloudbot.pluginmanager.Hook
-        :type event: cloudbot.events.BaseEvent
+        :type event: cloudbot.event.BaseEvent
         :rtype: list
         """
         parameters = []
@@ -317,7 +317,7 @@ class PluginManager:
     def _execute_hook_threaded(self, hook, event):
         """
         :type hook: Hook
-        :type event: cloudbot.events.BaseEvent
+        :type event: cloudbot.event.BaseEvent
         """
         event.prepare_threaded()
 
@@ -334,7 +334,7 @@ class PluginManager:
     def _execute_hook_sync(self, hook, event):
         """
         :type hook: Hook
-        :type event: cloudbot.events.BaseEvent
+        :type event: cloudbot.event.BaseEvent
         """
         yield from event.prepare()
 
@@ -355,7 +355,7 @@ class PluginManager:
         Returns False if the hook errored, True otherwise.
 
         :type hook: cloudbot.pluginmanager.Hook
-        :type event: cloudbot.events.BaseEvent
+        :type event: cloudbot.event.BaseEvent
         :rtype: bool
         """
         try:
@@ -383,9 +383,9 @@ class PluginManager:
     def _sieve(self, sieve, event, hook):
         """
         :type sieve: cloudbot.pluginmanager.Hook
-        :type event: cloudbot.events.BaseEvent
+        :type event: cloudbot.event.BaseEvent
         :type hook: cloudbot.pluginmanager.Hook
-        :rtype: cloudbot.events.BaseEvent
+        :rtype: cloudbot.event.BaseEvent
         """
         try:
             if sieve.threaded:
@@ -405,7 +405,7 @@ class PluginManager:
 
         Returns False if the hook didn't run successfully, and True if it ran successfully.
 
-        :type event: cloudbot.events.BaseEvent | cloudbot.events.CommandEvent
+        :type event: cloudbot.event.BaseEvent | cloudbot.event.CommandEvent
         :type hook: cloudbot.pluginmanager.Hook | cloudbot.pluginmanager.CommandHook
         :rtype: bool
         """
@@ -665,7 +665,7 @@ class SieveHook(Hook):
 
 class EventHook(Hook):
     """
-    :type types: set[cloudbot.events.EventType]
+    :type types: set[cloudbot.event.EventType]
     """
 
     def __init__(self, plugin, event_hook):
diff --git a/plugins/core_sieve.py b/plugins/core_sieve.py
index c2e1f6c..b5eb46b 100644
--- a/plugins/core_sieve.py
+++ b/plugins/core_sieve.py
@@ -14,7 +14,7 @@ buckets = {}
 def sieve_suite(bot, event, _hook):
     """
     :type bot: cloudbot.bot.CloudBot
-    :type event: cloudbot.events.BaseEvent
+    :type event: cloudbot.event.BaseEvent
     :type _hook: cloudbot.pluginmanager.Hook
     """
     conn = event.conn
diff --git a/plugins/history.py b/plugins/history.py
index c479c94..0c27e30 100644
--- a/plugins/history.py
+++ b/plugins/history.py
@@ -5,7 +5,7 @@ import re
 
 from cloudbot import hook
 from cloudbot.util import timesince
-from cloudbot.events import EventType
+from cloudbot.event import EventType
 
 db_ready = []
 
@@ -23,7 +23,7 @@ def db_init(db, conn_name):
 
 def track_seen(event, db, conn):
     """ Tracks messages for the .seen command
-    :type event: cloudbot.events.BaseEvent
+    :type event: cloudbot.event.BaseEvent
     :type db: sqlalchemy.orm.Session
     :type conn: cloudbot.client.Client
     """
@@ -37,7 +37,7 @@ def track_seen(event, db, conn):
 
 def track_history(event, message_time, conn):
     """
-    :type event: cloudbot.events.BaseEvent
+    :type event: cloudbot.event.BaseEvent
     :type conn: cloudbot.client.Client
     """
     try:
@@ -54,7 +54,7 @@ def track_history(event, message_time, conn):
 def chat_tracker(event, db, conn):
     """
     :type db: sqlalchemy.orm.Session
-    :type event: cloudbot.events.BaseEvent
+    :type event: cloudbot.event.BaseEvent
     :type conn: cloudbot.client.Client
     """
     message_time = time.time()
@@ -66,7 +66,7 @@ def chat_tracker(event, db, conn):
 @hook.command(autohelp=False)
 def resethistory(event, conn):
     """- resets chat history for the current channel
-    :type event: cloudbot.events.BaseEvent
+    :type event: cloudbot.event.BaseEvent
     :type conn: cloudbot.client.Client
     """
     try:
@@ -81,7 +81,7 @@ def resethistory(event, conn):
 def seen(text, nick, chan, db, event, conn):
     """<nick> <channel> - tells when a nickname was last in active in one of my channels
     :type db: sqlalchemy.orm.Session
-    :type event: cloudbot.events.BaseEvent
+    :type event: cloudbot.event.BaseEvent
     :type conn: cloudbot.client.Client
     """
 
diff --git a/plugins/ignore.py b/plugins/ignore.py
index dbd422b..818c39d 100644
--- a/plugins/ignore.py
+++ b/plugins/ignore.py
@@ -2,7 +2,7 @@ import asyncio
 from fnmatch import fnmatch
 
 from cloudbot import hook
-from cloudbot.events import EventType
+from cloudbot.event import EventType
 
 
 @hook.onload
@@ -28,7 +28,7 @@ def ensure_ignored(bot):
 def ignore_sieve(bot, event, _hook):
     """ blocks events from ignored channels/hosts
     :type bot: cloudbot.bot.CloudBot
-    :type event: cloudbot.events.BaseEvent
+    :type event: cloudbot.event.BaseEvent
     :type _hook: cloudbot.pluginmanager.Hook
     """
     # don't block event hooks
diff --git a/plugins/log.py b/plugins/log.py
index 6f61337..d7e8c37 100644
--- a/plugins/log.py
+++ b/plugins/log.py
@@ -5,7 +5,7 @@ import time
 
 import cloudbot
 from cloudbot import hook
-from cloudbot.events import EventType
+from cloudbot.event import EventType
 
 
 
@@ -48,7 +48,7 @@ ctcp_unknown_with_message = ("[{server}:{channel}] {nick} [{user}@{host}] "
 def format_event(event):
     """
     Format an event
-    :type event: cloudbot.events.BaseEvent
+    :type event: cloudbot.event.BaseEvent
     :rtype: str
     """
 
@@ -202,7 +202,7 @@ def get_raw_log_stream(server):
 @hook.irc_raw("*", singlethread=True)
 def log_raw(event):
     """
-    :type event: cloudbot.events.BaseEvent
+    :type event: cloudbot.event.BaseEvent
     """
     logging_config = event.bot.config.get("logging", {})
     if not logging_config.get("raw_file_log", False):
@@ -214,7 +214,7 @@ def log_raw(event):
 @hook.irc_raw("*", singlethread=True)
 def log(event):
     """
-    :type event: cloudbot.events.BaseEvent
+    :type event: cloudbot.event.BaseEvent
     """
     text = format_event(event)
 
@@ -229,7 +229,7 @@ def log(event):
 def console_log(bot, event):
     """
     :type bot: cloudbot.bot.CloudBot
-    :type event: cloudbot.events.BaseEvent
+    :type event: cloudbot.event.BaseEvent
     """
     text = format_event(event)
     if text is not None:
diff --git a/plugins/tell.py b/plugins/tell.py
index 5955108..1b00656 100644
--- a/plugins/tell.py
+++ b/plugins/tell.py
@@ -6,7 +6,7 @@ from sqlalchemy.sql import select
 
 from cloudbot import hook
 from cloudbot.util import timesince, botvars
-from cloudbot.events import EventType
+from cloudbot.event import EventType
 
 table = Table(
     'tells',
@@ -75,7 +75,7 @@ def add_tell(db, server, sender, target, message):
 @hook.event(EventType.message, singlethread=True)
 def tellinput(event, conn, db, nick, notice):
     """
-    :type event: cloudbot.events.BaseEvent
+    :type event: cloudbot.event.BaseEvent
     :type conn: cloudbot.client.Client
     :type db: sqlalchemy.orm.Session
     """
-- 
2.0.0

