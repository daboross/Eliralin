From 25cc3d22542754c8b478d3b9a44f4f11926da0f7 Mon Sep 17 00:00:00 2001
From: Dabo Ross <daboross@daboross.net>
Date: Sat, 5 Apr 2014 23:10:52 -0700
Subject: [PATCH] Plugins to be added


diff --git a/plugins/eliralin_teamcity.py b/plugins/eliralin_teamcity.py
new file mode 100644
index 0000000..07c8e8f
--- /dev/null
+++ b/plugins/eliralin_teamcity.py
@@ -0,0 +1,162 @@
+from xml.etree.ElementTree import ParseError
+import traceback
+from xml.etree import ElementTree
+import time
+
+import requests
+from requests.auth import HTTPBasicAuth
+
+from util import hook
+
+
+teamcity_url = "http://ci.daboross.net/ci"
+
+
+class ProjectDatabase:
+    def __init__(self):
+        self.reload_timestamp = 0
+        self.projects = []
+        self.username = "default"
+        self.password = "default"
+        self.teamcity_url = teamcity_url
+        self.loaded_key = False
+
+    def download(self, url):
+        if url.startswith("/httpAuth"):
+            data = requests.get(self.teamcity_url + url, auth=HTTPBasicAuth(self.username, self.password)).text
+        elif url.startswith("/guestAuth"):
+            data = requests.get(self.teamcity_url + url).text
+        elif self.loaded_key:
+            data = requests.get("{}/httpAuth{}".format(self.teamcity_url, url),
+                                auth=HTTPBasicAuth(self.username, self.password)).text
+        else:
+            data = requests.get("{}/guestAuth{}".format(self.teamcity_url, url)).text
+        try:
+            return ElementTree.fromstring(data)
+        except ParseError:
+            print("Error loading {} ({})".format(url, data))
+            raise
+
+    def load_key(self, bot):
+        if not self.loaded_key:
+            api_keys = bot.config.get("api_keys", None)
+            if api_keys:
+                self.username = api_keys.get("teamcity_username")
+                self.password = api_keys.get("teamcity_password")
+                self.loaded_key = True
+            else:
+                print("Warning, couldn't find teamcity api key")
+
+    def reload_database(self):
+        self.reload_timestamp = time.time()
+        self.projects = []
+        root = self.download("/app/rest/projects")
+        for project in root:
+            if project.get("id") != "_Root":
+                self.projects.append(Project(project))
+
+    def ensure_loaded(self, bot=None):
+        if bot and not self.loaded_key:
+            self.load_key(bot)
+        if self.reload_timestamp == 0:
+            self.reload_database()
+
+    def after_check(self):
+        if time.time() > self.reload_timestamp + 300:
+            self.reload_database()
+
+
+class Project:
+    def __init__(self, project):
+        self.name = project.get("name")
+        self.project_id = project.get("id")
+        self.project_url = project.get("href")
+        self.downloads = []
+        project_element = database.download(self.project_url)
+        build_types = project_element.find("buildTypes")
+        if build_types and len(build_types) > 0:
+            for build_type in build_types.findall("buildType"):
+                download = find_download_url(build_type)
+                if download:
+                    self.downloads.append(download)
+
+        self.search_name = self.name.lower()
+        self.search_id = self.project_id.lower()
+
+    def search(self, search):
+        if search == self.search_name or search == self.search_id:
+            return 2
+        elif search in self.search_name or search in self.search_id:
+            return 1
+        return 0
+
+
+def find_download_url(build_type_element):
+    try:
+        build_type_id = build_type_element.get("id")
+        href = build_type_element.get("href")
+        builds_url = database.download(href).find("builds").get("href")
+        build_url = database.download(builds_url).find("build").get("href")
+        artifacts_url = database.download(build_url).find("artifacts").get("href")
+        files = database.download(artifacts_url).findall("file")
+        filenames = [download_file.get("name") for download_file in files]
+        return {"id": build_type_id, "files": filenames}
+    except AttributeError:
+        traceback.print_exc()
+        return None
+    except ParseError:
+        traceback.print_exc()
+        return None
+
+
+database = ProjectDatabase()
+
+
+@hook.command()
+@hook.command("ci")
+def teamcity(inp, bot=None, reply=None, message=None):
+    """teamcity [project] - Searches for project on teamcity, and displays project URL and download"""
+    database.ensure_loaded(bot=bot)
+    search = inp.lower()
+    level_found = 0
+    project_found = None
+    other_matches = []
+    for project in database.projects:
+        level = project.search(search)
+        if level > level_found:
+            if project_found:
+                other_matches.append(project_found.name)
+            project_found = project
+            level_found = level
+        elif level > 0:
+            other_matches.append(project.name)
+
+    if project_found is not None:
+        reply("{} - Project: http://ci.daboross.net/p/{}".format(project_found.name, project_found.project_id))
+        for download in project_found.downloads:
+            for download_file in download["files"]:
+                message("Download: http://ci.daboross.net/d/{}/{}".format(download["id"], download_file))
+        if len(other_matches) > 0:
+            message("(Other matches: {})".format(", ".join(other_matches)))
+    else:
+        reply("No projects found matching '{}'".format(inp))
+    database.after_check()
+
+
+@hook.command(permissions=["botcontrol"], autohelp=False)
+@hook.command("reloadci", permissions=["botcontrol"], autohelp=False)
+def reload_teamcity(inp, bot=None, reply=None):
+    """reloadci - Reloads teamcity database manually"""
+    database.load_key(bot)
+    database.reload_database()
+    reply("Reloaded teamcity, found {} projects.".format(len(database.projects)))
+    database.after_check()
+
+
+@hook.command(permissions=["botcontrol"], autohelp=False)
+@hook.command("listci", permissions=["botcontrol"], autohelp=False)
+def list_teamcity(inp, bot=None, reply=None):
+    """listci - Lists all projects loaded into database from teamcity"""
+    database.ensure_loaded(bot=bot)
+    reply("Projects: {}".format(", ".join([project.name for project in database.projects])))
+    database.after_check()
diff --git a/plugins/eliralin_utility.py b/plugins/eliralin_utility.py
new file mode 100644
index 0000000..0934b98
--- /dev/null
+++ b/plugins/eliralin_utility.py
@@ -0,0 +1,157 @@
+from random import random
+import socket
+import sys
+import traceback
+import time
+
+from util import hook, web
+
+
+@hook.command
+def josephus(inp):
+    """jose [size] [every x] [starting person] - Calculates who dies last """
+    split = inp.split()
+    if len(split) != 3:
+        return "Not enough / too many arguments. {}".format(len(split))
+    size, every_x, current = [int(x) for x in split]
+    alive, till_kill = [True] * size, 0
+    while True:
+        if alive[current]:
+            if sum(alive) == 1:
+                break
+            elif till_kill == 0:
+                alive[current] = False
+                till_kill = every_x - 1
+            else:
+                till_kill -= 1
+        current += 1 if current < size - 1 else 1 - size
+    return "Josephus should be at position {} to survive.".format(current)
+
+
+@hook.regex("(?i)(^ )*pets Eliralin *$")
+def pet(match, action=None, nick=None, chan=None):
+    r = random()
+    if r > 0.7:
+        action("huggles {}".format(nick))
+
+
+@hook.command
+@hook.command("hug")
+def huggle(inp, action=None, nick=None):
+    if inp:
+        action("huggles {}".format(inp))
+    else:
+        action("huggles {}".format(nick))
+
+
+@hook.command
+def colors(inp):
+    if inp:
+        intinp = int(inp)
+        if intinp > 70:
+            return "Please use a number smaller than or equal to 70"
+        forrange = range(intinp)
+    else:
+        forrange = range(30)
+    result = ""
+    for i in forrange if inp else range(30):
+        result += u"\x03{0:02d} {0}".format(i)
+    return result
+
+
+@hook.regex(r'^Eliralin[,;:.](| .*)$')
+def reply(match, message=None, nick=None):
+    time.sleep(0.2)
+    message(match.group(0).replace("Eliralin", nick))
+
+
+@hook.regex("(?i)(Hello|Hi) Eliralin(!| |\\.|\\?)*")
+def hello_regex(match, nick=None, message=None):
+    if match.group(2) == "?":
+        message("Hi {}, What's your question?".format(nick))
+    else:
+        message("Hello {}!".format(nick))
+
+
+@hook.command(permissions=['adminonly'])
+def tree(inp, message=None, notice=None):
+    """tree [type] [text] - Tree text"""
+    type_input = inp.split(None, 1)
+    if len(type_input) < 2:
+        notice("tree [type] [text] - Tree text")
+        return
+    tree_type = type_input[0]
+    if tree_type == "1":
+        func = lambda c: c[1:-1]
+    elif tree_type == "2":
+        func = lambda c: c[2:]
+    elif tree_type == "3":
+        func = lambda c: c[:-2]
+    else:
+        return "Invalid tree type '{}'.".format(tree_type)
+    current = type_input[1]
+    spaces = 7
+    while len(current) > 0:
+        spaces += 1
+        message(spaces * ' ' + current)
+        current = func(current)
+
+    message((spaces - 1) * ' ' + ('----' if len(type_input[1]) % 2 == 0 else '---'))
+
+
+@hook.command
+def threaddump(inp):
+    print("Running thread dump")
+    code = []
+    for threadId, stack in sys._current_frames().items():
+        code.append("\n# ThreadID: %s" % threadId)
+        for filename, lineno, name, line in traceback.extract_stack(stack):
+            code.append('File: "%s", line %d, in %s' % (filename, lineno, name))
+            if line:
+                code.append("  %s" % (line.strip()))
+    return "Thread dump located at {}".format(web.haste("\n".join(code), ext='txt'))
+
+
+@hook.command
+def dns(inp):
+    """dns [domain] - Resolves the IP of a domain"""
+    try:
+        socket.setdefaulttimeout(5)
+        ip = None
+        for info in socket.getaddrinfo(inp, 80, 0, 0, socket.SOL_TCP):
+            print(info)
+            if ip is None:
+                ip = info[-1][0]
+            else:
+                ip = "{}, {}".format(ip, info[-1][0])
+        return "{} resolves to {}".format(inp, ip)
+    except socket.gaierror:
+        return "Resolve Failed!"
+
+
+@hook.command
+def rdns(inp):
+    """rdns [ip] - Resolves the hostname of an IP"""
+    try:
+        socket.setdefaulttimeout(5)
+        domain = socket.gethostbyaddr(inp)[0]
+        return "{} resolves to {}".format(inp, domain)
+    except socket.gaierror:
+        return "Resolve Failed!"
+
+
+@hook.command("unicode")
+def unicodecommand(inp, reply=None):
+    try:
+        return u"'{}'".format(chr(int(inp)))
+    except Exception:
+        reply("Failed")
+        raise
+
+
+@hook.command(permissions=["botcontrol"])
+def addprefix(inp, chan=None, db=None):
+    """addprefix [prefix] - Adds a one-letter prefix to the bot in this channel"""
+    db.execute("CREATE TABLE IF NOT EXISTS prefixes(channel, prefix, UNIQUE(channel, prefix) ON CONFLICT REPLACE)")
+    db.execute("INSERT INTO prefixes(channel, prefix) VALUES(?, ?)", [chan, inp])
+    db.commit()
diff --git a/plugins/meme.py b/plugins/meme.py
new file mode 100644
index 0000000..71ca4c1
--- /dev/null
+++ b/plugins/meme.py
@@ -0,0 +1,120 @@
+from util import hook, http, web
+import shlex
+import requests
+import json
+
+GENURL = 'http://version1.api.memegenerator.co'
+
+POPULAR_URL = '{0}/Generators_Select_ByPopular'.format(GENURL)
+POPULAR_DAT = {
+    'pageIndex': '0',
+    'pageSize': '24',
+    'days': '',
+}
+
+SEARCH_URL = '{0}/Generators_Search'.format(GENURL)
+SEARCH_DAT = {
+    'q': None,
+    'pageIndex': '0',
+    'pageSize': '24',
+}
+
+INFO_URL = "{0}/Generator_Select_ByUrlNameOrGeneratorID".format(GENURL)
+INFO_DAT = {'urlName': None}
+
+ACTION_URL = "{0}/Instance_Create".format(GENURL)
+ACTION_DAT = {
+    'username': None,
+    'password': None,
+    'languageCode': 'en',
+    'generatorID': None,
+    'imageID': None,
+    'text0': None,
+    'text1': None,
+}
+
+
+def get_image_id_from_url(url):
+    return url.split("/")[-1].split(".")[0]
+
+
+@hook.command(autohelp=False)
+def listmemes(pattern):
+    memeinfo = []
+    if pattern:
+        url = SEARCH_URL
+        SEARCH_DAT.update({'q': pattern})
+        params = SEARCH_DAT
+    else:
+        url = POPULAR_URL
+        params = POPULAR_DAT
+
+    result = requests.get(url, params=params).json
+    if not result.get('success', False):
+        if result.get('errorMessage', None):
+            return result['errorMessage']
+        else:
+            return FIX_MEME
+
+    out = ""
+    for m in result['result']:
+        if out == "":
+            out = m['urlName'] + ": " + m['imageUrl']
+        else:
+            out = out + "\n" + m['urlName'] + ": " + m['imageUrl']
+    return "List of memes: %s" % web.haste(out)
+
+
+def get_api_result(*args, **kwargs):
+    response = requests.get(*args, **kwargs)
+    result = None
+    message = "API is broken. Please tell blha303 about this."
+    try:
+        jsondata = response.json()
+    except ValueError:
+        pass  # out is already set for this state
+    else:
+        if jsondata.get('success', False):
+            result = jsondata['result']
+            message = None
+        elif jsondata.get('errorMessage', False):
+            message = jsondata['errorMessage']
+    return result, message
+
+
+@hook.command
+def meme(inp, bot=None):
+    """meme <meme> "<topline>" "<bottomline>" - Generate meme. Get meme ID using .listmemes. You can make a section blank with .meme Meme "" "Bottom text only" """
+    keys = bot.config['api_keys']
+    if not 'meme_user' in keys or keys['meme_user'] == "MEMEGENERATOR USERNAME":
+        return "Please set username and password in config"
+    try:
+        user = keys['meme_user']
+        passw = keys['meme_pass']
+    except:
+        keys['meme_user'] = "MEMEGENERATOR USERNAME"
+        keys['meme_pass'] = "MEMEGENERATOR PASSWORD"
+        json.dump(bot.config, open('config', 'w'), sort_keys=True, indent=2)
+        return "Please set username and password in config"
+    inpsplit = shlex.split(inp)
+    INFO_DAT.update({'urlName': inpsplit[0]})
+    result, message = get_api_result(INFO_URL, params=INFO_DAT)
+    if result:
+        ACTION_DAT.update({
+            'username': user,
+            'password': passw,
+            'generatorID': result['generatorID'],
+            'imageID': get_image_id_from_url(result['imageUrl']),
+            'text0': inpsplit[1],
+            'text1': inpsplit[2],
+        })
+    else:
+        return message
+    result, message = get_api_result(ACTION_URL, params=ACTION_DAT)
+    if result:
+        try:
+            return web.isgd(result['instanceImageUrl'])
+        except (web.ShortenError, http.HTTPError) as error:
+            return result['instanceImageUrl']
+    else:
+        return message
diff --git a/plugins/recipe.py b/plugins/recipe.py
new file mode 100644
index 0000000..bec27da
--- /dev/null
+++ b/plugins/recipe.py
@@ -0,0 +1,111 @@
+import random
+
+from util import hook, http, web
+
+METADATA_URL = "http://omnidator.appspot.com/microdata/json/?url={}"
+
+BASE_URL = "http://www.cookstr.com"
+SEARCH_URL = BASE_URL + "/searches"
+RANDOM_URL = SEARCH_URL + "/surprise"
+
+# set this to true to censor this plugin!
+censor = True
+phrases = [
+    "EAT SOME FUCKING \x02{}\x02",
+    "YOU WON'T NOT MAKE SOME FUCKING \x02{}\x02",
+    "HOW ABOUT SOME FUCKING \x02{}?\x02",
+    "WHY DON'T YOU EAT SOME FUCKING \x02{}?\x02",
+    "MAKE SOME FUCKING \x02{}\x02",
+    "INDUCE FOOD COMA WITH SOME FUCKING \x02{}\x02"
+    "CLASSILY PARTAKE IN SOME FUCKING \x02{}\x02",
+    "COOK UP SOME FUCKING \x02{}\x02",
+    "CURE YOUR MOUTH'S POST TRAUMATIC STRESS DISORDER WITH SOME FUCKING \x02{}\x02",
+    "PROCURE SOME CHILD LABOR TO COOK UP SOME FUCKING \x02{}\x02",
+    "YOUR INDECISION IS FAR LESS APPETIZING THAN SOME FUCKING \x02{}\x02"
+]
+
+clean_key = lambda i: i.split("#")[1]
+
+
+class ParseError(Exception):
+    pass
+
+
+def get_data(url):
+    """ Uses the omnidator API to parse the metadata from the provided URL """
+    try:
+        omni = http.get_json(METADATA_URL.format(url))
+    except (http.HTTPError, http.URLError) as e:
+        raise ParseError(e)
+    schemas = omni["@"]
+    for d in schemas:
+        if d["a"] == "<http://schema.org/Recipe>":
+            data = {clean_key(key): value for (key, value) in d.iteritems()
+                    if key.startswith("http://schema.org/Recipe")}
+            return data
+    raise ParseError("No recipe data found")
+
+
+@hook.command(autohelp=False)
+def recipe(inp):
+    """recipe [term] - Gets a recipe for [term], or ets a random recipe if [term] is not provided"""
+    if inp:
+        # get the recipe URL by searching
+        try:
+            search = http.get_soup(SEARCH_URL, query=inp.strip())
+        except (http.HTTPError, http.URLError) as e:
+            return "Could not get recipe: {}".format(e)
+
+        # find the list of results
+        result_list = search.find('div', {'class': 'found_results'})
+
+        if result_list:
+            results = result_list.find_all('div', {'class': 'recipe_result'})
+        else:
+            return "No results"
+
+        # pick a random front page result
+        result = random.choice(results)
+
+        # extract the URL from the result
+        url = BASE_URL + result.find('div', {'class': 'image-wrapper'}).find('a')['href']
+
+    else:
+        # get a random recipe URL
+        try:
+            page = http.open(RANDOM_URL)
+        except (http.HTTPError, http.URLError) as e:
+            return "Could not get recipe: {}".format(e)
+        url = page.geturl()
+
+    # use get_data() to get the recipe info from the URL
+    try:
+        data = get_data(url)
+    except ParseError as e:
+        return "Could not parse recipe: {}".format(e)
+
+    name = data["name"].strip()
+    return "Try eating \x02{}!\x02 - {}".format(name, web.try_isgd(url))
+
+
+@hook.command(autohelp=False)
+def dinner(inp):
+    """dinner - WTF IS FOR DINNER"""
+    try:
+        page = http.open(RANDOM_URL)
+    except (http.HTTPError, http.URLError) as e:
+        return "Could not get recipe: {}".format(e)
+    url = page.geturl()
+
+    try:
+        data = get_data(url)
+    except ParseError as e:
+        return "Could not parse recipe: {}".format(e)
+
+    name = data["name"].strip().upper()
+    text = random.choice(phrases).format(name)
+
+    if censor:
+        text = text.replace("FUCK", "F**K")
+
+    return "{} - {}".format(text, web.try_isgd(url))
\ No newline at end of file
diff --git a/plugins/regex_chans.py b/plugins/regex_chans.py
new file mode 100644
index 0000000..d9c902b
--- /dev/null
+++ b/plugins/regex_chans.py
@@ -0,0 +1,128 @@
+from util import hook
+
+
+# Default value.
+# If True, all channels without a setting will have regex enabled
+# If False, all channels without a setting will have regex disabled
+default_enabled = False
+
+db_ready = False
+
+
+def db_init(db):
+    global db_ready
+    if not db_ready:
+        db.execute("CREATE TABLE IF NOT EXISTS regexchans(channel PRIMARY KEY, status)")
+        db.commit()
+        db_ready = True
+
+
+def get_status(db, channel):
+    row = db.execute("SELECT status FROM regexchans WHERE channel = ?", [channel]).fetchone()
+    if row:
+        return row[0]
+    else:
+        return None
+
+
+def set_status(db, channel, status):
+    db.execute("REPLACE INTO regexchans (channel, status) VALUES(?, ?)", [channel, status])
+    db.commit()
+
+
+def delete_status(db, channel):
+    db.execute("DELETE FROM regexchans WHERE channel = ?", [channel])
+    db.commit()
+
+
+def list_status(db):
+    row = db.execute("SELECT * FROM regexchans").fetchall()
+    result = None
+    for values in row:
+        if result:
+            result += u", {}: {}".format(values[0], values[1])
+        else:
+            result = u"{}: {}".format(values[0], values[1])
+    return result
+
+
+@hook.sieve
+def sieve_regex(bot, inp, func, kind, args):
+    db = bot.get_db_connection(inp.conn)
+    db_init(db)
+    if kind == 'regex' and inp.chan.startswith("#") and func.__name__ != 'factoid':
+        chanstatus = get_status(db, inp.chan)
+        if chanstatus != "ENABLED" and (chanstatus == "DISABLED" or not default_enabled):
+            print("Denying input.raw={}, kind={}, args={} from {}".format(inp.raw, kind, args, inp.chan))
+            return None
+        print("Allowing input.raw={}, kind={}, args={} from {}".format(inp.raw, kind, args, inp.chan))
+
+    return inp
+
+
+@hook.command(permissions=["botcontrol"])
+def enableregex(inp, db=None, message=None, notice=None, chan=None, nick=None):
+    db_init(db)
+    inp = inp.strip().lower()
+    if not inp:
+        channel = chan
+    elif inp.startswith("#"):
+        channel = inp
+    else:
+        channel = u"#{}".format(inp)
+
+    message(u"Enabling regex matching (youtube, etc) (issued by {})".format(nick), target=channel)
+    notice(u"Enabling regex matching (youtube, etc) in channel {}".format(channel))
+    set_status(db, channel, "ENABLED")
+
+
+@hook.command(permissions=["botcontrol"])
+def disableregex(inp, db=None, message=None, notice=None, chan=None, nick=None):
+    db_init(db)
+    inp = inp.strip().lower()
+    if not inp:
+        channel = chan
+    elif inp.startswith("#"):
+        channel = inp
+    else:
+        channel = u"#{}".format(inp)
+
+    message(u"Disabling regex matching (youtube, etc) (issued by {})".format(nick), target=channel)
+    notice(u"Disabling regex matching (youtube, etc) in channel {}".format(channel))
+    set_status(db, channel, "DISABLED")
+
+
+@hook.command(permissions=["botcontrol"])
+def resetregex(inp, db=None, message=None, notice=None, chan=None, nick=None):
+    db_init(db)
+    inp = inp.strip().lower()
+    if not inp:
+        channel = chan
+    elif inp.startswith("#"):
+        channel = inp
+    else:
+        channel = u"#{}".format(inp)
+
+    message(u"Resetting regex matching setting (youtube, etc) (issued by {})".format(nick), target=channel)
+    notice(u"Resetting regex matching setting (youtube, etc) in channel {}".format(channel))
+    delete_status(db, channel)
+
+
+@hook.command(permissions=["botcontrol"])
+def regexstatus(inp, db=None, chan=None):
+    db_init(db)
+    inp = inp.strip().lower()
+    if not inp:
+        channel = chan
+    elif inp.startswith("#"):
+        channel = inp
+    else:
+        channel = u"#{}".format(inp)
+
+    return u"Regex status for {}: {}".format(channel, get_status(db, channel))
+
+
+@hook.command(permissions=["botcontrol"])
+def listregex(inp, db=None):
+    db_init(db)
+    return list_status(db)
diff --git a/plugins/steal.py b/plugins/steal.py
new file mode 100644
index 0000000..78ccddb
--- /dev/null
+++ b/plugins/steal.py
@@ -0,0 +1,62 @@
+from util import hook
+from random import randint
+
+
+def db_init(db):
+    db.execute("CREATE TABLE IF NOT EXISTS stolen(word, PRIMARY KEY (word))")
+    db.commit()
+
+
+def get_random(db):
+    count = db.execute("SELECT COUNT(word) FROM stolen").fetchone()[0]
+    row = db.execute("SELECT word FROM stolen LIMIT 1 OFFSET ?", [randint(0, int(count-1))]).fetchone()
+    if row:
+        return row[0]
+    else:
+        return None
+
+
+def list_steals(db):
+    row = db.execute("SELECT word FROM stolen").fetchall()
+    return row
+
+
+def add_word(db, stolen):
+    db.execute("REPLACE INTO stolen (word) VALUES(?)", [stolen])
+    db.commit()
+
+
+@hook.command(autoHelp=False)
+@hook.command("steal", autoHelp=False)
+def stealit(inp, idb=None, nick=None, action=None):
+    """steal [[object] username]- Steals an object from a user or randomly chooses a previously stolen object if none is given"""
+    db_init(idb)
+    args = inp.strip().split()
+    if not args:
+        steal_from = nick
+        to_steal = get_random(idb)
+        action("steals {}'s {}".format(steal_from, to_steal))
+    elif len(args) < 2:
+        steal_from = args[0]
+        to_steal = get_random(idb)
+        action("steals {}'s {}".format(steal_from, to_steal))
+    else:
+        steal_from = args[len(args) - 1]
+        to_steal = " ".join(args[0:-1])
+        action("steals {}'s {}".format(steal_from, to_steal))
+        add_word(idb, to_steal)
+
+
+@hook.command(autoHelp=False, permissions=["adminonly"])
+def liststolen(inp, idb=None, reply=None):
+    db_init(idb)
+    text = False
+    for word in list_steals(idb):
+        if not text:
+            text = word[0]
+        else:
+            text += ", {}".format(word[0])
+        if len(text) > 400:
+            reply(text.rsplit(', ', 1)[0])
+            text = word[0]
+    return text
-- 
1.9.1

