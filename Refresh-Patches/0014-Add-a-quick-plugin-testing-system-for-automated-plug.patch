From a08f821babb9737f848976c47b7b5943703923b4 Mon Sep 17 00:00:00 2001
From: Dabo Ross <daboross@daboross.net>
Date: Tue, 22 Apr 2014 21:34:42 -0700
Subject: [PATCH] Add a "quick" plugin testing system, for automated plugin
 testing using a real bot object.

The quick plugin testing, or "qpt", can be enabled with the "--qpt" command line argument.

diff --git a/cloudbot/__init__.py b/cloudbot/__init__.py
index d2ee8b7..d763277 100644
--- a/cloudbot/__init__.py
+++ b/cloudbot/__init__.py
@@ -5,11 +5,11 @@ import os
 
 from .core import bot, connection, config, permissions, pluginmanager, events
 from .util import botvars, bucket, formatting, hook, http, pyexec, textgen, timeformat, timesince, urlnorm, web
-from .util import threaddump
+from .util import threaddump, qpt
 
 __all__ = ["core", "util", "bot", "connection", "config", "permissions", "pluginmanager", "events", "botvars", "bucket",
            "formatting", "hook", "http", "pyexec", "textgen", "timeformat", "timesince", "urlnorm", "web", "dev_mode",
-           "threaddump"]
+           "threaddump", "qpt"]
 
 
 def _setup():
diff --git a/cloudbot/core/connection.py b/cloudbot/core/connection.py
index 64df4de..2081e1d 100644
--- a/cloudbot/core/connection.py
+++ b/cloudbot/core/connection.py
@@ -5,8 +5,8 @@ import ssl
 from ssl import SSLContext
 
 from cloudbot.core.permissions import PermissionManager
-
 from cloudbot.core.events import BaseEvent
+from cloudbot.util import qpt
 
 irc_prefix_re = re.compile(r":([^ ]*) ([^ ]*) (.*)")
 irc_noprefix_re = re.compile(r"([^ ]*) (.*)")
@@ -235,10 +235,13 @@ class IRCConnection:
         else:
             self._connected = True
             self.logger.info("[{}] Connecting".format(self.readable_name))
-
-        self._transport, self._protocol = yield from self.loop.create_connection(
-            lambda: IRCProtocol(self), host=self.host, port=self.port, ssl=self.ssl_context,
-        )
+        if qpt.is_enabled():
+            self._transport = QPTTransport()
+            self._protocol = QPTProtocol(self)
+        else:
+            self._transport, self._protocol = yield from self.loop.create_connection(
+                lambda: IRCProtocol(self), host=self.host, port=self.port, ssl=self.ssl_context,
+            )
 
     def stop(self):
         if not self._connected:
@@ -358,3 +361,93 @@ class IRCProtocol(asyncio.Protocol):
             # Put the message into the queue to be handled
             # TODO: Do we want to directly call the handling method here?
             self.message_queue.put_nowait(event)
+
+
+class QPTProtocol:
+    def __init__(self, ircconn):
+        """
+        :type ircconn: IRCConnection
+        """
+        self.loop = ircconn.loop
+        self.logger = ircconn.logger
+        self.readable_name = ircconn.readable_name
+        self.describe_server = lambda: ircconn.describe_server()
+        self.botconn = ircconn.botconn
+        self.output_queue = ircconn.output_queue
+        self.message_queue = ircconn.message_queue
+        # input buffer
+        self._input_buffer = b""
+        # connected
+        self._connected = True
+        self.input_queue = asyncio.Queue(loop=self.botconn.bot.loop)
+        asyncio.async(qpt.run_tests(self.botconn.bot, self.botconn, self.input_queue, self.output_queue))
+        asyncio.async(self.recieve_loop())
+
+    @asyncio.coroutine
+    def recieve_loop(self):
+        while self._connected:
+            line = yield from self.input_queue.get()
+
+            # parse the line into a message
+            if line.startswith(":"):
+                prefix_line_match = irc_prefix_re.match(line)
+                if prefix_line_match is None:
+                    self.logger.critical("[{}] Received invalid IRC line '{}' from {}".format(
+                        self.readable_name, line, self.describe_server()
+                    ))
+                    continue
+
+                netmask_prefix, command, params = prefix_line_match.groups()
+                prefix = ":" + netmask_prefix  # TODO: Do we need to know this?
+                netmask_match = irc_netmask_re.match(netmask_prefix)
+                if netmask_match is None:
+                    # This isn't in the format of a netmask
+                    nick = netmask_prefix
+                    user = None
+                    host = None
+                    mask = netmask_prefix
+                else:
+                    nick = netmask_match.group(1)
+                    user = netmask_match.group(2)
+                    host = netmask_match.group(3)
+                    mask = netmask_prefix
+            else:
+                prefix = None
+                noprefix_line_match = irc_noprefix_re.match(line)
+                if noprefix_line_match is None:
+                    self.logger.critical("[{}] Received invalid IRC line '{}' from {}".format(
+                        self.readable_name, line, self.describe_server()
+                    ))
+                    continue
+                command = noprefix_line_match.group(1)
+                params = noprefix_line_match.group(2)
+                nick = None
+                user = None
+                host = None
+                mask = None
+
+            param_list = irc_param_re.findall(params)
+            if param_list:
+                # TODO: What the heck?
+                if param_list[-1].startswith(":"):
+                    param_list[-1] = param_list[-1][1:]
+                last_param = param_list[-1]
+            else:
+                last_param = None
+            # Set up parsed message
+            # TODO: What do you actually want to send here? Are prefix and params really necessary?
+            event = BaseEvent(conn=self.botconn, irc_raw=line, irc_prefix=prefix, irc_command=command,
+                              irc_paramlist=param_list, irc_message=last_param, nick=nick, user=user, host=host,
+                              mask=mask)
+            # we should also remember to ping the server if they ping us
+            if command == "PING":
+                self.output_queue.put_nowait("PONG :" + last_param)
+
+            # Put the message into the queue to be handled
+            # TODO: Do we want to directly call the handling method here?
+            self.message_queue.put_nowait(event)
+
+
+class QPTTransport:
+    def close(self):
+        pass
\ No newline at end of file
diff --git a/cloudbot/util/qpt.py b/cloudbot/util/qpt.py
new file mode 100644
index 0000000..887fe67
--- /dev/null
+++ b/cloudbot/util/qpt.py
@@ -0,0 +1,146 @@
+import asyncio
+import glob
+import importlib
+import inspect
+import os
+import traceback
+import sys
+
+
+def _test_hook(func, times):
+    specifications = inspect.getargspec(func)
+    args = specifications[0]
+    if args is None:
+        args = []
+    func._qpt_test = True
+    func._qpt_args = args
+    func._qpt_name = func.__module__ + "." + func.__name__
+    func._qpt_times = times
+    return func
+
+
+def print_both(text):
+    pass
+    print()
+    print("# " + text)
+    print()
+
+
+def print_before(text):
+    pass
+    print()
+    print("# " + text)
+
+
+def print_after(text):
+    pass
+    print("# " + text)
+    print()
+
+
+def test(times=1):
+    return lambda func: _test_hook(func, times)
+
+
+@asyncio.coroutine
+def run_test(func, bot, conn, input_queue, output_queue):
+    """
+    :type bot: cloudbot.core.bot.CloudBot
+    :type conn: cloudbot.core.connection.BotConnection
+    :type input_queue: asyncio.Queue
+    :type output_queue: asyncio.Queue
+    """
+    if not hasattr(func, "_qpt_test") or not func._qpt_test:
+        return
+
+    @asyncio.coroutine
+    def send(line):
+        if not line:
+            raise ValueError
+        else:
+            yield from input_queue.put(line.strip())
+
+    @asyncio.coroutine
+    def get():
+        future = asyncio.Task(output_queue.get())
+        yield from asyncio.wait_for(future, 5)
+        return future.result()
+
+    @asyncio.coroutine
+    def run_command(text):
+        yield from send(":TestUser!~user@example.com PRIVMSG #channel :" + conn.config.get("command_prefix") + text)
+
+    for test_number in range(func._qpt_times):
+        # each test might want to run multiple times, with the test number as an argument.
+        # We'll treat each of these times as a different test
+
+        if not bot.running:
+            return
+
+        while not output_queue.empty():
+            print_before("Removed '{}' from queue.".format((yield from output_queue.get())))
+
+        print_both("Running test {} #{}".format(func._qpt_name, test_number))
+        params = []
+        for arg in func._qpt_args:
+            if arg == "bot":
+                params.append(bot)
+            elif arg == "conn":
+                params.append(conn)
+            elif arg == "get":
+                params.append(get)
+            elif arg == "send":
+                params.append(send)
+            elif arg == "run_command":
+                params.append(run_command)
+            elif arg == "test_number":
+                params.append(test_number)
+            else:
+                print_before("Test {} #{} Failure: required invalid arg {}".format(func._qpt_name, test_number, arg))
+                continue
+        if not asyncio.iscoroutine(func):
+            func = asyncio.coroutine(func)
+        try:
+            yield from func(*params)
+        except asyncio.TimeoutError:
+            yield from asyncio.sleep(0.1)  # wait 0.1 second before saying results
+            print_before("Test {} #{} Failure: queue get failed".format(func._qpt_name, test_number))
+        except Exception:
+            yield from asyncio.sleep(0.1)  # wait 0.1 second before saying results
+            print_before("Test {} #{} Failure:".format(func._qpt_name, test_number))
+            sys.stdout.flush()
+            traceback.print_exc()
+        else:
+            yield from asyncio.sleep(0.1)  # wait 0.1 second before saying results
+            print_before("Test {} #{} success".format(func._qpt_name, test_number))
+
+
+@asyncio.coroutine
+def run_tests(bot, conn, input_queue, output_queue):
+    files = sorted(list(set(glob.glob(os.path.join("qpt_tests", '*.py')))))
+    print(files)
+    for file in files:
+        if not bot.running:
+            return
+        title = os.path.splitext(os.path.basename(file))[0]
+
+        if title == "__init__":
+            continue  # ignore __init__
+
+        try:
+            module = importlib.import_module("qpt_tests." + title)
+        except Exception:
+            print_both("Failed to start tests in {}:".format(title))
+            traceback.print_exc()
+            continue
+
+        for func in module.__dict__.values():
+
+            if not bot.running:
+                return
+
+            yield from run_test(func, bot, conn, input_queue, output_queue)
+
+
+def is_enabled():
+    return "--qpt" in sys.argv
diff --git a/qpt_tests/__init__.py b/qpt_tests/__init__.py
new file mode 100644
index 0000000..e69de29
-- 
1.9.3

