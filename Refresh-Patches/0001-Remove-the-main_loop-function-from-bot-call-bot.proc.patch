From 21a39db5870ef756cc39241f69ce6490fbdb1d26 Mon Sep 17 00:00:00 2001
From: Dabo Ross <daboross@daboross.net>
Date: Sun, 8 Jun 2014 00:27:02 -0700
Subject: [PATCH] Remove the main_loop function from bot, call bot.process
 directly from the connection.


diff --git a/cloudbot/core/bot.py b/cloudbot/core/bot.py
index f80a572..77516e8 100644
--- a/cloudbot/core/bot.py
+++ b/cloudbot/core/bot.py
@@ -17,6 +17,7 @@ from cloudbot.core.pluginmanager import PluginManager
 from cloudbot.core.events import BaseEvent, CommandEvent, RegexEvent
 from cloudbot.util import botvars, formatting
 
+
 logger_initialized = False
 
 
@@ -44,6 +45,8 @@ class CloudBot:
     :type db_session: sqlalchemy.orm.scoping.scoped_session
     :type db_metadata: sqlalchemy.sql.schema.MetaData
     :type loop: asyncio.events.AbstractEventLoop
+    :type stopped_future: asyncio.Future
+    :param: stopped_future: Future that will be given a result when the bot has stopped.
     """
 
     def __init__(self, loop=asyncio.get_event_loop()):
@@ -51,11 +54,10 @@ class CloudBot:
         self.loop = loop
         self.start_time = time.time()
         self.running = True
+        # future which will be called when the bot stops
+        self.stopped_future = asyncio.Future(loop=self.loop)
         self.do_restart = False
 
-        # stores all queued messages from all connections
-        self.queued_events = asyncio.Queue(loop=self.loop)
-
         # stores each bot server connection
         self.connections = []
 
@@ -109,7 +111,10 @@ class CloudBot:
         Starts CloudBot.
         This will first load plugins, then connect to IRC, then start the main loop for processing input.
         """
-        self.loop.run_until_complete(self.main_loop())
+        # Initializes the bot, plugins and connections
+        self.loop.run_until_complete(self._init_routine())
+        # Wait till the bot stops.
+        self.loop.run_until_complete(self.stopped_future)
         self.loop.close()
 
     def create_connections(self):
@@ -154,10 +159,8 @@ class CloudBot:
             connection.stop()
 
         self.running = False
-        # We need to make sure that the main loop actually exists after this method is called. This will ensure that the
-        # blocking queued_events.get() method is executed, then the method will stop without processing it because
-        # self.running = False
-        self.queued_events.put_nowait(StopIteration)
+        # Give the stopped_future a result, so that run() will exit
+        self.stopped_future.set_result(None)
 
     def restart(self, reason=None):
         """shuts the bot down and restarts it"""
@@ -165,35 +168,37 @@ class CloudBot:
         self.stop(reason)
 
     @asyncio.coroutine
-    def main_loop(self):
-        # load plugins
+    def _load_plugins(self):
+        """
+        Initialization routine - loads plugins
+        """
         yield from self.plugin_manager.load_all(os.path.abspath("plugins"))
+
+    @asyncio.coroutine
+    def _connect(self):
+        """
+        Initialization routine - starts connections
+        """
+        yield from asyncio.gather(*[conn.connect() for conn in self.connections], loop=self.loop)
+
+    @asyncio.coroutine
+    def _init_routine(self):
+        yield from self._load_plugins()
+
         # if we we're stopped while loading plugins, cancel that and just stop
         if not self.running:
+            # set the stopped_future result so that the run() method will exit right away
+            self.stopped_future.set_result(None)
             return
 
         if cloudbot.dev_mode.get("plugin_reloading"):
             # start plugin reloader
             self.reloader.start(os.path.abspath("plugins"))
 
-        # start connections
-        yield from asyncio.gather(*[conn.connect() for conn in self.connections], loop=self.loop)
+        yield from self._connect()
+
         # run a manual garbage collection cycle, to clean up any unused objects created during initialization
         gc.collect()
-        # start main loop
-        self.logger.info("Starting main loop")
-        while self.running:
-            # This function will wait until a new message is received.
-            event = yield from self.queued_events.get()
-
-            if not self.running:
-                # When the bot is stopped, StopIteration is put into the queue to make sure that
-                # self.queued_events.get() doesn't block this thread forever.
-                # But we don't actually want to process that message, so if we're stopped, just exit.
-                return
-
-            # process the message
-            asyncio.async(self.process(event), loop=self.loop)
 
     @asyncio.coroutine
     def process(self, event):
diff --git a/cloudbot/core/connection.py b/cloudbot/core/connection.py
index 64df4de..c6e9790 100644
--- a/cloudbot/core/connection.py
+++ b/cloudbot/core/connection.py
@@ -27,9 +27,7 @@ class BotConnection:
     :type nick: str
     :type vars: dict
     :type history: dict[str, list[tuple]]
-    :type message_queue: queue.Queue
-    :type input_queue: queue.Queue
-    :type output_queue: queue.Queue
+    :type output_queue: asyncio.Queue
     :type connection: IRCConnection
     :type permissions: PermissionManager
     :type connected: bool
@@ -73,9 +71,6 @@ class BotConnection:
         self.vars = {}
         self.history = {}
 
-        self.message_queue = bot.queued_events  # global parsed message queue, for parsed received messages
-
-        self.input_queue = asyncio.Queue(loop=self.loop)
         self.output_queue = asyncio.Queue(loop=self.loop)
 
         # create permissions manager
@@ -181,7 +176,6 @@ class IRCConnection:
     :type port: int
     :type use_ssl: bool
     :type output_queue: asyncio.Queue
-    :type message_queue: asyncio.Queue
     :type botconn: BotConnection
     :type ignore_cert_errors: bool
     :type timeout: int
@@ -198,7 +192,6 @@ class IRCConnection:
         self.port = conn.port
         self.use_ssl = conn.ssl
         self.output_queue = conn.output_queue  # lines to be sent out
-        self.message_queue = conn.message_queue  # global queue for parsed lines that were received
         self.loop = conn.loop
         self.botconn = conn
 
@@ -258,7 +251,7 @@ class IRCProtocol(asyncio.Protocol):
         self.describe_server = lambda: ircconn.describe_server()
         self.botconn = ircconn.botconn
         self.output_queue = ircconn.output_queue
-        self.message_queue = ircconn.message_queue
+        self.bot = ircconn.botconn.bot
         # input buffer
         self._input_buffer = b""
         # connected
@@ -355,6 +348,5 @@ class IRCProtocol(asyncio.Protocol):
             if command == "PING":
                 self.output_queue.put_nowait("PONG :" + last_param)
 
-            # Put the message into the queue to be handled
-            # TODO: Do we want to directly call the handling method here?
-            self.message_queue.put_nowait(event)
+            # handle the message, async
+            asyncio.async(self.bot.process(event))
-- 
2.0.0

