From c2af65f37b8ad3da9cddceb8f0b1ab3c3e0396fe Mon Sep 17 00:00:00 2001
From: Dabo Ross <daboross@daboross.net>
Date: Tue, 17 Jun 2014 23:54:41 -0500
Subject: [PATCH] Complete rewrite of log plugin


diff --git a/plugins/log.py b/plugins/log.py
index 6522fba..b0c9697 100644
--- a/plugins/log.py
+++ b/plugins/log.py
@@ -1,95 +1,171 @@
-"""
-log.py: written by Scaevolus 2009
-
-edited 2014
-"""
 import asyncio
 import os
 import codecs
 import time
-import re
-import sys
 
+import cloudbot
 from cloudbot import hook
+from cloudbot.core.events import EventType
 
-log_dir = os.path.join(os.path.abspath("."), "logs")
 
-stream_cache = {}  # '{server} {chan}': (filename, fd)
 
-formats = {
-    "PRIVMSG": "[{server}:{chan}] <{nick}> {message}",
-    "PART": "[{server}:{chan}] -!- {nick} [{user}@{host}] has left {chan}",
-    "JOIN": "[{server}:{chan}] -!- {nick} [{user}@{host}] has joined {chan}",
-    "MODE": "[{server}:{chan}] -!- mode/{chan} [{param_tail}] by {nick}",
-    "KICK": "[{server}:{chan}] -!- {param1} was kicked from {chan} by {nick} ({message})",
-    "TOPIC": "[{server}:{chan}] -!- {nick} changed the topic of {chan} to: {message}",
-    "QUIT": "[{server}] -!- {nick} has quit ({message})",
-    "NOTICE": "[{server}:{chan}] -{nick}- {message}",
-    "default": "[{server}] {irc_raw}"
-}
 
-action_ctcp_format = "[{server}:{chan}] * {nick} {ctcpmsg}"
-known_ctcp_format = "[{server}:{chan}] {nick} has requested CTCP {ctcpcmd}: {ctcpmsg}"
-unknown_ctcp_format = "[{server}:{chan}] {nick} ({user}@{host}) requested unknown CTCP {ctcpcmd}: {ctcpmsg}"
 
 
-def get_ctcp_format(ctcpcmd):
-    if ctcpcmd.lower() == "action":
-        return action_ctcp_format
-    elif ctcpcmd.lower() in ("version", "ping", "time", "finger"):
-        return known_ctcp_format
-    else:
-        return unknown_ctcp_format
 
 
-irc_color_re = re.compile(r"(\x03(\d+,\d+|\d)|[\x0f\x02\x16\x1f])")
 
 
-def get_log_filename(server, chan):
-    _time = time.gmtime()
-    return os.path.join(log_dir, time.strftime('%Y', _time), server, chan,
-                        (time.strftime("{}.%m-%d.log".format(chan), _time)).lower())
 
 
-def beautify(event):
+
+
+
+
+
+
+
+
+# +---------+
+# | Formats |
+# +---------+
+from cloudbot.util.formatting import strip_colors
+
+base_formats = {
+    EventType.message: "[{server}:{channel}] <{nick}> {content}",
+    EventType.notice: "[{server}:{channel}] -{nick}- {content}",
+    EventType.action: "[{server}:{channel}] * {nick} {content}",
+    EventType.join: "[{server}:{channel}] -!- {nick} [{user}@{host}] has joined",
+    EventType.part: "[{server}:{channel}] -!- {nick} [{user}@{host}] has left ({content})",
+    EventType.kick: "[{server}:{channel}] -!- {nick} has kicked {target} ({content})",
+}
+
+irc_formats = {
+    "MODE": "[{server}:{channel}] -!- mode/{channel} [{param_tail}] by {nick}",
+    "TOPIC": "[{server}:{channel}] -!- {nick} has changed the topic to: {content}",
+    "QUIT": "[{server}] -!- {nick} has quit ({content})",
+    "INVITE": "[{server}] -!- {nick} has invited {target} to {chan}",
+    "NICK": "[{server}] {nick} is now known as {content}",
+}
+
+irc_default = "[{server}] {irc_raw}"
+
+ctcp_known = "[{server}:{channel}] {nick} [{user}@{host}] has requested CTCP {ctcp_command}"
+ctcp_known_with_message = ("[{server}:{channel}] {nick} [{user}@{host}] "
+                           "has requested CTCP {ctcp_command}: {ctcp_message}")
+ctcp_unknown = "[{server}:{channel}] {nick} [{user}@{host}] has requested unknown CTCP {ctcp_command}"
+ctcp_unknown_with_message = ("[{server}:{channel}] {nick} [{user}@{host}] "
+                             "has requested unknown CTCP {ctcp_command}: {ctcp_message}")
+
+
+# +------------+
+# | Formatting |
+# +------------+
+
+def format_event(event):
     """
+    Format an event
     :type event: cloudbot.core.events.BaseEvent
     :rtype: str
     """
-    logging = event.bot.config.get("logging", {})
-    if event.irc_command in ("375", "372", "376") and not logging.get("show_motd", True):
-        return None
-    if event.irc_command in ("003", "005", "250", "251", "252", "253", "254", "255", "256") and not logging.get("show_server_info", True):
-        return None
-    if event.irc_command == "PING":
-        return None
-    log_format = formats.get(event.irc_command)
-    if not log_format:
-        return formats["default"].format(server=event.conn.readable_name, irc_raw=event.irc_raw)
+
+    # Setup arguments
 
     args = {
-        "server": event.conn.readable_name, "param_tail": " ".join(event.irc_paramlist[1:]),
-        "message": irc_color_re.sub("", event.irc_message), "nick": event.nick, "chan": event.chan,
+        "server": event.conn.readable_name, "target": event.target, "channel": event.chan, "nick": event.nick,
         "user": event.user, "host": event.host
     }
 
-    _len = len(event.irc_paramlist)
-    for n, p in enumerate(event.irc_paramlist):
-        args["param" + str(n)] = p
-        args["param_" + str(abs(n - _len))] = p
+    if event.content is not None:
+        # We can't strip colors from None
+        args["content"] = strip_colors(event.content)
+    else:
+        args["content"] = None
+
+    # Try formatting with non-connection-specific formats
+
+    if event.type in base_formats:
+        return base_formats[event.type].format(**args)
 
-    if event.irc_command == "PRIVMSG" and event.irc_message.count("\x01") >= 2:
-        ctcp_split = event.irc_message.split("\x01", 2)[1].split(' ', 1)
+    # Try formatting with IRC-formats, if this is an IRC event
+    if event.irc_command is not None:
+        return format_irc_event(event, args)
 
-        args["ctcpcmd"] = ctcp_split[0]
-        if len(ctcp_split) < 2:
-            args["ctcpmsg"] = ""
+
+def format_irc_event(event, args):
+    """
+    Format an IRC event
+    :param event: The event to format
+    :param args: The pre-created arguments
+    :return:
+    """
+
+    # Setup arguments
+
+    # Add the IRC-specific param_tail argument to the generic arguments
+    args["param_tail"] = " ".join(event.irc_paramlist[1:])
+
+    # Try formatting with the IRC command
+
+    if event.irc_command in irc_formats:
+        return irc_formats[event.irc_command].format(**args)
+
+    # Try formatting with the CTCP command
+
+    if event.irc_ctcp_text is not None:
+        ctcp_command, ctcp_message = event.irc_ctcp_text.split(None, 1)
+        args["ctcp_command"] = ctcp_command
+        args["ctcp_message"] = ctcp_message
+
+        if ctcp_command in ("VERSION", "PING", "TIME", "FINGER"):
+            if ctcp_message:
+                return ctcp_known_with_message.format(**args)
+            else:
+                return ctcp_known.format(**args)
         else:
-            args["ctcpmsg"] = ctcp_split[1]
+            if ctcp_message:
+                return ctcp_unknown_with_message.format(**args)
+            else:
+                return ctcp_unknown.format(**args)
 
-        log_format = get_ctcp_format(args["ctcpcmd"])
+    # No formats have been found, resort to the default
 
-    return log_format.format(**args)
+    # Check if the command is blacklisted for raw output
+
+    logging_config = event.bot.config.get("logging", {})
+
+    if not logging_config.get("show_motd", True) and event.irc_command in ("375", "372", "376"):
+        return None
+    elif not logging_config.get("show_server_info", True) and event.irc_command in (
+            "003", "005", "250", "251", "252", "253", "254", "255", "256"):
+        return None
+    elif event.irc_command == "PING":
+        return None
+
+    # Format using the default raw format
+
+    return irc_default.format(server=event.conn.readable_name, irc_raw=event.irc_raw)
+
+# +--------------+
+# | File logging |
+# +--------------+
+
+file_format = "{server}_{chan}_%Y%m%d.log"
+raw_file_format = "{server}_%Y%m%d.log"
+
+folder_format = "%Y"
+
+# Stream cache, (server, chan) -> (file_name, stream)
+stream_cache = {}
+# Raw stream cache, server -> (file_name, stream)
+raw_cache = {}
+
+
+def get_log_filename(server, chan):
+    current_time = time.gmtime()
+    folder_name = time.strftime(folder_format, current_time)
+    file_name = time.strftime(file_format.format(chan=chan, server=server), current_time).lower()
+    return os.path.join(cloudbot.log_dir, folder_name, file_name)
 
 
 def get_log_stream(server, chan):
@@ -97,44 +173,71 @@ def get_log_stream(server, chan):
     cache_key = (server, chan)
     old_filename, log_stream = stream_cache.get(cache_key, (None, None))
 
-    if new_filename != old_filename:  # we need to open a new stream
-        if log_stream:
-            # already open stream needs to be closed
+    # If the filename has changed since we opened the stream, we should re-open
+    if new_filename != old_filename:
+        # If we had a stream open before, we should close it
+        if log_stream is not None:
             log_stream.flush()
             log_stream.close()
-        data_dir = os.path.dirname(new_filename)
-        if not os.path.exists(data_dir):
-            os.makedirs(data_dir)
+
+        log_dir = os.path.dirname(new_filename)
+        os.makedirs(log_dir, exist_ok=True)
+
         log_stream = codecs.open(new_filename, "a", "utf-8")
         stream_cache[cache_key] = (new_filename, log_stream)
 
     return log_stream
 
 
+def get_raw_log_filename(server):
+    current_time = time.gmtime()
+    folder_name = time.strftime(folder_format, current_time)
+    file_name = time.strftime(file_format.format(server=server), current_time).lower()
+    return os.path.join(cloudbot.log_dir, "raw", folder_name, file_name)
+
+
+def get_raw_log_stream(server):
+    new_filename = get_raw_log_filename(server)
+    old_filename, log_stream = stream_cache.get(server, (None, None))
+
+    # If the filename has changed since we opened the stream, we should re-open
+    if new_filename != old_filename:
+        # If we had a stream open before, we should close it
+        if log_stream is not None:
+            log_stream.flush()
+            log_stream.close()
+
+        log_dir = os.path.dirname(new_filename)
+        os.makedirs(log_dir, exist_ok=True)
+
+        log_stream = codecs.open(new_filename, "a", "utf-8")
+        stream_cache[server] = (new_filename, log_stream)
+
+    return log_stream
+
+
 @hook.irc_raw("*", singlethread=True)
-def log(event):
+def log_raw(event):
     """
     :type event: cloudbot.core.events.BaseEvent
     """
-    raw_log = get_log_stream(event.conn.name, "raw")
-    raw_log.write(event.irc_raw + "\n")
+    logging_config = event.bot.config.get("logging", {})
+    if not logging_config.get("raw_file_log", False):
+        return
+
+    get_raw_log_stream(event.conn.name).write(event.irc_raw + "\n")
 
-    human_readable = beautify(event)
 
-    if human_readable:
-        # beautify will return an empty string if event.irc_command is "PING"
+@hook.irc_raw("*", singlethread=True)
+def log(event):
+    """
+    :type event: cloudbot.core.events.BaseEvent
+    """
+    text = format_event(event)
+
+    if text is not None:
         if event.irc_command in ["PRIVMSG", "PART", "JOIN", "MODE", "TOPIC", "QUIT", "NOTICE"] and event.chan:
-            channel = event.chan
-            # temporary fix until presence tracking is implemented:
-        elif event.irc_command == 'QUIT':
-            channel = 'quit'
-        elif event.irc_command == 'NICK':
-            channel = 'nick'
-        else:
-            channel = None
-        if channel:
-            channel_log = get_log_stream(event.conn.name, channel)
-            channel_log.write(human_readable + '\n')
+            get_log_stream(event.conn.name, event.chan).write(text + '\n')
 
 
 # Log console separately to prevent lag
@@ -145,7 +248,15 @@ def console_log(bot, event):
     :type bot: cloudbot.core.bot.CloudBot
     :type event: cloudbot.core.events.BaseEvent
     """
-    human_readable = beautify(event)
-    if human_readable:
-        # beautify will return an empty string if event.irc_command is "PING"
-        bot.logger.info(human_readable)
+    text = format_event(event)
+    if text is not None:
+        bot.logger.info(text)
+
+
+# TODO: @hook.onstop() for when unloaded
+@hook.command("flushlog", permissions=["adminonly"])
+def flush_log():
+    for stream in stream_cache.values():
+        stream.flush()
+    for stream in raw_cache.values():
+        stream.flush()
-- 
2.0.0

